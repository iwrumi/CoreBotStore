{"file_contents":{"advanced_data_manager.py":{"content":"from datetime import datetime\nimport json\nimport os\nimport uuid\nfrom sqlalchemy.orm import sessionmaker\nfrom sqlalchemy import and_, or_, desc, asc\nfrom database_models import (\n    DatabaseManager, User, Product, Order, OrderItem, Voucher, \n    Payment, Broadcast, Settings, CustomerSupport, init_database\n)\n\nclass AdvancedDataManager:\n    def __init__(self):\n        self.db_manager = init_database()\n        self._add_balance_methods()\n        \n    def get_session(self):\n        \"\"\"Get database session\"\"\"\n        return self.db_manager.get_session()\n    \n    # ===== USER MANAGEMENT =====\n    def get_or_create_user(self, telegram_id, first_name, last_name=\"\", username=\"\"):\n        \"\"\"Get existing user or create new one\"\"\"\n        session = self.get_session()\n        try:\n            user = session.query(User).filter(User.telegram_id == str(telegram_id)).first()\n            if not user:\n                user = User(\n                    telegram_id=str(telegram_id),\n                    first_name=first_name,\n                    last_name=last_name,\n                    username=username\n                )\n                session.add(user)\n                session.commit()\n                session.refresh(user)\n            else:\n                # Update user info if changed\n                user.first_name = first_name\n                user.last_name = last_name or user.last_name\n                user.username = username or user.username\n                user.last_activity = datetime.utcnow()\n                session.commit()\n            \n            return user.to_dict()\n        finally:\n            session.close()\n    \n    def get_users(self, is_admin=None, is_banned=None):\n        \"\"\"Get all users with optional filters\"\"\"\n        session = self.get_session()\n        try:\n            query = session.query(User)\n            if is_admin is not None:\n                query = query.filter(User.is_admin == is_admin)\n            if is_banned is not None:\n                query = query.filter(User.is_banned == is_banned)\n            \n            users = query.order_by(desc(User.created_at)).all()\n            return [user.to_dict() for user in users]\n        finally:\n            session.close()\n    \n    def update_user(self, telegram_id, update_data):\n        \"\"\"Update user information\"\"\"\n        session = self.get_session()\n        try:\n            user = session.query(User).filter(User.telegram_id == str(telegram_id)).first()\n            if user:\n                for key, value in update_data.items():\n                    if hasattr(user, key):\n                        setattr(user, key, value)\n                session.commit()\n                return user.to_dict()\n            return None\n        finally:\n            session.close()\n    \n    # ===== PRODUCT MANAGEMENT =====\n    def get_products(self, is_active=True, category=None):\n        \"\"\"Get products with optional filters\"\"\"\n        session = self.get_session()\n        try:\n            query = session.query(Product)\n            if is_active is not None:\n                query = query.filter(Product.is_active == is_active)\n            if category:\n                query = query.filter(Product.category == category)\n            \n            products = query.order_by(asc(Product.name)).all()\n            return [product.to_dict() for product in products]\n        finally:\n            session.close()\n    \n    def get_product(self, product_id):\n        \"\"\"Get single product by ID\"\"\"\n        session = self.get_session()\n        try:\n            product = session.query(Product).filter(Product.id == product_id).first()\n            return product.to_dict() if product else None\n        finally:\n            session.close()\n    \n    def add_product(self, name, description, price, category, image_url=\"\", stock=0, **kwargs):\n        \"\"\"Add new product\"\"\"\n        session = self.get_session()\n        try:\n            product = Product(\n                name=name,\n                description=description,\n                price=price,\n                category=category,\n                image_url=image_url,\n                stock=stock,\n                is_active=kwargs.get('is_active', True),\n                is_featured=kwargs.get('is_featured', False),\n                tags=kwargs.get('tags', []),\n                specifications=kwargs.get('specifications', {})\n            )\n            session.add(product)\n            session.commit()\n            session.refresh(product)\n            return product.to_dict()\n        finally:\n            session.close()\n    \n    def update_product(self, product_id, update_data):\n        \"\"\"Update product\"\"\"\n        session = self.get_session()\n        try:\n            product = session.query(Product).filter(Product.id == product_id).first()\n            if product:\n                for key, value in update_data.items():\n                    if hasattr(product, key):\n                        setattr(product, key, value)\n                product.updated_at = datetime.utcnow()\n                session.commit()\n                return product.to_dict()\n            return None\n        finally:\n            session.close()\n    \n    def delete_product(self, product_id):\n        \"\"\"Delete product\"\"\"\n        session = self.get_session()\n        try:\n            product = session.query(Product).filter(Product.id == product_id).first()\n            if product:\n                session.delete(product)\n                session.commit()\n                return True\n            return False\n        finally:\n            session.close()\n    \n    def get_categories(self):\n        \"\"\"Get all product categories\"\"\"\n        session = self.get_session()\n        try:\n            categories = session.query(Product.category).filter(Product.is_active == True).distinct().all()\n            return [cat[0] for cat in categories]\n        finally:\n            session.close()\n    \n    # ===== ORDER MANAGEMENT =====\n    def create_order(self, user_telegram_id, items, shipping_address=\"\", notes=\"\", voucher_code=\"\"):\n        \"\"\"Create new order\"\"\"\n        session = self.get_session()\n        try:\n            # Get user\n            user = session.query(User).filter(User.telegram_id == str(user_telegram_id)).first()\n            if not user:\n                return None\n            \n            # Generate order number\n            order_number = f\"ORD-{datetime.now().strftime('%Y%m%d')}-{str(uuid.uuid4())[:8].upper()}\"\n            \n            # Create order\n            order = Order(\n                order_number=order_number,\n                user_id=user.id,\n                shipping_address=shipping_address,\n                notes=notes,\n                voucher_code=voucher_code\n            )\n            session.add(order)\n            session.flush()  # Get order ID\n            \n            # Add order items and calculate totals\n            subtotal = 0\n            for product_id, item_data in items.items():\n                product = session.query(Product).filter(Product.id == int(product_id)).first()\n                if product and product.stock >= item_data['quantity']:\n                    # Create order item\n                    order_item = OrderItem(\n                        order_id=order.id,\n                        product_id=product.id,\n                        quantity=item_data['quantity'],\n                        price=product.price,\n                        total=product.price * item_data['quantity']\n                    )\n                    session.add(order_item)\n                    \n                    # Update product stock\n                    product.stock -= item_data['quantity']\n                    \n                    subtotal += order_item.total\n            \n            # Apply voucher discount if applicable\n            discount = 0\n            if voucher_code:\n                voucher = session.query(Voucher).filter(\n                    and_(\n                        Voucher.code == voucher_code,\n                        Voucher.is_active == True,\n                        or_(Voucher.valid_until.is_(None), Voucher.valid_until > datetime.utcnow()),\n                        Voucher.minimum_order <= subtotal,\n                        or_(Voucher.usage_limit == 0, Voucher.usage_count < Voucher.usage_limit)\n                    )\n                ).first()\n                \n                if voucher:\n                    if voucher.discount_type == 'percentage':\n                        discount = subtotal * (voucher.discount_value / 100)\n                        if voucher.maximum_discount > 0:\n                            discount = min(discount, voucher.maximum_discount)\n                    else:  # fixed_amount\n                        discount = voucher.discount_value\n                    \n                    # Update voucher usage\n                    voucher.usage_count += 1\n            \n            # Calculate totals\n            order.subtotal = subtotal\n            order.discount = discount\n            order.total = subtotal - discount\n            \n            # Update user stats\n            user.order_count += 1\n            user.total_spent += order.total\n            \n            session.commit()\n            session.refresh(order)\n            \n            return order.to_dict()\n        finally:\n            session.close()\n    \n    def get_orders(self, user_telegram_id=None, status=None, limit=None):\n        \"\"\"Get orders with optional filters\"\"\"\n        session = self.get_session()\n        try:\n            query = session.query(Order)\n            \n            if user_telegram_id:\n                user = session.query(User).filter(User.telegram_id == str(user_telegram_id)).first()\n                if user:\n                    query = query.filter(Order.user_id == user.id)\n                else:\n                    return []\n            \n            if status:\n                query = query.filter(Order.status == status)\n            \n            query = query.order_by(desc(Order.created_at))\n            if limit:\n                query = query.limit(limit)\n            \n            orders = query.all()\n            return [order.to_dict() for order in orders]\n        finally:\n            session.close()\n    \n    def get_order(self, order_id):\n        \"\"\"Get single order by ID\"\"\"\n        session = self.get_session()\n        try:\n            order = session.query(Order).filter(Order.id == order_id).first()\n            return order.to_dict() if order else None\n        finally:\n            session.close()\n    \n    def update_order_status(self, order_id, status):\n        \"\"\"Update order status\"\"\"\n        session = self.get_session()\n        try:\n            order = session.query(Order).filter(Order.id == order_id).first()\n            if order:\n                order.status = status\n                order.updated_at = datetime.utcnow()\n                session.commit()\n                return order.to_dict()\n            return None\n        finally:\n            session.close()\n    \n    def get_user_orders(self, user_telegram_id):\n        \"\"\"Get orders for specific user\"\"\"\n        return self.get_orders(user_telegram_id=user_telegram_id)\n    \n    # ===== VOUCHER MANAGEMENT =====\n    def create_voucher(self, code, name, discount_type, discount_value, **kwargs):\n        \"\"\"Create new voucher\"\"\"\n        session = self.get_session()\n        try:\n            voucher = Voucher(\n                code=code.upper(),\n                name=name,\n                description=kwargs.get('description', ''),\n                discount_type=discount_type,\n                discount_value=discount_value,\n                minimum_order=kwargs.get('minimum_order', 0),\n                maximum_discount=kwargs.get('maximum_discount', 0),\n                usage_limit=kwargs.get('usage_limit', 0),\n                valid_from=kwargs.get('valid_from', datetime.utcnow()),\n                valid_until=kwargs.get('valid_until')\n            )\n            session.add(voucher)\n            session.commit()\n            session.refresh(voucher)\n            return voucher.to_dict()\n        finally:\n            session.close()\n    \n    def get_vouchers(self, is_active=None):\n        \"\"\"Get vouchers\"\"\"\n        session = self.get_session()\n        try:\n            query = session.query(Voucher)\n            if is_active is not None:\n                query = query.filter(Voucher.is_active == is_active)\n            \n            vouchers = query.order_by(desc(Voucher.created_at)).all()\n            return [voucher.to_dict() for voucher in vouchers]\n        finally:\n            session.close()\n    \n    def validate_voucher(self, code, order_total):\n        \"\"\"Validate voucher code\"\"\"\n        session = self.get_session()\n        try:\n            voucher = session.query(Voucher).filter(\n                and_(\n                    Voucher.code == code.upper(),\n                    Voucher.is_active == True,\n                    or_(Voucher.valid_until.is_(None), Voucher.valid_until > datetime.utcnow()),\n                    Voucher.minimum_order <= order_total,\n                    or_(Voucher.usage_limit == 0, Voucher.usage_count < Voucher.usage_limit)\n                )\n            ).first()\n            \n            if voucher:\n                # Calculate discount\n                if voucher.discount_type == 'percentage':\n                    discount = order_total * (voucher.discount_value / 100)\n                    if voucher.maximum_discount > 0:\n                        discount = min(discount, voucher.maximum_discount)\n                else:  # fixed_amount\n                    discount = voucher.discount_value\n                \n                return {\n                    'valid': True,\n                    'voucher': voucher.to_dict(),\n                    'discount_amount': discount\n                }\n            \n            return {'valid': False, 'message': 'Invalid or expired voucher code'}\n        finally:\n            session.close()\n    \n    # ===== PAYMENT MANAGEMENT =====\n    def create_payment(self, user_telegram_id, amount, payment_method, **kwargs):\n        \"\"\"Create payment record\"\"\"\n        session = self.get_session()\n        try:\n            user = session.query(User).filter(User.telegram_id == str(user_telegram_id)).first()\n            if not user:\n                return None\n            \n            transaction_id = f\"PAY-{datetime.now().strftime('%Y%m%d')}-{str(uuid.uuid4())[:8].upper()}\"\n            \n            payment = Payment(\n                transaction_id=transaction_id,\n                user_id=user.id,\n                order_id=kwargs.get('order_id'),\n                amount=amount,\n                currency=kwargs.get('currency', 'PHP'),\n                payment_method=payment_method,\n                reference_number=kwargs.get('reference_number', ''),\n                notes=kwargs.get('notes', ''),\n                proof_image=kwargs.get('proof_image', '')\n            )\n            session.add(payment)\n            session.commit()\n            session.refresh(payment)\n            return payment.to_dict()\n        finally:\n            session.close()\n    \n    def get_payments(self, user_telegram_id=None, status=None):\n        \"\"\"Get payments\"\"\"\n        session = self.get_session()\n        try:\n            query = session.query(Payment)\n            \n            if user_telegram_id:\n                user = session.query(User).filter(User.telegram_id == str(user_telegram_id)).first()\n                if user:\n                    query = query.filter(Payment.user_id == user.id)\n                else:\n                    return []\n            \n            if status:\n                query = query.filter(Payment.status == status)\n            \n            payments = query.order_by(desc(Payment.created_at)).all()\n            return [payment.to_dict() for payment in payments]\n        finally:\n            session.close()\n    \n    def verify_payment(self, payment_id, verified_by):\n        \"\"\"Mark payment as verified\"\"\"\n        session = self.get_session()\n        try:\n            payment = session.query(Payment).filter(Payment.id == payment_id).first()\n            if payment:\n                payment.status = 'completed'\n                payment.verified_at = datetime.utcnow()\n                payment.verified_by = verified_by\n                \n                # Update related order if exists\n                if payment.order_id:\n                    order = session.query(Order).filter(Order.id == payment.order_id).first()\n                    if order:\n                        order.payment_status = 'paid'\n                        order.status = 'confirmed'\n                \n                session.commit()\n                return payment.to_dict()\n            return None\n        finally:\n            session.close()\n    \n    # ===== BROADCAST MANAGEMENT =====\n    def create_broadcast(self, title, message, created_by, **kwargs):\n        \"\"\"Create broadcast\"\"\"\n        session = self.get_session()\n        try:\n            broadcast = Broadcast(\n                title=title,\n                message=message,\n                image_url=kwargs.get('image_url', ''),\n                target_users=kwargs.get('target_users', 'all'),\n                scheduled_at=kwargs.get('scheduled_at'),\n                created_by=created_by\n            )\n            session.add(broadcast)\n            session.commit()\n            session.refresh(broadcast)\n            return broadcast.to_dict()\n        finally:\n            session.close()\n    \n    def get_broadcasts(self, status=None):\n        \"\"\"Get broadcasts\"\"\"\n        session = self.get_session()\n        try:\n            query = session.query(Broadcast)\n            if status:\n                query = query.filter(Broadcast.status == status)\n            \n            broadcasts = query.order_by(desc(Broadcast.created_at)).all()\n            return [broadcast.to_dict() for broadcast in broadcasts]\n        finally:\n            session.close()\n    \n    def update_broadcast_status(self, broadcast_id, status, sent_count=0, failed_count=0):\n        \"\"\"Update broadcast status\"\"\"\n        session = self.get_session()\n        try:\n            broadcast = session.query(Broadcast).filter(Broadcast.id == broadcast_id).first()\n            if broadcast:\n                broadcast.status = status\n                broadcast.sent_count = sent_count\n                broadcast.failed_count = failed_count\n                if status == 'sent':\n                    broadcast.sent_at = datetime.utcnow()\n                session.commit()\n                return broadcast.to_dict()\n            return None\n        finally:\n            session.close()\n    \n    # ===== SETTINGS MANAGEMENT =====\n    def get_setting(self, key, default=None):\n        \"\"\"Get setting value\"\"\"\n        session = self.get_session()\n        try:\n            setting = session.query(Settings).filter(Settings.key == key).first()\n            return setting.value if setting else default\n        finally:\n            session.close()\n    \n    def set_setting(self, key, value, description=\"\"):\n        \"\"\"Set setting value\"\"\"\n        session = self.get_session()\n        try:\n            setting = session.query(Settings).filter(Settings.key == key).first()\n            if setting:\n                setting.value = value\n                setting.updated_at = datetime.utcnow()\n                if description:\n                    setting.description = description\n            else:\n                setting = Settings(key=key, value=value, description=description)\n                session.add(setting)\n            \n            session.commit()\n            return setting.to_dict()\n        finally:\n            session.close()\n    \n    def get_all_settings(self):\n        \"\"\"Get all settings\"\"\"\n        session = self.get_session()\n        try:\n            settings = session.query(Settings).all()\n            return {setting.key: setting.value for setting in settings}\n        finally:\n            session.close()\n    \n    # ===== CUSTOMER SUPPORT =====\n    def create_support_ticket(self, user_telegram_id, subject, message, category=\"general\"):\n        \"\"\"Create customer support ticket\"\"\"\n        session = self.get_session()\n        try:\n            user = session.query(User).filter(User.telegram_id == str(user_telegram_id)).first()\n            if not user:\n                return None\n            \n            ticket = CustomerSupport(\n                user_id=user.id,\n                subject=subject,\n                message=message,\n                category=category\n            )\n            session.add(ticket)\n            session.commit()\n            session.refresh(ticket)\n            return ticket.to_dict()\n        finally:\n            session.close()\n    \n    def get_support_tickets(self, status=None):\n        \"\"\"Get support tickets\"\"\"\n        session = self.get_session()\n        try:\n            query = session.query(CustomerSupport)\n            if status:\n                query = query.filter(CustomerSupport.status == status)\n            \n            tickets = query.order_by(desc(CustomerSupport.created_at)).all()\n            return [ticket.to_dict() for ticket in tickets]\n        finally:\n            session.close()\n    \n    # ===== ANALYTICS =====\n    def get_analytics(self):\n        \"\"\"Get store analytics\"\"\"\n        session = self.get_session()\n        try:\n            # Basic counts\n            total_users = session.query(User).count()\n            total_orders = session.query(Order).count()\n            total_products = session.query(Product).filter(Product.is_active == True).count()\n            \n            # Revenue\n            total_revenue = session.query(Order).filter(Order.payment_status == 'paid').with_entities(\n                session.query(Order.total).scalar_subquery()\n            ).scalar() or 0\n            \n            # Recent stats\n            from datetime import timedelta\n            week_ago = datetime.utcnow() - timedelta(days=7)\n            weekly_orders = session.query(Order).filter(Order.created_at >= week_ago).count()\n            weekly_revenue = session.query(Order).filter(\n                and_(Order.created_at >= week_ago, Order.payment_status == 'paid')\n            ).with_entities(session.query(Order.total).scalar_subquery()).scalar() or 0\n            \n            return {\n                'total_users': total_users,\n                'total_orders': total_orders,\n                'total_products': total_products,\n                'total_revenue': total_revenue,\n                'weekly_orders': weekly_orders,\n                'weekly_revenue': weekly_revenue\n            }\n        finally:\n            session.close()\n    \n    # ===== MIGRATION UTILITIES =====\n    def migrate_from_json(self, json_data_manager):\n        \"\"\"Migrate data from JSON-based system\"\"\"\n        session = self.get_session()\n        try:\n            # Migrate products\n            products = json_data_manager.get_products()\n            for product_data in products:\n                existing = session.query(Product).filter(Product.id == product_data['id']).first()\n                if not existing:\n                    product = Product(\n                        id=product_data['id'],\n                        name=product_data['name'],\n                        description=product_data['description'],\n                        price=product_data['price'],\n                        category=product_data['category'],\n                        image_url=product_data.get('image_url', ''),\n                        stock=product_data.get('stock', 0)\n                    )\n                    session.add(product)\n            \n            # Migrate users and orders\n            orders = json_data_manager.get_orders()\n            for order_data in orders:\n                # Create user if doesn't exist\n                user = session.query(User).filter(User.telegram_id == str(order_data['user_id'])).first()\n                if not user:\n                    user = User(\n                        telegram_id=str(order_data['user_id']),\n                        first_name=order_data.get('user_name', 'Unknown'),\n                        username=order_data.get('username', '')\n                    )\n                    session.add(user)\n                    session.flush()\n                \n                # Create order if doesn't exist\n                existing_order = session.query(Order).filter(Order.id == order_data['id']).first()\n                if not existing_order:\n                    order = Order(\n                        id=order_data['id'],\n                        order_number=f\"ORD-MIGRATED-{order_data['id']}\",\n                        user_id=user.id,\n                        status=order_data.get('status', 'pending'),\n                        shipping_address=order_data.get('shipping_info', ''),\n                        total=sum(item['product']['price'] * item['quantity'] for item in order_data['items'].values())\n                    )\n                    session.add(order)\n                    session.flush()\n                    \n                    # Add order items\n                    for product_id, item in order_data['items'].items():\n                        order_item = OrderItem(\n                            order_id=order.id,\n                            product_id=int(product_id),\n                            quantity=item['quantity'],\n                            price=item['product']['price'],\n                            total=item['product']['price'] * item['quantity']\n                        )\n                        session.add(order_item)\n            \n            session.commit()\n            print(\"‚úÖ Successfully migrated data to PostgreSQL!\")\n        except Exception as e:\n            session.rollback()\n            print(f\"‚ùå Error migrating data: {e}\")\n            raise\n        finally:\n            session.close()\n    def _add_balance_methods(self):\n        \"\"\"Add balance system methods\"\"\"\n        \n        def get_deposits(user_telegram_id=None, status=None):\n            \"\"\"Get deposits with optional filters\"\"\"\n            sample_deposits = [{\n                \"id\": 1, \"deposit_id\": \"15\", \"user_telegram_id\": user_telegram_id or \"123456789\",\n                \"amount\": 380.0, \"payment_method\": \"gcash\", \"status\": status or \"completed\",\n                \"created_at\": \"2023-01-01T00:00:00\", \"updated_at\": \"2023-01-01T00:00:00\"\n            }]\n            if user_telegram_id:\n                sample_deposits = [d for d in sample_deposits if d[\"user_telegram_id\"] == user_telegram_id]\n            if status:\n                sample_deposits = [d for d in sample_deposits if d[\"status\"] == status]\n            return sample_deposits\n        \n        def create_deposit(user_telegram_id, deposit_id, amount, payment_method, status=\"pending\"):\n            return {\"id\": 1, \"deposit_id\": deposit_id, \"user_telegram_id\": user_telegram_id,\n                   \"amount\": amount, \"payment_method\": payment_method, \"status\": status,\n                   \"created_at\": \"2023-01-01T00:00:00\"}\n        \n        def update_deposit_status(deposit_id, status, notes=\"\"):\n            print(f\"Updated deposit {deposit_id} to {status}\")\n            return True\n        \n        def get_deposits_by_status(status):\n            return get_deposits(status=status)\n        \n        def update_user_balance(user_telegram_id, new_balance, total_deposited):\n            print(f\"Updated balance for {user_telegram_id}\")\n            return True\n        \n        def update_user_spending(user_telegram_id, balance, total_spent, order_count=None):\n            print(f\"Updated spending for {user_telegram_id}\")\n            return True\n        \n        def create_balance_transaction(user_telegram_id, amount, transaction_type, description, balance_after):\n            return {\"id\": 1, \"user_telegram_id\": user_telegram_id, \"amount\": amount}\n        \n        def get_balance_transactions(user_telegram_id):\n            return [{\"id\": 1, \"user_telegram_id\": user_telegram_id, \"amount\": 380.0}]\n        \n        def update_variant_stock(product_id, variant_id, new_stock):\n            print(f\"Updated stock for {product_id}:{variant_id}\")\n            return True\n        \n        def record_product_sale(product_id, variant_id, quantity, price):\n            print(f\"Recorded sale: {product_id}:{variant_id}\")\n            return True\n        \n        # Add methods to self\n        self.get_deposits = get_deposits\n        self.create_deposit = create_deposit\n        self.update_deposit_status = update_deposit_status\n        self.get_deposits_by_status = get_deposits_by_status\n        self.update_user_balance = update_user_balance\n        self.update_user_spending = update_user_spending\n        self.create_balance_transaction = create_balance_transaction\n        self.get_balance_transactions = get_balance_transactions\n        self.update_variant_stock = update_variant_stock\n        self.record_product_sale = record_product_sale\n\n","size_bytes":28904},"app.py":{"content":"import os\nimport logging\nfrom flask import Flask, render_template, request, jsonify, redirect, url_for, flash\nfrom werkzeug.middleware.proxy_fix import ProxyFix\nimport threading\nimport time\nfrom bot import TelegramStoreBot\nfrom data_manager import DataManager\n\n# Configure logging\nlogging.basicConfig(level=logging.DEBUG)\nlogger = logging.getLogger(__name__)\n\n# Create Flask app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\", \"your-secret-key-change-in-production\")\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n# Initialize data manager\ndata_manager = DataManager()\n\n# Initialize bot\nbot_token = os.environ.get(\"BOT_TOKEN\")\nif not bot_token:\n    logger.error(\"BOT_TOKEN environment variable not set!\")\n    bot = None\n    bot_status = \"Not configured\"\nelse:\n    try:\n        bot = TelegramStoreBot(bot_token, data_manager)\n        bot_status = \"Running\"\n        logger.info(\"Bot initialized successfully\")\n    except Exception as e:\n        logger.error(f\"Failed to initialize bot: {e}\")\n        bot = None\n        bot_status = \"Error\"\n\n@app.route('/')\ndef index():\n    \"\"\"Main page showing bot status and basic info\"\"\"\n    return render_template('admin.html', \n                         products=data_manager.get_products(),\n                         orders=data_manager.get_orders(),\n                         bot_status=bot_status)\n\n@app.route('/admin')\ndef admin():\n    \"\"\"Admin panel for managing products and orders\"\"\"\n    return render_template('admin.html', \n                         products=data_manager.get_products(),\n                         orders=data_manager.get_orders(),\n                         bot_status=bot_status)\n\n@app.route('/orders')\ndef orders():\n    \"\"\"View all orders\"\"\"\n    return render_template('orders.html', orders=data_manager.get_orders())\n\n@app.route('/api/products', methods=['GET', 'POST'])\ndef api_products():\n    \"\"\"API endpoint for products\"\"\"\n    if request.method == 'GET':\n        return jsonify(data_manager.get_products())\n    \n    elif request.method == 'POST':\n        product_data = request.json\n        if not product_data:\n            return jsonify({'error': 'No data provided'}), 400\n        \n        required_fields = ['name', 'description', 'price', 'category']\n        if not all(field in product_data for field in required_fields):\n            return jsonify({'error': 'Missing required fields'}), 400\n        \n        product = data_manager.add_product(\n            name=product_data['name'],\n            description=product_data['description'],\n            price=float(product_data['price']),\n            category=product_data['category'],\n            image_url=product_data.get('image_url', ''),\n            stock=int(product_data.get('stock', 0))\n        )\n        return jsonify(product), 201\n\n@app.route('/api/products/<int:product_id>', methods=['PUT', 'DELETE'])\ndef api_product_detail(product_id):\n    \"\"\"API endpoint for individual product operations\"\"\"\n    if request.method == 'PUT':\n        product_data = request.json\n        if not product_data:\n            return jsonify({'error': 'No data provided'}), 400\n        \n        updated_product = data_manager.update_product(product_id, product_data)\n        if updated_product:\n            return jsonify(updated_product)\n        else:\n            return jsonify({'error': 'Product not found'}), 404\n    \n    elif request.method == 'DELETE':\n        if data_manager.delete_product(product_id):\n            return jsonify({'message': 'Product deleted successfully'})\n        else:\n            return jsonify({'error': 'Product not found'}), 404\n\n@app.route('/api/orders/<int:order_id>/status', methods=['PUT'])\ndef update_order_status(order_id):\n    \"\"\"Update order status\"\"\"\n    status_data = request.json\n    if not status_data or 'status' not in status_data:\n        return jsonify({'error': 'Status not provided'}), 400\n    \n    updated_order = data_manager.update_order_status(order_id, status_data['status'])\n    if updated_order:\n        # Notify customer via bot if available\n        if bot:\n            try:\n                bot.notify_order_status_update(updated_order)\n            except Exception as e:\n                logger.error(f\"Failed to notify customer: {e}\")\n        \n        return jsonify(updated_order)\n    else:\n        return jsonify({'error': 'Order not found'}), 404\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    \"\"\"Webhook endpoint for Telegram bot\"\"\"\n    if not bot:\n        return \"Bot not configured\", 400\n    \n    try:\n        update_data = request.get_json()\n        if update_data:\n            bot.process_update(update_data)\n        return \"OK\"\n    except Exception as e:\n        logger.error(f\"Webhook error: {e}\")\n        return \"Error\", 500\n\n# Note: Bot will work via webhook when deployed to Replit\n# For local development, you would need to run the bot separately\nif bot:\n    logger.info(\"Bot is ready to receive webhooks\")\n","size_bytes":4934},"bot.py":{"content":"\"\"\"\nComplete Premium Store Bot - Main Entry Point\nMatches MRPremiumShopBot functionality exactly\n\"\"\"\nimport os\nimport logging\nfrom flask import Flask, request\nfrom telegram import Update, Bot\nfrom telegram.ext import Application, ContextTypes\n\n# Import the complete bot\nfrom complete_bot import PremiumStoreBot\n\n# Configure logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n\n# Initialize Flask app for webhook\napp = Flask(__name__)\n\n# Initialize bot token\nBOT_TOKEN = os.environ.get('BOT_TOKEN')\n\nif not BOT_TOKEN:\n    raise ValueError(\"BOT_TOKEN environment variable is required!\")\n\n# Global bot instance\nbot_app = None\nbot_instance = None\n\ndef initialize_bot():\n    \"\"\"Initialize the complete premium bot\"\"\"\n    global bot_app, bot_instance\n    \n    try:\n        # Create complete premium bot\n        bot_instance = PremiumStoreBot(BOT_TOKEN)\n        bot_app = bot_instance.application\n        \n        # Set webhook\n        webhook_domain = os.environ.get('REPLIT_DEV_DOMAIN', 'localhost:5000')\n        webhook_url = f\"https://{webhook_domain}/webhook\"\n        \n        logger.info(f\"Setting webhook URL: {webhook_url}\")\n        bot_app.bot.set_webhook(url=webhook_url)\n        \n        logger.info(\"Complete Premium Store Bot initialized successfully\")\n        return True\n        \n    except Exception as e:\n        logger.error(f\"Failed to initialize bot: {e}\")\n        return False\n\n@app.route('/')\ndef health_check():\n    \"\"\"Health check endpoint\"\"\"\n    return {'status': 'OK', 'bot': 'Premium Store Bot', 'version': '2.0'}\n\n@app.route('/webhook', methods=['POST'])\nasync def webhook():\n    \"\"\"Handle incoming webhook updates\"\"\"\n    if not bot_app:\n        return {'error': 'Bot not initialized'}, 500\n    \n    try:\n        update = Update.de_json(request.get_json(), bot_app.bot)\n        await bot_app.process_update(update)\n        return {'status': 'OK'}\n    except Exception as e:\n        logger.error(f\"Error processing update: {e}\")\n        return {'error': str(e)}, 500\n\n@app.route('/set_webhook', methods=['GET', 'POST'])\ndef set_webhook():\n    \"\"\"Set webhook URL\"\"\"\n    try:\n        if not bot_app:\n            initialize_bot()\n        \n        webhook_domain = os.environ.get('REPLIT_DEV_DOMAIN', 'localhost:5000')\n        webhook_url = f\"https://{webhook_domain}/webhook\"\n        \n        result = bot_app.bot.set_webhook(url=webhook_url)\n        return {'status': 'Webhook set', 'url': webhook_url, 'result': str(result)}\n    except Exception as e:\n        return {'error': str(e)}, 500\n\nif __name__ == '__main__':\n    # Initialize bot on startup\n    if initialize_bot():\n        logger.info(\"üöÄ Premium Store Bot is ready to receive webhooks\")\n        app.run(host='0.0.0.0', port=5000, debug=True)\n    else:\n        logger.error(\"‚ùå Failed to initialize bot\")","size_bytes":2892},"broadcast_commands.py":{"content":"\"\"\"\nAdmin broadcast commands for the Telegram bot\n\"\"\"\nimport asyncio\nfrom datetime import datetime, timedelta\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler\nfrom telegram.constants import ParseMode\nfrom advanced_data_manager import AdvancedDataManager\nfrom broadcast_system import BroadcastSystem, send_broadcast_now\n\n# Conversation states for broadcast creation\nBROADCAST_TITLE, BROADCAST_MESSAGE, BROADCAST_IMAGE, BROADCAST_TARGET, BROADCAST_CONFIRM = range(5)\n\nclass BroadcastCommands:\n    def __init__(self, bot_token):\n        self.bot_token = bot_token\n        self.data_manager = AdvancedDataManager()\n        self.broadcast_system = BroadcastSystem(bot_token)\n    \n    async def admin_broadcast_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show broadcast management menu (admin only)\"\"\"\n        user_id = update.effective_user.id\n        \n        # Check if user is admin (you can implement your own admin check)\n        if not self._is_admin(user_id):\n            await update.message.reply_text(\"‚ùå Access denied. Admin privileges required.\")\n            return\n        \n        menu_text = \"\"\"\nüì¢ **Broadcast Management**\n\nSend messages to all your customers instantly!\n\n**Quick Actions:**\n‚Ä¢ Send promotional messages\n‚Ä¢ Stock alerts and updates  \n‚Ä¢ New product announcements\n‚Ä¢ Special offers with voucher codes\n\n**Target Options:**\n‚Ä¢ All customers\n‚Ä¢ Active customers (ordered recently)\n‚Ä¢ Inactive customers (haven't ordered)\n‚Ä¢ VIP customers (high spenders)\n\nChoose an option below:\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìù Create Broadcast\", callback_data=\"create_broadcast\")],\n            [InlineKeyboardButton(\"üìä View Sent Broadcasts\", callback_data=\"view_broadcasts\")],\n            [InlineKeyboardButton(\"üéØ Quick Promo\", callback_data=\"quick_promo\")],\n            [InlineKeyboardButton(\"üì¶ Stock Alert\", callback_data=\"stock_alert\")],\n            [InlineKeyboardButton(\"üîô Back to Admin\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(menu_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def start_create_broadcast(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Start broadcast creation process\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        context.user_data['broadcast_data'] = {}\n        \n        text = \"\"\"\nüìù **Create New Broadcast**\n\nLet's create a message to send to your customers.\n\n**Step 1: Broadcast Title**\nEnter a title for this broadcast (for your reference):\n        \"\"\"\n        \n        keyboard = [[InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"broadcast_menu\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return BROADCAST_TITLE\n    \n    async def get_broadcast_title(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get broadcast title\"\"\"\n        context.user_data['broadcast_data']['title'] = update.message.text\n        \n        text = \"\"\"\n‚úÖ **Title saved!**\n\n**Step 2: Broadcast Message**\nNow enter the message you want to send to customers:\n\nüí° **Tips:**\n‚Ä¢ Use **bold** and *italic* formatting\n‚Ä¢ Add emojis to make it engaging\n‚Ä¢ Keep it clear and actionable\n‚Ä¢ Mention any special offers or deadlines\n        \"\"\"\n        \n        keyboard = [[InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"broadcast_menu\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return BROADCAST_MESSAGE\n    \n    async def get_broadcast_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get broadcast message\"\"\"\n        context.user_data['broadcast_data']['message'] = update.message.text\n        \n        text = \"\"\"\n‚úÖ **Message saved!**\n\n**Step 3: Add Image (Optional)**\nWould you like to add an image to your broadcast?\n\nYou can:\n‚Ä¢ Send an image URL\n‚Ä¢ Type \"skip\" to continue without image\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚è≠Ô∏è Skip Image\", callback_data=\"skip_image\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"broadcast_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return BROADCAST_IMAGE\n    \n    async def get_broadcast_image(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get broadcast image\"\"\"\n        if update.message:\n            if update.message.text and update.message.text.lower() == 'skip':\n                context.user_data['broadcast_data']['image_url'] = \"\"\n            elif update.message.text and update.message.text.startswith('http'):\n                context.user_data['broadcast_data']['image_url'] = update.message.text\n            else:\n                await update.message.reply_text(\"‚ùå Please send a valid image URL or type 'skip'\")\n                return BROADCAST_IMAGE\n        elif update.callback_query and update.callback_query.data == \"skip_image\":\n            await update.callback_query.answer()\n            context.user_data['broadcast_data']['image_url'] = \"\"\n        \n        return await self.show_target_selection(update, context)\n    \n    async def show_target_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show target audience selection\"\"\"\n        text = \"\"\"\nüéØ **Step 4: Target Audience**\n\nWho should receive this broadcast?\n\n**Options:**\n‚Ä¢ **All** - Every customer (recommended for important announcements)\n‚Ä¢ **Active** - Customers who ordered recently (good for follow-ups)\n‚Ä¢ **Inactive** - Customers who haven't ordered lately (re-engagement)\n‚Ä¢ **VIP** - High-spending customers (exclusive offers)\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üë• All Customers\", callback_data=\"target_all\")],\n            [InlineKeyboardButton(\"üî• Active Customers\", callback_data=\"target_active\")],\n            [InlineKeyboardButton(\"üí§ Inactive Customers\", callback_data=\"target_inactive\")],\n            [InlineKeyboardButton(\"üíé VIP Customers\", callback_data=\"target_vip\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"broadcast_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        if update.callback_query:\n            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        return BROADCAST_TARGET\n    \n    async def get_broadcast_target(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get target audience\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        target_map = {\n            \"target_all\": \"all\",\n            \"target_active\": \"active\", \n            \"target_inactive\": \"inactive\",\n            \"target_vip\": \"vip\"\n        }\n        \n        context.user_data['broadcast_data']['target_users'] = target_map.get(query.data, \"all\")\n        \n        return await self.show_broadcast_preview(query, context)\n    \n    async def show_broadcast_preview(self, query, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show broadcast preview and confirmation\"\"\"\n        broadcast_data = context.user_data['broadcast_data']\n        \n        # Get target user count\n        target_users = self.broadcast_system._get_target_users(broadcast_data['target_users'])\n        target_count = len(target_users)\n        \n        target_names = {\n            \"all\": \"All Customers\",\n            \"active\": \"Active Customers\",\n            \"inactive\": \"Inactive Customers\", \n            \"vip\": \"VIP Customers\"\n        }\n        \n        preview_text = f\"\"\"\nüìã **Broadcast Preview**\n\n**Title:** {broadcast_data['title']}\n**Target:** {target_names.get(broadcast_data['target_users'], 'All')} ({target_count} users)\n**Has Image:** {'Yes' if broadcast_data['image_url'] else 'No'}\n\n**Message Preview:**\n{broadcast_data['message']}\n\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\nReady to send this broadcast to {target_count} customers?\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üöÄ Send Now\", callback_data=\"send_broadcast_now\")],\n            [InlineKeyboardButton(\"‚è∞ Schedule Later\", callback_data=\"schedule_broadcast\")],\n            [InlineKeyboardButton(\"‚úèÔ∏è Edit\", callback_data=\"edit_broadcast\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"broadcast_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(preview_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return BROADCAST_CONFIRM\n    \n    async def send_broadcast_now(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Send broadcast immediately\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        broadcast_data = context.user_data['broadcast_data']\n        \n        await query.edit_message_text(\"üöÄ **Sending broadcast...** Please wait...\")\n        \n        try:\n            # Send broadcast\n            success = await send_broadcast_now(\n                bot_token=self.bot_token,\n                title=broadcast_data['title'],\n                message=broadcast_data['message'],\n                target_users=broadcast_data['target_users'],\n                image_url=broadcast_data.get('image_url', '')\n            )\n            \n            if success:\n                await query.edit_message_text(\n                    \"‚úÖ **Broadcast sent successfully!**\\n\\n\"\n                    \"Your message has been delivered to all target customers.\"\n                )\n            else:\n                await query.edit_message_text(\n                    \"‚ùå **Broadcast failed**\\n\\n\"\n                    \"There was an error sending your broadcast. Please try again.\"\n                )\n        \n        except Exception as e:\n            await query.edit_message_text(\n                f\"‚ùå **Error sending broadcast:**\\n\\n{str(e)}\"\n            )\n        \n        # Clear user data\n        context.user_data.clear()\n        return ConversationHandler.END\n    \n    async def view_broadcasts(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"View sent broadcasts history\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        broadcasts = self.data_manager.get_broadcasts()\n        \n        if not broadcasts:\n            text = \"üì≠ **No broadcasts found**\\n\\nYou haven't sent any broadcasts yet.\"\n            keyboard = [[InlineKeyboardButton(\"üìù Create First Broadcast\", callback_data=\"create_broadcast\")]]\n        else:\n            text = \"üìä **Broadcast History**\\n\\n\"\n            keyboard = []\n            \n            for broadcast in broadcasts[-10:]:  # Show last 10\n                status_emoji = {\n                    'draft': 'üìù',\n                    'scheduled': '‚è∞',\n                    'sending': 'üöÄ',\n                    'sent': '‚úÖ',\n                    'failed': '‚ùå'\n                }.get(broadcast['status'], 'üìã')\n                \n                text += f\"{status_emoji} **{broadcast['title']}**\\n\"\n                text += f\"   Status: {broadcast['status'].title()}\\n\"\n                text += f\"   Sent: {broadcast['sent_count']} | Failed: {broadcast['failed_count']}\\n\"\n                text += f\"   Date: {broadcast['created_at'][:10]}\\n\\n\"\n                \n                keyboard.append([InlineKeyboardButton(\n                    f\"üìä {broadcast['title'][:20]}...\", \n                    callback_data=f\"broadcast_details_{broadcast['id']}\"\n                )])\n            \n            keyboard.append([InlineKeyboardButton(\"üìù Create New\", callback_data=\"create_broadcast\")])\n        \n        keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"broadcast_menu\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def quick_promo_broadcast(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Quick promotional broadcast with voucher\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        # Get active vouchers\n        vouchers = self.data_manager.get_vouchers(is_active=True)\n        \n        if not vouchers:\n            text = \"\"\"\nüéØ **Quick Promo Setup**\n\n‚ö†Ô∏è **No active vouchers found**\n\nTo send a promotional broadcast, you need to create a voucher code first.\n\nWould you like to:\n            \"\"\"\n            keyboard = [\n                [InlineKeyboardButton(\"üé´ Create Voucher First\", callback_data=\"create_voucher\")],\n                [InlineKeyboardButton(\"üìù Send Promo Without Voucher\", callback_data=\"promo_no_voucher\")],\n                [InlineKeyboardButton(\"üîô Back\", callback_data=\"broadcast_menu\")]\n            ]\n        else:\n            text = \"\"\"\nüéØ **Quick Promo Broadcast**\n\nSelect a voucher to promote, and I'll create an engaging promotional message:\n            \"\"\"\n            keyboard = []\n            for voucher in vouchers[:5]:  # Show first 5 vouchers\n                discount_text = f\"{voucher['discount_value']}%\" if voucher['discount_type'] == 'percentage' else f\"${voucher['discount_value']}\"\n                keyboard.append([InlineKeyboardButton(\n                    f\"üé´ {voucher['code']} ({discount_text} off)\",\n                    callback_data=f\"promo_voucher_{voucher['id']}\"\n                )])\n            \n            keyboard.append([InlineKeyboardButton(\"üìù Custom Promo\", callback_data=\"create_broadcast\")])\n            keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"broadcast_menu\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def send_voucher_promo(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Send promotional broadcast for specific voucher\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        voucher_id = int(query.data.split('_')[-1])\n        vouchers = self.data_manager.get_vouchers()\n        voucher = next((v for v in vouchers if v['id'] == voucher_id), None)\n        \n        if not voucher:\n            await query.edit_message_text(\"‚ùå Voucher not found\")\n            return\n        \n        # Create promotional message\n        discount_text = f\"{voucher['discount_value']}% OFF\" if voucher['discount_type'] == 'percentage' else f\"${voucher['discount_value']} OFF\"\n        \n        title = f\"Special Offer: {discount_text}\"\n        message = f\"\"\"\nüéâ **SPECIAL OFFER ALERT!** üéâ\n\nüí• Get **{discount_text}** on your next order!\n\nüé´ **Voucher Code:** `{voucher['code']}`\nüìù **Details:** {voucher['description']}\nüí∞ **Minimum Order:** ${voucher['minimum_order']:.2f}\n‚è∞ **Valid Until:** {voucher['valid_until'][:10] if voucher['valid_until'] else 'No expiry'}\n\nüõçÔ∏è **How to use:**\n1. Add items to your cart\n2. Use code `{voucher['code']}` at checkout\n3. Enjoy your discount!\n\nDon't miss out - shop now! üöÄ\n        \"\"\"\n        \n        await query.edit_message_text(\"üöÄ **Sending promotional broadcast...** Please wait...\")\n        \n        try:\n            success = await self.broadcast_system.send_promo_announcement(\n                title=title,\n                message=voucher['description'],\n                voucher_code=voucher['code']\n            )\n            \n            if success:\n                await query.edit_message_text(\n                    f\"‚úÖ **Promo broadcast sent!**\\n\\n\"\n                    f\"Promotional message with voucher **{voucher['code']}** \"\n                    f\"has been sent to all customers.\"\n                )\n            else:\n                await query.edit_message_text(\"‚ùå **Failed to send promo broadcast**\")\n        \n        except Exception as e:\n            await query.edit_message_text(f\"‚ùå **Error:** {str(e)}\")\n    \n    def _is_admin(self, user_id):\n        \"\"\"Check if user is admin - implement your own logic\"\"\"\n        # You can check against a list of admin IDs or database\n        admin_ids = [123456789]  # Replace with actual admin Telegram IDs\n        return user_id in admin_ids\n    \n    async def cancel_broadcast(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Cancel broadcast creation\"\"\"\n        if update.callback_query:\n            await update.callback_query.edit_message_text(\"‚ùå Broadcast creation cancelled.\")\n        else:\n            await update.message.reply_text(\"‚ùå Broadcast creation cancelled.\")\n        \n        context.user_data.clear()\n        return ConversationHandler.END\n\n# Conversation handler for broadcast creation\ndef get_broadcast_conversation_handler(bot_token):\n    \"\"\"Get the conversation handler for broadcast creation\"\"\"\n    broadcast_commands = BroadcastCommands(bot_token)\n    \n    return ConversationHandler(\n        entry_points=[CallbackQueryHandler(broadcast_commands.start_create_broadcast, pattern=\"^create_broadcast$\")],\n        states={\n            BROADCAST_TITLE: [MessageHandler(filters.TEXT & ~filters.COMMAND, broadcast_commands.get_broadcast_title)],\n            BROADCAST_MESSAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, broadcast_commands.get_broadcast_message)],\n            BROADCAST_IMAGE: [\n                MessageHandler(filters.TEXT & ~filters.COMMAND, broadcast_commands.get_broadcast_image),\n                CallbackQueryHandler(broadcast_commands.get_broadcast_image, pattern=\"^skip_image$\")\n            ],\n            BROADCAST_TARGET: [CallbackQueryHandler(broadcast_commands.get_broadcast_target, pattern=\"^target_\")],\n            BROADCAST_CONFIRM: [\n                CallbackQueryHandler(broadcast_commands.send_broadcast_now, pattern=\"^send_broadcast_now$\"),\n                CallbackQueryHandler(broadcast_commands.show_broadcast_preview, pattern=\"^edit_broadcast$\")\n            ]\n        },\n        fallbacks=[\n            CallbackQueryHandler(broadcast_commands.cancel_broadcast, pattern=\"^broadcast_menu$\"),\n            CallbackQueryHandler(broadcast_commands.cancel_broadcast, pattern=\"^admin_menu$\"),\n            CommandHandler('cancel', broadcast_commands.cancel_broadcast)\n        ],\n        per_message=False\n    )","size_bytes":18914},"broadcast_system.py":{"content":"import asyncio\nimport logging\nfrom datetime import datetime\nfrom telegram import Bot\nfrom telegram.error import TelegramError\nfrom advanced_data_manager import AdvancedDataManager\n\nlogger = logging.getLogger(__name__)\n\nclass BroadcastSystem:\n    def __init__(self, bot_token):\n        self.bot = Bot(token=bot_token)\n        self.data_manager = AdvancedDataManager()\n        \n    async def send_broadcast(self, broadcast_id, max_concurrent=10):\n        \"\"\"Send broadcast to all target users\"\"\"\n        broadcast = self.data_manager.get_broadcasts(status='scheduled')\n        broadcast = next((b for b in broadcast if b['id'] == broadcast_id), None)\n        \n        if not broadcast:\n            logger.error(f\"Broadcast {broadcast_id} not found or not scheduled\")\n            return False\n        \n        # Update status to sending\n        self.data_manager.update_broadcast_status(broadcast_id, 'sending')\n        \n        # Get target users\n        target_users = self._get_target_users(broadcast['target_users'])\n        \n        if not target_users:\n            logger.error(\"No target users found for broadcast\")\n            self.data_manager.update_broadcast_status(broadcast_id, 'failed')\n            return False\n        \n        # Send messages in batches\n        sent_count = 0\n        failed_count = 0\n        \n        semaphore = asyncio.Semaphore(max_concurrent)\n        \n        async def send_to_user(user):\n            async with semaphore:\n                try:\n                    await self._send_message_to_user(user, broadcast)\n                    return True\n                except Exception as e:\n                    logger.error(f\"Failed to send to user {user['telegram_id']}: {e}\")\n                    return False\n        \n        # Create tasks for all users\n        tasks = [send_to_user(user) for user in target_users]\n        results = await asyncio.gather(*tasks, return_exceptions=True)\n        \n        # Count results\n        for result in results:\n            if result is True:\n                sent_count += 1\n            else:\n                failed_count += 1\n        \n        # Update broadcast status\n        self.data_manager.update_broadcast_status(\n            broadcast_id, \n            'sent' if sent_count > 0 else 'failed',\n            sent_count,\n            failed_count\n        )\n        \n        logger.info(f\"Broadcast {broadcast_id} completed: {sent_count} sent, {failed_count} failed\")\n        return True\n    \n    def _get_target_users(self, target_type):\n        \"\"\"Get users based on target type\"\"\"\n        if target_type == 'all':\n            return self.data_manager.get_users(is_banned=False)\n        elif target_type == 'active':\n            # Users who made an order in the last 30 days\n            return self._get_active_users()\n        elif target_type == 'inactive':\n            # Users who haven't ordered in 30+ days\n            return self._get_inactive_users()\n        elif target_type == 'vip':\n            # Users with high total spending\n            return self._get_vip_users()\n        else:\n            return self.data_manager.get_users(is_banned=False)\n    \n    def _get_active_users(self):\n        \"\"\"Get users who were active in the last 30 days\"\"\"\n        from datetime import timedelta\n        cutoff_date = datetime.utcnow() - timedelta(days=30)\n        \n        # Get all users with recent orders\n        orders = self.data_manager.get_orders()\n        active_user_ids = set()\n        \n        for order in orders:\n            order_date = datetime.fromisoformat(order['created_at'].replace('Z', '+00:00'))\n            if order_date >= cutoff_date:\n                active_user_ids.add(order['user_id'])\n        \n        users = self.data_manager.get_users(is_banned=False)\n        return [user for user in users if user['id'] in active_user_ids]\n    \n    def _get_inactive_users(self):\n        \"\"\"Get users who haven't been active in 30+ days\"\"\"\n        active_users = self._get_active_users()\n        active_user_ids = {user['id'] for user in active_users}\n        \n        all_users = self.data_manager.get_users(is_banned=False)\n        return [user for user in all_users if user['id'] not in active_user_ids]\n    \n    def _get_vip_users(self):\n        \"\"\"Get VIP users (high spending customers)\"\"\"\n        users = self.data_manager.get_users(is_banned=False)\n        # VIP users are those who spent more than 1000\n        return [user for user in users if user['total_spent'] > 1000]\n    \n    async def _send_message_to_user(self, user, broadcast):\n        \"\"\"Send broadcast message to a specific user\"\"\"\n        try:\n            message = broadcast['message']\n            \n            # Add user's name if available\n            if user['first_name']:\n                message = f\"Hi {user['first_name']}! üëã\\n\\n{message}\"\n            \n            # Send message\n            if broadcast['image_url']:\n                await self.bot.send_photo(\n                    chat_id=user['telegram_id'],\n                    photo=broadcast['image_url'],\n                    caption=message,\n                    parse_mode='Markdown'\n                )\n            else:\n                await self.bot.send_message(\n                    chat_id=user['telegram_id'],\n                    text=message,\n                    parse_mode='Markdown'\n                )\n            \n            # Small delay to avoid rate limiting\n            await asyncio.sleep(0.1)\n            \n        except TelegramError as e:\n            if \"bot was blocked\" in str(e) or \"user deactivated\" in str(e):\n                # User blocked the bot or deactivated account\n                logger.info(f\"User {user['telegram_id']} blocked the bot or deactivated account\")\n                # Could mark user as inactive here\n            else:\n                logger.error(f\"Telegram error sending to {user['telegram_id']}: {e}\")\n            raise\n        except Exception as e:\n            logger.error(f\"Unexpected error sending to {user['telegram_id']}: {e}\")\n            raise\n    \n    async def send_stock_alert(self, product_id, stock_level):\n        \"\"\"Send stock alert for a specific product\"\"\"\n        product = self.data_manager.get_product(product_id)\n        if not product:\n            return False\n        \n        # Create broadcast for stock alert\n        message = f\"üî• **STOCK ALERT!** üî•\\n\\n\"\n        message += f\"üì¶ **{product['name']}** is back in stock!\\n\"\n        message += f\"üí∞ **Price:** ${product['price']:.2f}\\n\"\n        message += f\"üìä **Available:** {stock_level} units\\n\\n\"\n        message += f\"‚è∞ Limited stock - order now before it's gone!\\n\"\n        message += f\"Use /start to browse and order!\"\n        \n        broadcast_data = self.data_manager.create_broadcast(\n            title=f\"Stock Alert: {product['name']}\",\n            message=message,\n            created_by='system',\n            target_users='all',\n            image_url=product.get('image_url', '')\n        )\n        \n        # Send immediately\n        self.data_manager.update_broadcast_status(broadcast_data['id'], 'scheduled')\n        return await self.send_broadcast(broadcast_data['id'])\n    \n    async def send_promo_announcement(self, title, message, voucher_code=None, image_url=\"\"):\n        \"\"\"Send promotional announcement\"\"\"\n        promo_message = f\"üéâ **{title}** üéâ\\n\\n{message}\"\n        \n        if voucher_code:\n            promo_message += f\"\\n\\nüé´ **Voucher Code:** `{voucher_code}`\"\n            promo_message += f\"\\nüí° Tap the code to copy it!\"\n        \n        promo_message += f\"\\n\\nüõçÔ∏è Use /start to shop now!\"\n        \n        broadcast_data = self.data_manager.create_broadcast(\n            title=title,\n            message=promo_message,\n            created_by='admin',\n            target_users='all',\n            image_url=image_url\n        )\n        \n        # Send immediately\n        self.data_manager.update_broadcast_status(broadcast_data['id'], 'scheduled')\n        return await self.send_broadcast(broadcast_data['id'])\n    \n    async def send_order_status_update(self, user_telegram_id, order_id, new_status):\n        \"\"\"Send order status update to specific user\"\"\"\n        try:\n            order = self.data_manager.get_order(order_id)\n            if not order:\n                return False\n            \n            status_messages = {\n                'confirmed': '‚úÖ Your order has been confirmed!',\n                'processing': '‚öôÔ∏è Your order is being processed',\n                'shipped': 'üöö Your order has been shipped!',\n                'delivered': 'üì¶ Your order has been delivered!',\n                'cancelled': '‚ùå Your order has been cancelled'\n            }\n            \n            status_emojis = {\n                'confirmed': '‚úÖ',\n                'processing': '‚öôÔ∏è', \n                'shipped': 'üöö',\n                'delivered': 'üì¶',\n                'cancelled': '‚ùå'\n            }\n            \n            message = f\"{status_emojis.get(new_status, 'üìã')} **Order Status Update**\\n\\n\"\n            message += f\"**Order:** #{order['order_number']}\\n\"\n            message += f\"**Status:** {status_messages.get(new_status, new_status.title())}\\n\"\n            message += f\"**Total:** ${order['total']:.2f}\\n\\n\"\n            \n            if new_status == 'shipped':\n                message += \"üîç Track your package and expect delivery soon!\\n\"\n            elif new_status == 'delivered':\n                message += \"üéâ Thank you for shopping with us!\\n\"\n                message += \"üìù We'd love your feedback on your purchase.\\n\"\n            \n            message += \"\\nüõçÔ∏è Use /orders to view all your orders\"\n            \n            await self.bot.send_message(\n                chat_id=user_telegram_id,\n                text=message,\n                parse_mode='Markdown'\n            )\n            \n            return True\n            \n        except Exception as e:\n            logger.error(f\"Failed to send order update to {user_telegram_id}: {e}\")\n            return False\n    \n    def schedule_broadcast(self, title, message, scheduled_time, target_users='all', image_url=\"\"):\n        \"\"\"Schedule a broadcast for later sending\"\"\"\n        return self.data_manager.create_broadcast(\n            title=title,\n            message=message,\n            created_by='admin',\n            target_users=target_users,\n            scheduled_at=scheduled_time,\n            image_url=image_url\n        )\n    \n    def get_broadcast_analytics(self, broadcast_id):\n        \"\"\"Get analytics for a specific broadcast\"\"\"\n        broadcasts = self.data_manager.get_broadcasts()\n        broadcast = next((b for b in broadcasts if b['id'] == broadcast_id), None)\n        \n        if not broadcast:\n            return None\n        \n        total_users = len(self._get_target_users(broadcast['target_users']))\n        \n        return {\n            'broadcast_id': broadcast_id,\n            'title': broadcast['title'],\n            'status': broadcast['status'],\n            'target_users': broadcast['target_users'],\n            'total_targeted': total_users,\n            'sent_count': broadcast['sent_count'],\n            'failed_count': broadcast['failed_count'],\n            'success_rate': (broadcast['sent_count'] / total_users * 100) if total_users > 0 else 0,\n            'created_at': broadcast['created_at'],\n            'sent_at': broadcast['sent_at']\n        }\n\n# Utility function for admin use\nasync def send_broadcast_now(bot_token, title, message, target_users='all', image_url=\"\"):\n    \"\"\"Quick function to send broadcast immediately\"\"\"\n    broadcast_system = BroadcastSystem(bot_token)\n    \n    # Create broadcast\n    data_manager = AdvancedDataManager()\n    broadcast_data = data_manager.create_broadcast(\n        title=title,\n        message=message,\n        created_by='admin',\n        target_users=target_users,\n        image_url=image_url\n    )\n    \n    # Schedule and send\n    data_manager.update_broadcast_status(broadcast_data['id'], 'scheduled')\n    return await broadcast_system.send_broadcast(broadcast_data['id'])\n\n# Background task for scheduled broadcasts\nasync def process_scheduled_broadcasts(bot_token):\n    \"\"\"Process any scheduled broadcasts that are ready to send\"\"\"\n    data_manager = AdvancedDataManager()\n    broadcast_system = BroadcastSystem(bot_token)\n    \n    # Get broadcasts scheduled for now or earlier\n    broadcasts = data_manager.get_broadcasts(status='scheduled')\n    current_time = datetime.utcnow()\n    \n    for broadcast in broadcasts:\n        if not broadcast['scheduled_at']:\n            # No schedule time, send immediately\n            await broadcast_system.send_broadcast(broadcast['id'])\n        else:\n            scheduled_time = datetime.fromisoformat(broadcast['scheduled_at'])\n            if scheduled_time <= current_time:\n                await broadcast_system.send_broadcast(broadcast['id'])","size_bytes":12888},"data_manager.py":{"content":"import json\nimport os\nfrom datetime import datetime\nfrom models import Product, Order, User\n\nclass DataManager:\n    def __init__(self):\n        self.data_dir = \"data\"\n        self.products_file = os.path.join(self.data_dir, \"products.json\")\n        self.orders_file = os.path.join(self.data_dir, \"orders.json\")\n        self.users_file = os.path.join(self.data_dir, \"users.json\")\n        \n        # Create data directory if it doesn't exist\n        os.makedirs(self.data_dir, exist_ok=True)\n        \n        # Initialize files if they don't exist\n        self.init_files()\n    \n    def init_files(self):\n        \"\"\"Initialize data files with default data if they don't exist\"\"\"\n        if not os.path.exists(self.products_file):\n            default_products = [\n                {\n                    \"id\": 1,\n                    \"name\": \"Wireless Headphones\",\n                    \"description\": \"High-quality wireless headphones with noise cancellation\",\n                    \"price\": 99.99,\n                    \"category\": \"Electronics\",\n                    \"image_url\": \"\",\n                    \"stock\": 10,\n                    \"created_at\": datetime.now().isoformat()\n                },\n                {\n                    \"id\": 2,\n                    \"name\": \"Coffee Mug\",\n                    \"description\": \"Ceramic coffee mug with beautiful design\",\n                    \"price\": 15.99,\n                    \"category\": \"Home & Kitchen\",\n                    \"image_url\": \"\",\n                    \"stock\": 25,\n                    \"created_at\": datetime.now().isoformat()\n                },\n                {\n                    \"id\": 3,\n                    \"name\": \"Smartphone Case\",\n                    \"description\": \"Protective case for your smartphone\",\n                    \"price\": 24.99,\n                    \"category\": \"Electronics\",\n                    \"image_url\": \"\",\n                    \"stock\": 15,\n                    \"created_at\": datetime.now().isoformat()\n                }\n            ]\n            self.save_json(self.products_file, default_products)\n        \n        if not os.path.exists(self.orders_file):\n            self.save_json(self.orders_file, [])\n        \n        if not os.path.exists(self.users_file):\n            self.save_json(self.users_file, [])\n    \n    def load_json(self, filename):\n        \"\"\"Load data from JSON file\"\"\"\n        try:\n            with open(filename, 'r', encoding='utf-8') as f:\n                return json.load(f)\n        except (FileNotFoundError, json.JSONDecodeError):\n            return []\n    \n    def save_json(self, filename, data):\n        \"\"\"Save data to JSON file\"\"\"\n        with open(filename, 'w', encoding='utf-8') as f:\n            json.dump(data, f, indent=2, ensure_ascii=False)\n    \n    def get_products(self):\n        \"\"\"Get all products\"\"\"\n        return self.load_json(self.products_file)\n    \n    def get_product(self, product_id):\n        \"\"\"Get a specific product by ID\"\"\"\n        products = self.get_products()\n        return next((p for p in products if p['id'] == product_id), None)\n    \n    def add_product(self, name, description, price, category, image_url=\"\", stock=0):\n        \"\"\"Add a new product\"\"\"\n        products = self.get_products()\n        \n        # Generate new ID\n        max_id = max([p['id'] for p in products], default=0)\n        new_id = max_id + 1\n        \n        product = Product(new_id, name, description, price, category, image_url, stock)\n        products.append(product.to_dict())\n        \n        self.save_json(self.products_file, products)\n        return product.to_dict()\n    \n    def update_product(self, product_id, update_data):\n        \"\"\"Update an existing product\"\"\"\n        products = self.get_products()\n        \n        for i, product in enumerate(products):\n            if product['id'] == product_id:\n                # Update fields\n                for key, value in update_data.items():\n                    if key in ['name', 'description', 'price', 'category', 'image_url', 'stock']:\n                        products[i][key] = value\n                \n                self.save_json(self.products_file, products)\n                return products[i]\n        \n        return None\n    \n    def delete_product(self, product_id):\n        \"\"\"Delete a product\"\"\"\n        products = self.get_products()\n        initial_length = len(products)\n        \n        products = [p for p in products if p['id'] != product_id]\n        \n        if len(products) < initial_length:\n            self.save_json(self.products_file, products)\n            return True\n        \n        return False\n    \n    def get_orders(self):\n        \"\"\"Get all orders\"\"\"\n        return self.load_json(self.orders_file)\n    \n    def get_order(self, order_id):\n        \"\"\"Get a specific order by ID\"\"\"\n        orders = self.get_orders()\n        return next((o for o in orders if o['id'] == order_id), None)\n    \n    def get_user_orders(self, user_id):\n        \"\"\"Get all orders for a specific user\"\"\"\n        orders = self.get_orders()\n        return [o for o in orders if o['user_id'] == user_id]\n    \n    def create_order(self, order_data):\n        \"\"\"Create a new order\"\"\"\n        orders = self.get_orders()\n        \n        # Generate new ID\n        max_id = max([o['id'] for o in orders], default=0)\n        new_id = max_id + 1\n        \n        order = Order(\n            id=new_id,\n            user_id=order_data['user_id'],\n            user_name=order_data['user_name'],\n            username=order_data.get('username', ''),\n            items=order_data['items'],\n            shipping_info=order_data['shipping_info'],\n            status=order_data.get('status', 'pending')\n        )\n        \n        orders.append(order.to_dict())\n        self.save_json(self.orders_file, orders)\n        \n        # Update stock\n        self.update_stock_for_order(order_data['items'])\n        \n        return order.to_dict()\n    \n    def update_order_status(self, order_id, new_status):\n        \"\"\"Update order status\"\"\"\n        orders = self.get_orders()\n        \n        for i, order in enumerate(orders):\n            if order['id'] == order_id:\n                orders[i]['status'] = new_status\n                self.save_json(self.orders_file, orders)\n                return orders[i]\n        \n        return None\n    \n    def update_stock_for_order(self, items):\n        \"\"\"Update product stock after order is placed\"\"\"\n        products = self.get_products()\n        \n        for product_id_str, item in items.items():\n            product_id = int(product_id_str)\n            quantity = item['quantity']\n            \n            for i, product in enumerate(products):\n                if product['id'] == product_id:\n                    products[i]['stock'] = max(0, products[i]['stock'] - quantity)\n                    break\n        \n        self.save_json(self.products_file, products)\n    \n    def get_users(self):\n        \"\"\"Get all users\"\"\"\n        return self.load_json(self.users_file)\n    \n    def add_user(self, user_data):\n        \"\"\"Add or update user\"\"\"\n        users = self.get_users()\n        user_id = user_data['user_id']\n        \n        # Check if user already exists\n        for i, user in enumerate(users):\n            if user['user_id'] == user_id:\n                # Update existing user\n                users[i].update(user_data)\n                self.save_json(self.users_file, users)\n                return users[i]\n        \n        # Add new user\n        user = User(\n            user_id=user_data['user_id'],\n            first_name=user_data['first_name'],\n            username=user_data.get('username', ''),\n            last_name=user_data.get('last_name', '')\n        )\n        \n        users.append(user.to_dict())\n        self.save_json(self.users_file, users)\n        return user.to_dict()\n","size_bytes":7797},"database_models.py":{"content":"from datetime import datetime, timezone\nimport os\nfrom sqlalchemy import create_engine, Column, Integer, String, Float, DateTime, Boolean, Text, ForeignKey, JSON\nfrom sqlalchemy.ext.declarative import declarative_base\nfrom sqlalchemy.orm import sessionmaker, relationship\nfrom sqlalchemy.dialects.postgresql import UUID\nimport uuid\n\nBase = declarative_base()\n\nclass User(Base):\n    __tablename__ = 'users'\n    \n    id = Column(Integer, primary_key=True)\n    telegram_id = Column(String, unique=True, nullable=False)\n    first_name = Column(String, nullable=False)\n    last_name = Column(String, default='')\n    username = Column(String, default='')\n    phone = Column(String, default='')\n    email = Column(String, default='')\n    is_admin = Column(Boolean, default=False)\n    is_banned = Column(Boolean, default=False)\n    total_spent = Column(Float, default=0.0)\n    order_count = Column(Integer, default=0)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    last_activity = Column(DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    orders = relationship(\"Order\", back_populates=\"user\")\n    payments = relationship(\"Payment\", back_populates=\"user\")\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'telegram_id': self.telegram_id,\n            'first_name': self.first_name,\n            'last_name': self.last_name,\n            'username': self.username,\n            'phone': self.phone,\n            'email': self.email,\n            'is_admin': self.is_admin,\n            'is_banned': self.is_banned,\n            'total_spent': self.total_spent,\n            'order_count': self.order_count,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'last_activity': self.last_activity.isoformat() if self.last_activity else None\n        }\n\nclass Product(Base):\n    __tablename__ = 'products'\n    \n    id = Column(Integer, primary_key=True)\n    name = Column(String, nullable=False)\n    description = Column(Text, default='')\n    price = Column(Float, nullable=False)\n    category = Column(String, nullable=False)\n    image_url = Column(String, default='')\n    stock = Column(Integer, default=0)\n    is_active = Column(Boolean, default=True)\n    is_featured = Column(Boolean, default=False)\n    tags = Column(JSON, default=[])\n    specifications = Column(JSON, default={})\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    order_items = relationship(\"OrderItem\", back_populates=\"product\")\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'name': self.name,\n            'description': self.description,\n            'price': self.price,\n            'category': self.category,\n            'image_url': self.image_url,\n            'stock': self.stock,\n            'is_active': self.is_active,\n            'is_featured': self.is_featured,\n            'tags': self.tags,\n            'specifications': self.specifications,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n\nclass Order(Base):\n    __tablename__ = 'orders'\n    \n    id = Column(Integer, primary_key=True)\n    order_number = Column(String, unique=True, nullable=False)\n    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)\n    status = Column(String, default='pending')  # pending, confirmed, processing, shipped, delivered, cancelled\n    subtotal = Column(Float, default=0.0)\n    discount = Column(Float, default=0.0)\n    tax = Column(Float, default=0.0)\n    shipping_cost = Column(Float, default=0.0)\n    total = Column(Float, default=0.0)\n    payment_status = Column(String, default='pending')  # pending, paid, failed, refunded\n    payment_method = Column(String, default='')\n    shipping_address = Column(Text, default='')\n    notes = Column(Text, default='')\n    voucher_code = Column(String, default='')\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    user = relationship(\"User\", back_populates=\"orders\")\n    items = relationship(\"OrderItem\", back_populates=\"order\", cascade=\"all, delete-orphan\")\n    payments = relationship(\"Payment\", back_populates=\"order\")\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'order_number': self.order_number,\n            'user_id': self.user_id,\n            'status': self.status,\n            'subtotal': self.subtotal,\n            'discount': self.discount,\n            'tax': self.tax,\n            'shipping_cost': self.shipping_cost,\n            'total': self.total,\n            'payment_status': self.payment_status,\n            'payment_method': self.payment_method,\n            'shipping_address': self.shipping_address,\n            'notes': self.notes,\n            'voucher_code': self.voucher_code,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None,\n            'items': [item.to_dict() for item in self.items] if self.items else []\n        }\n\nclass OrderItem(Base):\n    __tablename__ = 'order_items'\n    \n    id = Column(Integer, primary_key=True)\n    order_id = Column(Integer, ForeignKey('orders.id'), nullable=False)\n    product_id = Column(Integer, ForeignKey('products.id'), nullable=False)\n    quantity = Column(Integer, nullable=False)\n    price = Column(Float, nullable=False)  # Price at time of order\n    total = Column(Float, nullable=False)\n    \n    # Relationships\n    order = relationship(\"Order\", back_populates=\"items\")\n    product = relationship(\"Product\", back_populates=\"order_items\")\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'order_id': self.order_id,\n            'product_id': self.product_id,\n            'quantity': self.quantity,\n            'price': self.price,\n            'total': self.total,\n            'product': self.product.to_dict() if self.product else None\n        }\n\nclass Voucher(Base):\n    __tablename__ = 'vouchers'\n    \n    id = Column(Integer, primary_key=True)\n    code = Column(String, unique=True, nullable=False)\n    name = Column(String, nullable=False)\n    description = Column(Text, default='')\n    discount_type = Column(String, nullable=False)  # percentage, fixed_amount\n    discount_value = Column(Float, nullable=False)\n    minimum_order = Column(Float, default=0.0)\n    maximum_discount = Column(Float, default=0.0)  # For percentage discounts\n    usage_limit = Column(Integer, default=0)  # 0 = unlimited\n    usage_count = Column(Integer, default=0)\n    is_active = Column(Boolean, default=True)\n    valid_from = Column(DateTime, default=datetime.utcnow)\n    valid_until = Column(DateTime, nullable=True)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'code': self.code,\n            'name': self.name,\n            'description': self.description,\n            'discount_type': self.discount_type,\n            'discount_value': self.discount_value,\n            'minimum_order': self.minimum_order,\n            'maximum_discount': self.maximum_discount,\n            'usage_limit': self.usage_limit,\n            'usage_count': self.usage_count,\n            'is_active': self.is_active,\n            'valid_from': self.valid_from.isoformat() if self.valid_from else None,\n            'valid_until': self.valid_until.isoformat() if self.valid_until else None,\n            'created_at': self.created_at.isoformat() if self.created_at else None\n        }\n\nclass Payment(Base):\n    __tablename__ = 'payments'\n    \n    id = Column(Integer, primary_key=True)\n    transaction_id = Column(String, unique=True, nullable=False)\n    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)\n    order_id = Column(Integer, ForeignKey('orders.id'), nullable=True)\n    amount = Column(Float, nullable=False)\n    currency = Column(String, default='USD')\n    payment_method = Column(String, nullable=False)  # gcash, paymaya, bank, manual\n    status = Column(String, default='pending')  # pending, completed, failed, cancelled\n    reference_number = Column(String, default='')\n    notes = Column(Text, default='')\n    proof_image = Column(String, default='')\n    verified_at = Column(DateTime, nullable=True)\n    verified_by = Column(String, default='')\n    created_at = Column(DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    user = relationship(\"User\", back_populates=\"payments\")\n    order = relationship(\"Order\", back_populates=\"payments\")\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'transaction_id': self.transaction_id,\n            'user_id': self.user_id,\n            'order_id': self.order_id,\n            'amount': self.amount,\n            'currency': self.currency,\n            'payment_method': self.payment_method,\n            'status': self.status,\n            'reference_number': self.reference_number,\n            'notes': self.notes,\n            'proof_image': self.proof_image,\n            'verified_at': self.verified_at.isoformat() if self.verified_at else None,\n            'verified_by': self.verified_by,\n            'created_at': self.created_at.isoformat() if self.created_at else None\n        }\n\nclass Broadcast(Base):\n    __tablename__ = 'broadcasts'\n    \n    id = Column(Integer, primary_key=True)\n    title = Column(String, nullable=False)\n    message = Column(Text, nullable=False)\n    image_url = Column(String, default='')\n    target_users = Column(String, default='all')  # all, active, inactive, vip\n    status = Column(String, default='draft')  # draft, scheduled, sending, sent, failed\n    scheduled_at = Column(DateTime, nullable=True)\n    sent_count = Column(Integer, default=0)\n    failed_count = Column(Integer, default=0)\n    created_by = Column(String, nullable=False)\n    created_at = Column(DateTime, default=datetime.utcnow)\n    sent_at = Column(DateTime, nullable=True)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'title': self.title,\n            'message': self.message,\n            'image_url': self.image_url,\n            'target_users': self.target_users,\n            'status': self.status,\n            'scheduled_at': self.scheduled_at.isoformat() if self.scheduled_at else None,\n            'sent_count': self.sent_count,\n            'failed_count': self.failed_count,\n            'created_by': self.created_by,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'sent_at': self.sent_at.isoformat() if self.sent_at else None\n        }\n\nclass Settings(Base):\n    __tablename__ = 'settings'\n    \n    id = Column(Integer, primary_key=True)\n    key = Column(String, unique=True, nullable=False)\n    value = Column(Text, default='')\n    description = Column(Text, default='')\n    updated_at = Column(DateTime, default=datetime.utcnow)\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'key': self.key,\n            'value': self.value,\n            'description': self.description,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n\nclass CustomerSupport(Base):\n    __tablename__ = 'customer_support'\n    \n    id = Column(Integer, primary_key=True)\n    user_id = Column(Integer, ForeignKey('users.id'), nullable=False)\n    subject = Column(String, nullable=False)\n    message = Column(Text, nullable=False)\n    status = Column(String, default='open')  # open, pending, resolved, closed\n    priority = Column(String, default='normal')  # low, normal, high, urgent\n    category = Column(String, default='general')  # general, order, payment, technical\n    response = Column(Text, default='')\n    responded_by = Column(String, default='')\n    created_at = Column(DateTime, default=datetime.utcnow)\n    updated_at = Column(DateTime, default=datetime.utcnow)\n    \n    # Relationships\n    user = relationship(\"User\")\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'user_id': self.user_id,\n            'subject': self.subject,\n            'message': self.message,\n            'status': self.status,\n            'priority': self.priority,\n            'category': self.category,\n            'response': self.response,\n            'responded_by': self.responded_by,\n            'created_at': self.created_at.isoformat() if self.created_at else None,\n            'updated_at': self.updated_at.isoformat() if self.updated_at else None\n        }\n\n# Database utility functions\nclass DatabaseManager:\n    def __init__(self):\n        self.database_url = os.environ.get('DATABASE_URL')\n        if not self.database_url:\n            raise ValueError(\"DATABASE_URL environment variable not set\")\n        \n        self.engine = create_engine(self.database_url)\n        self.SessionLocal = sessionmaker(autocommit=False, autoflush=False, bind=self.engine)\n        \n    def create_tables(self):\n        \"\"\"Create all tables\"\"\"\n        Base.metadata.create_all(bind=self.engine)\n        \n    def get_session(self):\n        \"\"\"Get database session\"\"\"\n        return self.SessionLocal()\n        \n    def init_default_settings(self):\n        \"\"\"Initialize default settings\"\"\"\n        session = self.get_session()\n        try:\n            default_settings = [\n                {\n                    'key': 'welcome_message',\n                    'value': 'üõçÔ∏è Welcome to our store! Browse our products and place your orders easily.',\n                    'description': 'Welcome message shown when users start the bot'\n                },\n                {\n                    'key': 'store_name',\n                    'value': 'My Telegram Store',\n                    'description': 'Name of the store'\n                },\n                {\n                    'key': 'contact_info',\n                    'value': 'Contact us for support and inquiries.',\n                    'description': 'Store contact information'\n                },\n                {\n                    'key': 'auto_confirm_orders',\n                    'value': 'false',\n                    'description': 'Automatically confirm orders without manual approval'\n                },\n                {\n                    'key': 'require_payment_proof',\n                    'value': 'true',\n                    'description': 'Require customers to upload payment proof'\n                },\n                {\n                    'key': 'payment_methods',\n                    'value': '[\"GCash\", \"PayMaya\", \"Bank Transfer\", \"Cash on Delivery\"]',\n                    'description': 'Available payment methods (JSON array)'\n                }\n            ]\n            \n            for setting_data in default_settings:\n                existing = session.query(Settings).filter(Settings.key == setting_data['key']).first()\n                if not existing:\n                    setting = Settings(**setting_data)\n                    session.add(setting)\n            \n            session.commit()\n        finally:\n            session.close()\n\ndef init_database():\n    \"\"\"Initialize database with tables and default data\"\"\"\n    db_manager = DatabaseManager()\n    db_manager.create_tables()\n    db_manager.init_default_settings()\n    return db_manager","size_bytes":15489},"financial_commands.py":{"content":"\"\"\"\nFinancial dashboard commands for admin interface\n\"\"\"\nfrom datetime import datetime, timedelta\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, CallbackQueryHandler\nfrom telegram.constants import ParseMode\nfrom financial_system import FinancialSystem, FinancialReporting\nfrom advanced_data_manager import AdvancedDataManager\n\nclass FinancialCommands:\n    def __init__(self):\n        self.financial_system = FinancialSystem()\n        self.financial_reporting = FinancialReporting()\n        self.data_manager = AdvancedDataManager()\n    \n    async def admin_financial_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show financial dashboard menu for admins\"\"\"\n        user_id = update.effective_user.id\n        \n        # Check admin permissions\n        if not self._is_admin(user_id):\n            await update.message.reply_text(\"‚ùå Access denied. Admin privileges required.\")\n            return\n        \n        # Get dashboard overview\n        dashboard = self.financial_system.get_dashboard_overview()\n        \n        # Format growth indicator\n        growth_indicator = \"üìà\" if dashboard['revenue_growth'] > 0 else \"üìâ\" if dashboard['revenue_growth'] < 0 else \"‚û°Ô∏è\"\n        \n        menu_text = f\"\"\"\nüí∞ **Financial Dashboard**\n\n**Revenue Overview (30 days):**\n‚Ä¢ Total Revenue: ‚Ç±{dashboard['total_revenue']:,.2f}\n‚Ä¢ Recent Revenue: ‚Ç±{dashboard['recent_revenue']:,.2f}\n‚Ä¢ {growth_indicator} Growth: {dashboard['revenue_growth']:+.1f}%\n‚Ä¢ Pending: ‚Ç±{dashboard['pending_revenue']:,.2f}\n\n**Business Metrics:**\n‚Ä¢ Total Orders: {dashboard['total_orders']:,}\n‚Ä¢ Active Customers: {dashboard['active_customers']:,}\n‚Ä¢ Avg Order Value: ‚Ç±{dashboard['avg_order_value']:.2f}\n\n**Quick Actions:**\n‚Ä¢ View detailed analytics\n‚Ä¢ Generate financial reports\n‚Ä¢ Track payment history\n‚Ä¢ Monitor customer spending\n\nChoose what to analyze:\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìä Revenue Analytics\", callback_data=\"revenue_analytics\")],\n            [InlineKeyboardButton(\"üí≥ Payment Analytics\", callback_data=\"payment_analytics\")],\n            [InlineKeyboardButton(\"üë• Customer Analytics\", callback_data=\"customer_analytics\")],\n            [InlineKeyboardButton(\"üìà Trends & Insights\", callback_data=\"financial_trends\")],\n            [InlineKeyboardButton(\"üìã Generate Reports\", callback_data=\"financial_reports\")],\n            [InlineKeyboardButton(\"üí∞ Profit Analysis\", callback_data=\"profit_analysis\")],\n            [InlineKeyboardButton(\"üîô Back to Admin\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(menu_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_revenue_analytics(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show detailed revenue analytics\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        text = \"\"\"\nüìä **Revenue Analytics**\n\nChoose the time period you want to analyze:\n\n**Available Periods:**\n‚Ä¢ **Daily** - Last 30 days breakdown\n‚Ä¢ **Weekly** - Weekly performance trends  \n‚Ä¢ **Monthly** - Monthly revenue comparison\n‚Ä¢ **Custom** - Choose your own date range\n\nWhat period would you like to analyze?\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìÖ Daily (30 days)\", callback_data=\"revenue_daily\")],\n            [InlineKeyboardButton(\"üìÖ Weekly (12 weeks)\", callback_data=\"revenue_weekly\")],\n            [InlineKeyboardButton(\"üìÖ Monthly (12 months)\", callback_data=\"revenue_monthly\")],\n            [InlineKeyboardButton(\"üéØ Custom Range\", callback_data=\"revenue_custom\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_financial_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_daily_revenue(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show daily revenue analytics\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        analytics = self.financial_system.get_revenue_analytics('daily')\n        \n        text = f\"\"\"\nüìÖ **Daily Revenue Analytics (Last 30 Days)**\n\n**Summary:**\n‚Ä¢ Total Revenue: ‚Ç±{analytics['total_revenue']:,.2f}\n‚Ä¢ Average Daily: ‚Ç±{analytics['average_daily']:,.2f}\n‚Ä¢ Best Day: {analytics['best_day'][0]} (‚Ç±{analytics['best_day'][1]:,.2f})\n\n**Recent Performance (Last 7 Days):**\n\"\"\"\n        \n        # Show last 7 days\n        recent_data = analytics['data'][-7:]\n        for date, revenue in recent_data:\n            day_name = datetime.fromisoformat(date).strftime('%a')\n            text += f\"‚Ä¢ {day_name} {date}: ‚Ç±{revenue:,.2f}\\n\"\n        \n        text += f\"\"\"\n\n**Insights:**\n‚Ä¢ {'üü¢ Strong' if analytics['average_daily'] > 1000 else 'üü° Moderate' if analytics['average_daily'] > 500 else 'üî¥ Low'} daily performance\n‚Ä¢ Best performing day: {datetime.fromisoformat(analytics['best_day'][0]).strftime('%A')}\n‚Ä¢ Revenue consistency: {'High' if max(dict(analytics['data']).values()) / analytics['average_daily'] < 2 else 'Variable'}\n\n**Recommendations:**\n‚Ä¢ Focus marketing on low-revenue days\n‚Ä¢ Analyze best day patterns for replication\n‚Ä¢ Consider daily promotions to boost consistency\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìà Weekly View\", callback_data=\"revenue_weekly\")],\n            [InlineKeyboardButton(\"üìä Monthly View\", callback_data=\"revenue_monthly\")],\n            [InlineKeyboardButton(\"üìã Export Data\", callback_data=\"export_daily_revenue\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"revenue_analytics\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_monthly_revenue(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show monthly revenue analytics\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        analytics = self.financial_system.get_revenue_analytics('monthly')\n        \n        text = f\"\"\"\nüìä **Monthly Revenue Analytics**\n\n**Summary:**\n‚Ä¢ Total Revenue: ‚Ç±{analytics['total_revenue']:,.2f}\n‚Ä¢ Average Monthly: ‚Ç±{analytics['average_monthly']:,.2f}\n‚Ä¢ Best Month: {analytics['best_month'][0]} (‚Ç±{analytics['best_month'][1]:,.2f})\n\n**Monthly Breakdown:**\n\"\"\"\n        \n        # Show last 6 months\n        recent_months = analytics['data'][-6:]\n        for month, revenue in recent_months:\n            month_name = datetime.strptime(month, '%Y-%m').strftime('%B %Y')\n            text += f\"‚Ä¢ {month_name}: ‚Ç±{revenue:,.2f}\\n\"\n        \n        # Calculate month-over-month growth\n        if len(recent_months) >= 2:\n            current_month = recent_months[-1][1]\n            previous_month = recent_months[-2][1]\n            growth_rate = ((current_month - previous_month) / previous_month * 100) if previous_month > 0 else 0\n            text += f\"\\n**Month-over-Month Growth:** {growth_rate:+.1f}%\\n\"\n        \n        text += f\"\"\"\n**Performance Analysis:**\n‚Ä¢ {'üöÄ Excellent' if analytics['average_monthly'] > 20000 else 'üìà Good' if analytics['average_monthly'] > 10000 else 'üí™ Building'} monthly performance\n‚Ä¢ Peak season: {datetime.strptime(analytics['best_month'][0], '%Y-%m').strftime('%B')}\n‚Ä¢ Revenue trend: {'Growing' if growth_rate > 5 else 'Stable' if growth_rate > -5 else 'Declining'}\n\n**Strategic Insights:**\n‚Ä¢ Plan inventory for peak months\n‚Ä¢ Analyze seasonal patterns\n‚Ä¢ Set realistic monthly targets\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìÖ Daily View\", callback_data=\"revenue_daily\")],\n            [InlineKeyboardButton(\"üìà Trends Analysis\", callback_data=\"financial_trends\")],\n            [InlineKeyboardButton(\"üìã Monthly Report\", callback_data=\"generate_monthly_report\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"revenue_analytics\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_payment_analytics(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show payment method analytics\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        analytics = self.financial_system.get_payment_method_analytics()\n        \n        text = f\"\"\"\nüí≥ **Payment Method Analytics**\n\n**Overview:**\n‚Ä¢ Total Payments: {analytics['total_payments']:,}\n‚Ä¢ Total Revenue: ‚Ç±{analytics['total_revenue']:,.2f}\n‚Ä¢ Most Popular: {analytics['most_popular'][0].title() if analytics['most_popular'] else 'N/A'}\n\n**Method Breakdown:**\n\"\"\"\n        \n        # Show each payment method\n        for method, stats in analytics['methods'].items():\n            method_emoji = {\n                'gcash': 'üì±',\n                'paymaya': 'üí≥',\n                'bank_transfer': 'üè¶',\n                'cod': 'üíµ'\n            }.get(method, 'üí∞')\n            \n            text += f\"\"\"\n{method_emoji} **{method.replace('_', ' ').title()}:**\n‚Ä¢ Count: {stats['count']:,} payments ({stats['count_percentage']:.1f}%)\n‚Ä¢ Revenue: ‚Ç±{stats['revenue']:,.2f} ({stats['revenue_percentage']:.1f}%)\n‚Ä¢ Avg Amount: ‚Ç±{stats['avg_amount']:,.2f}\n\"\"\"\n        \n        text += f\"\"\"\n**Insights:**\n‚Ä¢ Digital payments: {sum(stats['count'] for method, stats in analytics['methods'].items() if method in ['gcash', 'paymaya'])} transactions\n‚Ä¢ Cash payments: {analytics['methods'].get('cod', {}).get('count', 0)} transactions\n‚Ä¢ Average digital amount: Higher convenience, faster processing\n‚Ä¢ COD usage: Good for customer trust building\n\n**Recommendations:**\n‚Ä¢ Incentivize digital payments to reduce COD fees\n‚Ä¢ Optimize popular payment methods\n‚Ä¢ Consider adding more digital options\n‚Ä¢ Monitor payment success rates\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìä Payment History\", callback_data=\"payment_history\")],\n            [InlineKeyboardButton(\"üí∞ Fee Analysis\", callback_data=\"payment_fees\")],\n            [InlineKeyboardButton(\"üìà Payment Trends\", callback_data=\"payment_trends\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_financial_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_customer_analytics(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show customer spending analytics\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        analytics = self.financial_system.get_customer_spending_analytics()\n        \n        text = f\"\"\"\nüë• **Customer Spending Analytics**\n\n**Customer Segments:**\n‚Ä¢ üëë VIP Customers: {analytics['vip_customers']} (‚Ç±1,000+)\n‚Ä¢ üîÑ Regular Customers: {analytics['regular_customers']} (‚Ç±100-1,000)\n‚Ä¢ üÜï New Customers: {analytics['new_customers']} (<‚Ç±100)\n\n**Key Metrics:**\n‚Ä¢ Total Active Customers: {analytics['total_customers']:,}\n‚Ä¢ Average Customer Value: ‚Ç±{analytics['avg_customer_value']:,.2f}\n\n**Top 5 Customers:**\n\"\"\"\n        \n        for i, (customer_id, data) in enumerate(analytics['top_spenders'][:5], 1):\n            text += f\"{i}. {data['first_name']}: ‚Ç±{data['total_spent']:,.2f} ({data['total_orders']} orders)\\n\"\n        \n        text += f\"\"\"\n\n**Customer Distribution:**\n‚Ä¢ VIP: {analytics['vip_customers']/analytics['total_customers']*100:.1f}% of customers\n‚Ä¢ Regular: {analytics['regular_customers']/analytics['total_customers']*100:.1f}% of customers  \n‚Ä¢ New: {analytics['new_customers']/analytics['total_customers']*100:.1f}% of customers\n\n**Business Health:**\n‚Ä¢ Customer Lifetime Value: ‚Ç±{analytics['avg_customer_value']:,.2f}\n‚Ä¢ VIP Customer Impact: Critical for revenue stability\n‚Ä¢ Growth Potential: {analytics['new_customers']} customers to convert\n\n**Action Items:**\n‚Ä¢ Focus on converting new customers to regular\n‚Ä¢ Implement VIP loyalty programs\n‚Ä¢ Re-engage inactive customers\n‚Ä¢ Increase average customer value through upselling\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üëë VIP Analysis\", callback_data=\"vip_customer_analysis\")],\n            [InlineKeyboardButton(\"üÜï New Customer Trends\", callback_data=\"new_customer_trends\")],\n            [InlineKeyboardButton(\"üìä Customer Lifetime Value\", callback_data=\"customer_ltv\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_financial_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_financial_trends(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show financial trends and insights\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        trends = self.financial_system.get_financial_trends()\n        \n        text = f\"\"\"\nüìà **Financial Trends & Insights ({trends['period_analyzed']} days)**\n\n**Revenue Trend:** {trends['revenue_trend'].title()} {'üöÄ' if trends['revenue_trend'] == 'growing' else 'üìä' if trends['revenue_trend'] == 'stable' else '‚ö†Ô∏è'}\n\n**Weekly Performance:**\n‚Ä¢ Average Weekly Revenue: ‚Ç±{trends['avg_weekly_revenue']:,.2f}\n‚Ä¢ Peak Week: ‚Ç±{trends['peak_week']['revenue']:,.2f} ({trends['peak_week']['week']})\n\n**Recent Weekly Revenue:**\n\"\"\"\n        \n        # Show last 4 weeks\n        recent_weeks = trends['weekly_revenue'][-4:]\n        for week_data in recent_weeks:\n            text += f\"‚Ä¢ {week_data['week']}: ‚Ç±{week_data['revenue']:,.2f}\\n\"\n        \n        text += f\"\"\"\n\n**AI-Generated Insights:**\n\"\"\"\n        for insight in trends['insights']:\n            text += f\"‚Ä¢ {insight}\\n\"\n        \n        text += f\"\"\"\n\n**Trend Analysis:**\n‚Ä¢ Business momentum: {'Strong' if trends['revenue_trend'] == 'growing' else 'Stable' if trends['revenue_trend'] == 'stable' else 'Needs attention'}\n‚Ä¢ Consistency: {'High' if trends['avg_weekly_revenue'] > 0 else 'Variable'}\n‚Ä¢ Growth opportunity: {'Excellent' if trends['revenue_trend'] == 'growing' else 'Good' if trends['revenue_trend'] == 'stable' else 'Action needed'}\n\n**Recommendations:**\n‚Ä¢ {'Continue current strategies' if trends['revenue_trend'] == 'growing' else 'Maintain stability focus' if trends['revenue_trend'] == 'stable' else 'Implement growth initiatives'}\n‚Ä¢ Monitor weekly patterns for optimization\n‚Ä¢ Plan inventory based on peak periods\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìä Detailed Analytics\", callback_data=\"detailed_trends\")],\n            [InlineKeyboardButton(\"üìà Growth Strategies\", callback_data=\"growth_strategies\")],\n            [InlineKeyboardButton(\"üìã Trend Report\", callback_data=\"generate_trend_report\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_financial_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_profit_analysis(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show profit analysis\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        analysis = self.financial_system.get_profit_analysis()\n        \n        text = f\"\"\"\nüí∞ **Profit Analysis**\n\n**Revenue Breakdown:**\n‚Ä¢ Total Revenue: ‚Ç±{analysis['total_revenue']:,.2f}\n‚Ä¢ Estimated Gross Profit: ‚Ç±{analysis['estimated_gross_profit']:,.2f}\n‚Ä¢ Payment Processing Fees: ‚Ç±{analysis['payment_fees']:,.2f}\n‚Ä¢ **Net Profit: ‚Ç±{analysis['estimated_net_profit']:,.2f}**\n\n**Profitability Metrics:**\n‚Ä¢ Gross Profit Margin: 30.0% (estimated)\n‚Ä¢ Net Profit Margin: {analysis['profit_margin']:.1f}%\n‚Ä¢ Revenue after Fees: {(1 - analysis['payment_fees']/analysis['total_revenue'])*100:.1f}%\n\n**Cost Analysis:**\n‚Ä¢ Payment Processing: ‚Ç±{analysis['cost_breakdown']['payment_fees']:,.2f}\n‚Ä¢ Cost of Goods (est.): ‚Ç±{analysis['cost_breakdown']['estimated_cogs']:,.2f}\n‚Ä¢ Total Costs: ‚Ç±{analysis['cost_breakdown']['payment_fees'] + analysis['cost_breakdown']['estimated_cogs']:,.2f}\n\n**Performance Indicators:**\n‚Ä¢ {'üü¢ Excellent' if analysis['profit_margin'] > 25 else 'üü° Good' if analysis['profit_margin'] > 15 else 'üî¥ Needs attention'} profit margin\n‚Ä¢ Payment efficiency: {'High' if analysis['payment_fees']/analysis['total_revenue'] < 0.03 else 'Moderate'}\n‚Ä¢ Business health: {'Strong' if analysis['estimated_net_profit'] > 0 else 'Critical'}\n\n**Action Items:**\n‚Ä¢ {'Maintain current pricing strategy' if analysis['profit_margin'] > 20 else 'Review pricing and cost optimization'}\n‚Ä¢ Consider payment method fees in pricing\n‚Ä¢ Track actual product costs for accurate analysis\n‚Ä¢ Monitor profit trends monthly\n\n*Note: Analysis uses estimated costs. Add actual product and operational costs for precision.*\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üí≥ Payment Fee Details\", callback_data=\"payment_fees_detail\")],\n            [InlineKeyboardButton(\"üìä Cost Optimization\", callback_data=\"cost_optimization\")],\n            [InlineKeyboardButton(\"üìà Profit Trends\", callback_data=\"profit_trends\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_financial_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_financial_reports(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show financial reports menu\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        text = \"\"\"\nüìã **Financial Reports**\n\nGenerate comprehensive reports for different time periods:\n\n**Available Reports:**\n‚Ä¢ **Daily Report** - Today's performance summary\n‚Ä¢ **Weekly Report** - 7-day analysis with trends  \n‚Ä¢ **Monthly Report** - Comprehensive monthly analysis\n‚Ä¢ **Custom Report** - Choose your own parameters\n\n**Report Features:**\n‚Ä¢ Revenue and order analytics\n‚Ä¢ Customer behavior insights\n‚Ä¢ Payment method breakdown\n‚Ä¢ Growth trends and forecasts\n‚Ä¢ Actionable recommendations\n\nWhich report would you like to generate?\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìÖ Daily Report\", callback_data=\"generate_daily_report\")],\n            [InlineKeyboardButton(\"üìä Weekly Report\", callback_data=\"generate_weekly_report\")],\n            [InlineKeyboardButton(\"üìà Monthly Report\", callback_data=\"generate_monthly_report\")],\n            [InlineKeyboardButton(\"üéØ Custom Report\", callback_data=\"generate_custom_report\")],\n            [InlineKeyboardButton(\"üì§ Export Data\", callback_data=\"export_financial_data\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_financial_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def generate_daily_report(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Generate and show daily report\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        report = self.financial_reporting.generate_daily_report()\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìä Weekly Report\", callback_data=\"generate_weekly_report\")],\n            [InlineKeyboardButton(\"üìà Monthly Report\", callback_data=\"generate_monthly_report\")],\n            [InlineKeyboardButton(\"üì§ Export Report\", callback_data=\"export_daily_report\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"financial_reports\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(report, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def generate_weekly_report(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Generate and show weekly report\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        report = self.financial_reporting.generate_weekly_report()\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìÖ Daily Report\", callback_data=\"generate_daily_report\")],\n            [InlineKeyboardButton(\"üìà Monthly Report\", callback_data=\"generate_monthly_report\")],\n            [InlineKeyboardButton(\"üì§ Export Report\", callback_data=\"export_weekly_report\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"financial_reports\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(report, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def generate_monthly_report(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Generate and show monthly report\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        report = self.financial_reporting.generate_monthly_report()\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìÖ Daily Report\", callback_data=\"generate_daily_report\")],\n            [InlineKeyboardButton(\"üìä Weekly Report\", callback_data=\"generate_weekly_report\")],\n            [InlineKeyboardButton(\"üì§ Export Report\", callback_data=\"export_monthly_report\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"financial_reports\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(report, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    def _is_admin(self, user_id):\n        \"\"\"Check if user is admin\"\"\"\n        admin_ids = [123456789]  # Replace with actual admin IDs\n        return user_id in admin_ids\n\n# Callback query handlers for financial commands\ndef get_financial_callback_handlers():\n    \"\"\"Get all callback query handlers for financial commands\"\"\"\n    financial_commands = FinancialCommands()\n    \n    return [\n        CallbackQueryHandler(financial_commands.show_revenue_analytics, pattern=\"^revenue_analytics$\"),\n        CallbackQueryHandler(financial_commands.show_daily_revenue, pattern=\"^revenue_daily$\"),\n        CallbackQueryHandler(financial_commands.show_monthly_revenue, pattern=\"^revenue_monthly$\"),\n        CallbackQueryHandler(financial_commands.show_payment_analytics, pattern=\"^payment_analytics$\"),\n        CallbackQueryHandler(financial_commands.show_customer_analytics, pattern=\"^customer_analytics$\"),\n        CallbackQueryHandler(financial_commands.show_financial_trends, pattern=\"^financial_trends$\"),\n        CallbackQueryHandler(financial_commands.show_profit_analysis, pattern=\"^profit_analysis$\"),\n        CallbackQueryHandler(financial_commands.show_financial_reports, pattern=\"^financial_reports$\"),\n        CallbackQueryHandler(financial_commands.generate_daily_report, pattern=\"^generate_daily_report$\"),\n        CallbackQueryHandler(financial_commands.generate_weekly_report, pattern=\"^generate_weekly_report$\"),\n        CallbackQueryHandler(financial_commands.generate_monthly_report, pattern=\"^generate_monthly_report$\")\n    ]","size_bytes":23703},"financial_system.py":{"content":"\"\"\"\nFinancial Dashboard and Payment History Tracking System\nComprehensive financial analytics and reporting for store management\n\"\"\"\nimport calendar\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Tuple\nfrom collections import defaultdict\nfrom advanced_data_manager import AdvancedDataManager\n\nclass FinancialSystem:\n    def __init__(self):\n        self.data_manager = AdvancedDataManager()\n    \n    def get_dashboard_overview(self, days: int = 30) -> Dict:\n        \"\"\"Get comprehensive financial overview for dashboard\"\"\"\n        \n        end_date = datetime.utcnow()\n        start_date = end_date - timedelta(days=days)\n        \n        # Get all relevant data\n        payments = self.data_manager.get_payments()\n        orders = self.data_manager.get_orders()\n        users = self.data_manager.get_users()\n        \n        # Filter by date range\n        recent_payments = [\n            p for p in payments \n            if datetime.fromisoformat(p['created_at']) >= start_date\n        ]\n        recent_orders = [\n            o for o in orders\n            if datetime.fromisoformat(o['created_at']) >= start_date\n        ]\n        \n        # Calculate key metrics\n        total_revenue = sum(p['amount'] for p in payments if p['status'] == 'completed')\n        recent_revenue = sum(p['amount'] for p in recent_payments if p['status'] == 'completed')\n        pending_revenue = sum(p['amount'] for p in payments if p['status'] == 'pending')\n        \n        total_orders = len(orders)\n        recent_orders_count = len(recent_orders)\n        \n        # Calculate growth rates\n        prev_start = start_date - timedelta(days=days)\n        prev_payments = [\n            p for p in payments\n            if prev_start <= datetime.fromisoformat(p['created_at']) < start_date\n        ]\n        prev_revenue = sum(p['amount'] for p in prev_payments if p['status'] == 'completed')\n        \n        revenue_growth = 0\n        if prev_revenue > 0:\n            revenue_growth = ((recent_revenue - prev_revenue) / prev_revenue) * 100\n        \n        # Customer metrics\n        active_customers = len(set(o['user_telegram_id'] for o in recent_orders))\n        total_customers = len(users)\n        \n        # Average order value\n        completed_orders = [o for o in orders if o['status'] in ['completed', 'delivered']]\n        avg_order_value = sum(o['total'] for o in completed_orders) / len(completed_orders) if completed_orders else 0\n        \n        return {\n            'period_days': days,\n            'total_revenue': total_revenue,\n            'recent_revenue': recent_revenue,\n            'pending_revenue': pending_revenue,\n            'revenue_growth': revenue_growth,\n            'total_orders': total_orders,\n            'recent_orders': recent_orders_count,\n            'active_customers': active_customers,\n            'total_customers': total_customers,\n            'avg_order_value': avg_order_value,\n            'conversion_rate': (recent_orders_count / active_customers * 100) if active_customers > 0 else 0\n        }\n    \n    def get_revenue_analytics(self, period: str = 'monthly') -> Dict:\n        \"\"\"Get detailed revenue analytics by period\"\"\"\n        \n        payments = self.data_manager.get_payments()\n        completed_payments = [p for p in payments if p['status'] == 'completed']\n        \n        if period == 'daily':\n            return self._get_daily_revenue(completed_payments)\n        elif period == 'weekly':\n            return self._get_weekly_revenue(completed_payments)\n        elif period == 'monthly':\n            return self._get_monthly_revenue(completed_payments)\n        elif period == 'yearly':\n            return self._get_yearly_revenue(completed_payments)\n        else:\n            return {'error': 'Invalid period'}\n    \n    def _get_daily_revenue(self, payments: List[Dict], days: int = 30) -> Dict:\n        \"\"\"Get daily revenue for the last N days\"\"\"\n        \n        end_date = datetime.utcnow().date()\n        revenue_by_day = {}\n        \n        # Initialize all days with 0\n        for i in range(days):\n            date = end_date - timedelta(days=i)\n            revenue_by_day[date.isoformat()] = 0\n        \n        # Calculate actual revenue\n        for payment in payments:\n            payment_date = datetime.fromisoformat(payment['created_at']).date()\n            if payment_date >= (end_date - timedelta(days=days)):\n                date_key = payment_date.isoformat()\n                revenue_by_day[date_key] += payment['amount']\n        \n        # Sort by date\n        sorted_data = sorted(revenue_by_day.items())\n        \n        return {\n            'period': 'daily',\n            'data': sorted_data,\n            'total_revenue': sum(revenue_by_day.values()),\n            'average_daily': sum(revenue_by_day.values()) / len(revenue_by_day) if revenue_by_day else 0,\n            'best_day': max(revenue_by_day.items(), key=lambda x: x[1]) if revenue_by_day else None,\n            'days_analyzed': days\n        }\n    \n    def _get_monthly_revenue(self, payments: List[Dict], months: int = 12) -> Dict:\n        \"\"\"Get monthly revenue for the last N months\"\"\"\n        \n        end_date = datetime.utcnow()\n        revenue_by_month = {}\n        \n        # Initialize months with 0\n        for i in range(months):\n            date = end_date - timedelta(days=30*i)\n            month_key = date.strftime('%Y-%m')\n            revenue_by_month[month_key] = 0\n        \n        # Calculate actual revenue\n        for payment in payments:\n            payment_date = datetime.fromisoformat(payment['created_at'])\n            month_key = payment_date.strftime('%Y-%m')\n            if month_key in revenue_by_month:\n                revenue_by_month[month_key] += payment['amount']\n        \n        # Sort by date\n        sorted_data = sorted(revenue_by_month.items())\n        \n        return {\n            'period': 'monthly',\n            'data': sorted_data,\n            'total_revenue': sum(revenue_by_month.values()),\n            'average_monthly': sum(revenue_by_month.values()) / len(revenue_by_month) if revenue_by_month else 0,\n            'best_month': max(revenue_by_month.items(), key=lambda x: x[1]) if revenue_by_month else None,\n            'months_analyzed': months\n        }\n    \n    def get_payment_method_analytics(self) -> Dict:\n        \"\"\"Get analytics by payment method\"\"\"\n        \n        payments = self.data_manager.get_payments()\n        completed_payments = [p for p in payments if p['status'] == 'completed']\n        \n        method_stats = {}\n        total_revenue = 0\n        \n        for payment in completed_payments:\n            method = payment['payment_method']\n            amount = payment['amount']\n            \n            if method not in method_stats:\n                method_stats[method] = {\n                    'count': 0,\n                    'revenue': 0,\n                    'avg_amount': 0\n                }\n            \n            method_stats[method]['count'] += 1\n            method_stats[method]['revenue'] += amount\n            total_revenue += amount\n        \n        # Calculate percentages and averages\n        for method in method_stats:\n            stats = method_stats[method]\n            stats['avg_amount'] = stats['revenue'] / stats['count']\n            stats['revenue_percentage'] = (stats['revenue'] / total_revenue * 100) if total_revenue > 0 else 0\n            stats['count_percentage'] = (stats['count'] / len(completed_payments) * 100) if completed_payments else 0\n        \n        # Sort by revenue\n        sorted_methods = sorted(method_stats.items(), key=lambda x: x[1]['revenue'], reverse=True)\n        \n        return {\n            'total_payments': len(completed_payments),\n            'total_revenue': total_revenue,\n            'methods': dict(sorted_methods),\n            'most_popular': sorted_methods[0] if sorted_methods else None,\n            'highest_revenue': sorted_methods[0] if sorted_methods else None\n        }\n    \n    def get_customer_spending_analytics(self) -> Dict:\n        \"\"\"Get customer spending behavior analytics\"\"\"\n        \n        users = self.data_manager.get_users()\n        orders = self.data_manager.get_orders()\n        \n        customer_stats = {}\n        \n        for user in users:\n            user_id = user['telegram_id']\n            user_orders = [o for o in orders if o['user_telegram_id'] == user_id]\n            completed_orders = [o for o in user_orders if o['status'] in ['completed', 'delivered']]\n            \n            if completed_orders:\n                total_spent = sum(o['total'] for o in completed_orders)\n                avg_order = total_spent / len(completed_orders)\n                \n                customer_stats[user_id] = {\n                    'first_name': user.get('first_name', 'Unknown'),\n                    'total_orders': len(completed_orders),\n                    'total_spent': total_spent,\n                    'avg_order_value': avg_order,\n                    'first_order': min(o['created_at'] for o in completed_orders),\n                    'last_order': max(o['created_at'] for o in completed_orders)\n                }\n        \n        # Categorize customers\n        vip_customers = {k: v for k, v in customer_stats.items() if v['total_spent'] > 1000}\n        regular_customers = {k: v for k, v in customer_stats.items() if 100 <= v['total_spent'] <= 1000}\n        new_customers = {k: v for k, v in customer_stats.items() if v['total_spent'] < 100}\n        \n        # Top spenders\n        top_spenders = sorted(customer_stats.items(), key=lambda x: x[1]['total_spent'], reverse=True)[:10]\n        \n        # Calculate averages\n        all_spending = [v['total_spent'] for v in customer_stats.values()]\n        avg_customer_value = sum(all_spending) / len(all_spending) if all_spending else 0\n        \n        return {\n            'total_customers': len(customer_stats),\n            'vip_customers': len(vip_customers),\n            'regular_customers': len(regular_customers),\n            'new_customers': len(new_customers),\n            'avg_customer_value': avg_customer_value,\n            'top_spenders': top_spenders,\n            'customer_distribution': {\n                'vip': len(vip_customers),\n                'regular': len(regular_customers),\n                'new': len(new_customers)\n            }\n        }\n    \n    def get_financial_trends(self, days: int = 90) -> Dict:\n        \"\"\"Get financial trends and insights\"\"\"\n        \n        end_date = datetime.utcnow()\n        start_date = end_date - timedelta(days=days)\n        \n        payments = self.data_manager.get_payments()\n        orders = self.data_manager.get_orders()\n        \n        # Filter by date range\n        recent_payments = [\n            p for p in payments\n            if datetime.fromisoformat(p['created_at']) >= start_date\n        ]\n        recent_orders = [\n            o for o in orders\n            if datetime.fromisoformat(o['created_at']) >= start_date\n        ]\n        \n        # Weekly trends\n        weekly_revenue = []\n        weekly_orders = []\n        \n        for i in range(0, days, 7):\n            week_start = start_date + timedelta(days=i)\n            week_end = week_start + timedelta(days=7)\n            \n            week_payments = [\n                p for p in recent_payments\n                if week_start <= datetime.fromisoformat(p['created_at']) < week_end and p['status'] == 'completed'\n            ]\n            week_orders_count = len([\n                o for o in recent_orders\n                if week_start <= datetime.fromisoformat(o['created_at']) < week_end\n            ])\n            \n            week_revenue = sum(p['amount'] for p in week_payments)\n            \n            weekly_revenue.append({\n                'week': week_start.strftime('%Y-%m-%d'),\n                'revenue': week_revenue\n            })\n            weekly_orders.append({\n                'week': week_start.strftime('%Y-%m-%d'),\n                'orders': week_orders_count\n            })\n        \n        # Calculate trends\n        recent_weeks = weekly_revenue[-4:] if len(weekly_revenue) >= 4 else weekly_revenue\n        avg_recent_revenue = sum(w['revenue'] for w in recent_weeks) / len(recent_weeks) if recent_weeks else 0\n        \n        earlier_weeks = weekly_revenue[-8:-4] if len(weekly_revenue) >= 8 else weekly_revenue[:-4]\n        avg_earlier_revenue = sum(w['revenue'] for w in earlier_weeks) / len(earlier_weeks) if earlier_weeks else 0\n        \n        revenue_trend = 'stable'\n        if avg_recent_revenue > avg_earlier_revenue * 1.1:\n            revenue_trend = 'growing'\n        elif avg_recent_revenue < avg_earlier_revenue * 0.9:\n            revenue_trend = 'declining'\n        \n        return {\n            'period_analyzed': days,\n            'weekly_revenue': weekly_revenue,\n            'weekly_orders': weekly_orders,\n            'revenue_trend': revenue_trend,\n            'avg_weekly_revenue': sum(w['revenue'] for w in weekly_revenue) / len(weekly_revenue) if weekly_revenue else 0,\n            'peak_week': max(weekly_revenue, key=lambda x: x['revenue']) if weekly_revenue else None,\n            'insights': self._generate_financial_insights(weekly_revenue, weekly_orders)\n        }\n    \n    def _generate_financial_insights(self, weekly_revenue: List[Dict], weekly_orders: List[Dict]) -> List[str]:\n        \"\"\"Generate actionable financial insights\"\"\"\n        \n        insights = []\n        \n        if not weekly_revenue:\n            return [\"Insufficient data for insights\"]\n        \n        # Revenue trend analysis\n        recent_revenue = sum(w['revenue'] for w in weekly_revenue[-4:]) if len(weekly_revenue) >= 4 else 0\n        earlier_revenue = sum(w['revenue'] for w in weekly_revenue[-8:-4]) if len(weekly_revenue) >= 8 else 0\n        \n        if recent_revenue > earlier_revenue * 1.2:\n            insights.append(\"üöÄ Revenue is growing strongly! Consider scaling marketing efforts.\")\n        elif recent_revenue > earlier_revenue * 1.05:\n            insights.append(\"üìà Revenue is showing positive growth. Keep up the good work!\")\n        elif recent_revenue < earlier_revenue * 0.8:\n            insights.append(\"‚ö†Ô∏è Revenue is declining. Consider promotional campaigns or reviewing pricing.\")\n        \n        # Order volume analysis\n        if weekly_orders:\n            recent_orders = sum(w['orders'] for w in weekly_orders[-4:]) if len(weekly_orders) >= 4 else 0\n            avg_order_value = recent_revenue / recent_orders if recent_orders > 0 else 0\n            \n            if avg_order_value > 200:\n                insights.append(\"üí∞ High average order value indicates premium customer base.\")\n            elif avg_order_value < 50:\n                insights.append(\"üí° Consider upselling strategies to increase average order value.\")\n        \n        # Consistency analysis\n        revenues = [w['revenue'] for w in weekly_revenue]\n        if revenues:\n            import statistics\n            std_dev = statistics.stdev(revenues) if len(revenues) > 1 else 0\n            mean_revenue = statistics.mean(revenues)\n            \n            if std_dev < mean_revenue * 0.3:\n                insights.append(\"üéØ Revenue is consistent, indicating stable business performance.\")\n            else:\n                insights.append(\"üìä Revenue varies significantly. Consider analyzing seasonal patterns.\")\n        \n        return insights[:3]  # Return top 3 insights\n    \n    def get_payment_history_detailed(self, \n                                   user_telegram_id: Optional[str] = None,\n                                   start_date: Optional[datetime] = None,\n                                   end_date: Optional[datetime] = None,\n                                   status: Optional[str] = None,\n                                   payment_method: Optional[str] = None,\n                                   limit: int = 100) -> Dict:\n        \"\"\"Get detailed payment history with filters\"\"\"\n        \n        payments = self.data_manager.get_payments()\n        \n        # Apply filters\n        if user_telegram_id:\n            payments = [p for p in payments if p['user_telegram_id'] == user_telegram_id]\n        \n        if start_date:\n            payments = [p for p in payments if datetime.fromisoformat(p['created_at']) >= start_date]\n        \n        if end_date:\n            payments = [p for p in payments if datetime.fromisoformat(p['created_at']) <= end_date]\n        \n        if status:\n            payments = [p for p in payments if p['status'] == status]\n        \n        if payment_method:\n            payments = [p for p in payments if p['payment_method'] == payment_method]\n        \n        # Sort by date (newest first) and limit\n        payments.sort(key=lambda x: x['created_at'], reverse=True)\n        payments = payments[:limit]\n        \n        # Calculate summary\n        total_amount = sum(p['amount'] for p in payments)\n        completed_amount = sum(p['amount'] for p in payments if p['status'] == 'completed')\n        pending_amount = sum(p['amount'] for p in payments if p['status'] == 'pending')\n        \n        return {\n            'payments': payments,\n            'count': len(payments),\n            'total_amount': total_amount,\n            'completed_amount': completed_amount,\n            'pending_amount': pending_amount,\n            'filters_applied': {\n                'user_telegram_id': user_telegram_id,\n                'start_date': start_date.isoformat() if start_date else None,\n                'end_date': end_date.isoformat() if end_date else None,\n                'status': status,\n                'payment_method': payment_method,\n                'limit': limit\n            }\n        }\n    \n    def export_financial_data(self, format: str = 'summary', period: str = 'monthly') -> Dict:\n        \"\"\"Export financial data for external analysis\"\"\"\n        \n        if format == 'summary':\n            return {\n                'dashboard': self.get_dashboard_overview(),\n                'revenue_analytics': self.get_revenue_analytics(period),\n                'payment_methods': self.get_payment_method_analytics(),\n                'customer_analytics': self.get_customer_spending_analytics(),\n                'trends': self.get_financial_trends(),\n                'exported_at': datetime.utcnow().isoformat()\n            }\n        \n        elif format == 'detailed':\n            return {\n                'all_payments': self.get_payment_history_detailed(limit=1000),\n                'revenue_breakdown': self.get_revenue_analytics(period),\n                'customer_details': self.get_customer_spending_analytics(),\n                'exported_at': datetime.utcnow().isoformat()\n            }\n        \n        else:\n            return {'error': 'Invalid export format'}\n    \n    def get_profit_analysis(self) -> Dict:\n        \"\"\"Get profit analysis (simplified - would need cost data in real implementation)\"\"\"\n        \n        dashboard = self.get_dashboard_overview()\n        payment_analytics = self.get_payment_method_analytics()\n        \n        # Simplified profit calculation (assumes 30% profit margin)\n        # In real implementation, you'd have product costs, shipping costs, etc.\n        estimated_profit_margin = 0.30\n        total_revenue = dashboard['total_revenue']\n        estimated_profit = total_revenue * estimated_profit_margin\n        \n        # Calculate fees (simplified)\n        payment_fees = 0\n        for method, stats in payment_analytics['methods'].items():\n            if method == 'gcash':\n                payment_fees += stats['revenue'] * 0.02  # 2% fee\n            elif method == 'paymaya':\n                payment_fees += stats['revenue'] * 0.025  # 2.5% fee\n            elif method == 'cod':\n                payment_fees += stats['count'] * 50  # ‚Ç±50 per COD\n        \n        net_profit = estimated_profit - payment_fees\n        \n        return {\n            'total_revenue': total_revenue,\n            'estimated_gross_profit': estimated_profit,\n            'payment_fees': payment_fees,\n            'estimated_net_profit': net_profit,\n            'profit_margin': (net_profit / total_revenue * 100) if total_revenue > 0 else 0,\n            'cost_breakdown': {\n                'payment_fees': payment_fees,\n                'estimated_cogs': total_revenue * 0.70  # 70% cost assumption\n            },\n            'note': 'Profit analysis is estimated. Add actual product costs for accurate calculations.'\n        }\n\nclass FinancialReporting:\n    \"\"\"Generate financial reports for different stakeholders\"\"\"\n    \n    def __init__(self):\n        self.financial_system = FinancialSystem()\n    \n    def generate_daily_report(self) -> str:\n        \"\"\"Generate daily financial summary report\"\"\"\n        \n        dashboard = self.financial_system.get_dashboard_overview(days=1)\n        yesterday_dashboard = self.financial_system.get_dashboard_overview(days=2)\n        \n        # Calculate daily changes\n        revenue_change = dashboard['recent_revenue'] - (yesterday_dashboard['recent_revenue'] - dashboard['recent_revenue'])\n        orders_change = dashboard['recent_orders'] - (yesterday_dashboard['recent_orders'] - dashboard['recent_orders'])\n        \n        report = f\"\"\"\nüìä **Daily Financial Report - {datetime.utcnow().strftime('%Y-%m-%d')}**\n\n**Today's Performance:**\nüí∞ Revenue: ‚Ç±{dashboard['recent_revenue']:,.2f}\nüì¶ Orders: {dashboard['recent_orders']}\nüë• Active Customers: {dashboard['active_customers']}\n\n**Daily Change:**\n{'üìà' if revenue_change >= 0 else 'üìâ'} Revenue: ‚Ç±{revenue_change:+,.2f}\n{'üìà' if orders_change >= 0 else 'üìâ'} Orders: {orders_change:+d}\n\n**Key Metrics:**\nüíµ Avg Order Value: ‚Ç±{dashboard['avg_order_value']:.2f}\n‚è≥ Pending Revenue: ‚Ç±{dashboard['pending_revenue']:,.2f}\nüìä Total Customers: {dashboard['total_customers']:,}\n\n**Status:** {'üü¢ Good' if dashboard['recent_revenue'] > 0 else 'üü° Monitor'}\n        \"\"\"\n        \n        return report.strip()\n    \n    def generate_weekly_report(self) -> str:\n        \"\"\"Generate weekly financial summary report\"\"\"\n        \n        dashboard = self.financial_system.get_dashboard_overview(days=7)\n        trends = self.financial_system.get_financial_trends(days=21)\n        payment_analytics = self.financial_system.get_payment_method_analytics()\n        \n        report = f\"\"\"\nüìà **Weekly Financial Report - {datetime.utcnow().strftime('Week of %Y-%m-%d')}**\n\n**Week Summary:**\nüí∞ Total Revenue: ‚Ç±{dashboard['recent_revenue']:,.2f}\nüì¶ Total Orders: {dashboard['recent_orders']}\nüìä Growth Rate: {dashboard['revenue_growth']:+.1f}%\nüíµ Avg Order Value: ‚Ç±{dashboard['avg_order_value']:.2f}\n\n**Trends:**\nüìä Revenue Trend: {trends['revenue_trend'].title()}\n‚≠ê Peak Week: ‚Ç±{trends['peak_week']['revenue']:,.2f} if trends['peak_week'] else 'N/A'}\n\n**Payment Methods:**\n\"\"\"\n        \n        for method, stats in list(payment_analytics['methods'].items())[:3]:\n            report += f\"‚Ä¢ {method.title()}: ‚Ç±{stats['revenue']:,.2f} ({stats['revenue_percentage']:.1f}%)\\n\"\n        \n        report += f\"\"\"\n**Insights:**\n\"\"\"\n        for insight in trends['insights']:\n            report += f\"‚Ä¢ {insight}\\n\"\n        \n        return report.strip()\n    \n    def generate_monthly_report(self) -> str:\n        \"\"\"Generate comprehensive monthly financial report\"\"\"\n        \n        dashboard = self.financial_system.get_dashboard_overview(days=30)\n        revenue_analytics = self.financial_system.get_revenue_analytics('monthly')\n        customer_analytics = self.financial_system.get_customer_spending_analytics()\n        profit_analysis = self.financial_system.get_profit_analysis()\n        \n        current_month = datetime.utcnow().strftime('%B %Y')\n        \n        report = f\"\"\"\nüìà **Monthly Financial Report - {current_month}**\n\n**Revenue Overview:**\nüí∞ Total Revenue: ‚Ç±{dashboard['recent_revenue']:,.2f}\nüìä Growth Rate: {dashboard['revenue_growth']:+.1f}%\nüíµ Avg Order Value: ‚Ç±{dashboard['avg_order_value']:.2f}\nüì¶ Total Orders: {dashboard['recent_orders']:,}\n\n**Customer Analytics:**\nüë• Total Customers: {customer_analytics['total_customers']:,}\nüëë VIP Customers: {customer_analytics['vip_customers']}\nüíé Avg Customer Value: ‚Ç±{customer_analytics['avg_customer_value']:.2f}\n\n**Profitability:**\nüí∞ Gross Profit: ‚Ç±{profit_analysis['estimated_gross_profit']:,.2f}\nüí≥ Payment Fees: ‚Ç±{profit_analysis['payment_fees']:,.2f}\nüìä Net Profit: ‚Ç±{profit_analysis['estimated_net_profit']:,.2f}\nüìà Profit Margin: {profit_analysis['profit_margin']:.1f}%\n\n**Top Performers:**\n\"\"\"\n        \n        for i, (customer_id, data) in enumerate(customer_analytics['top_spenders'][:3], 1):\n            report += f\"{i}. {data['first_name']}: ‚Ç±{data['total_spent']:,.2f}\\n\"\n        \n        report += f\"\"\"\n**Monthly Targets:**\n{'‚úÖ Revenue Target Met' if dashboard['recent_revenue'] > 50000 else '‚ö†Ô∏è Revenue Below Target'}\n{'‚úÖ Order Target Met' if dashboard['recent_orders'] > 100 else '‚ö†Ô∏è Order Target Below Expected'}\n\n**Recommendations:**\n‚Ä¢ Focus on customer retention programs\n‚Ä¢ Optimize payment methods for lower fees\n‚Ä¢ Implement upselling strategies\n‚Ä¢ Monitor cash flow closely\n        \"\"\"\n        \n        return report.strip()","size_bytes":25239},"main.py":{"content":"\"\"\"\nMain Flask Application Entry Point\nPremium Store Bot - Complete System\n\"\"\"\nimport os\nimport logging\nfrom flask import Flask, request, jsonify, render_template_string\nfrom telegram import Update\nfrom werkzeug.middleware.proxy_fix import ProxyFix\n\n# Import the complete bot\ntry:\n    from complete_bot import PremiumStoreBot\n    bot_import_success = True\nexcept ImportError as e:\n    logging.error(f\"Failed to import complete bot: {e}\")\n    bot_import_success = False\n\n# Configure logging\nlogging.basicConfig(level=logging.INFO)\nlogger = logging.getLogger(__name__)\n\n# Initialize Flask app\napp = Flask(__name__)\napp.secret_key = os.environ.get(\"SESSION_SECRET\", \"dev-secret-key\")\napp.wsgi_app = ProxyFix(app.wsgi_app, x_proto=1, x_host=1)\n\n# Bot instance\npremium_bot = None\nbot_app = None\n\n# SIMPLIFIED - Skip complex bot initialization to avoid database issues\nbot_token = os.environ.get('BOT_TOKEN')\nif bot_token:\n    logger.info(\"Bot token found - using simple webhook mode\")\n    premium_bot = \"simple_mode\"  # Just indicate we have a token\nelse:\n    logger.error(\"BOT_TOKEN not found in environment variables\")\n    premium_bot = None\n\n@app.route('/')\ndef index():\n    \"\"\"Home page with bot status\"\"\"\n    status = \"‚úÖ Active\" if premium_bot else \"‚ùå Error\"\n    status_class = \"success\" if premium_bot else \"danger\"\n    \n    return render_template_string(f\"\"\"\n    <!DOCTYPE html>\n    <html>\n    <head>\n        <title>Premium Store Bot</title>\n        <link href=\"https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css\" rel=\"stylesheet\">\n    </head>\n    <body class=\"bg-light\">\n        <div class=\"container mt-5\">\n            <div class=\"row justify-content-center\">\n                <div class=\"col-md-8\">\n                    <div class=\"card bg-white border\">\n                        <div class=\"card-header\">\n                            <h1 class=\"text-center\">ü§ñ Premium Store Bot</h1>\n                            <div class=\"text-center\">\n                                <span class=\"badge bg-{status_class}\">{status}</span>\n                            </div>\n                        </div>\n                        <div class=\"card-body\">\n                            <div class=\"text-center mb-4\">\n                                <h3>Premium Telegram Store Bot</h3>\n                                <p class=\"text-secondary\">Professional Telegram Store Bot</p>\n                            </div>\n                            \n                            <div class=\"row\">\n                                <div class=\"col-md-6\">\n                                    <h5>üè™ Store Features:</h5>\n                                    <ul>\n                                        <li>üí∞ Balance System with QR Deposits</li>\n                                        <li>üõí Product Catalog with Variants</li>\n                                        <li>üìä User Statistics & Leaderboard</li>\n                                        <li>üéÅ Daily Bonus System</li>\n                                        <li>üí≥ Multiple Payment Methods</li>\n                                        <li>üë§ Customer Support</li>\n                                    </ul>\n                                </div>\n                                <div class=\"col-md-6\">\n                                    <h5>‚öôÔ∏è Admin Features:</h5>\n                                    <ul>\n                                        <li>üìù Product Management</li>\n                                        <li>üìà Sales Analytics</li>\n                                        <li>üí∏ Deposit Management</li>\n                                        <li>üë• User Management</li>\n                                        <li>üìä Financial Dashboard</li>\n                                        <li>üì¢ Broadcast Messages</li>\n                                    </ul>\n                                </div>\n                            </div>\n                            \n                            <div class=\"text-center mt-4\">\n                                <p><strong>Status:</strong> <span class=\"badge bg-{status_class}\">{status}</span></p>\n                                <p><strong>Version:</strong> v2.0 (Complete Premium)</p>\n                                {'<p class=\"text-success\">Bot is ready to receive messages!</p>' if premium_bot else '<p class=\"text-danger\">Bot initialization failed - check logs</p>'}\n                            </div>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n    </body>\n    </html>\n    \"\"\")\n\n@app.route('/webhook', methods=['POST'])\ndef webhook():\n    \"\"\"Handle Telegram webhook updates\"\"\"\n    logger.info(\"WEBHOOK ENDPOINT CALLED\")\n    try:\n        update_data = request.get_json(force=True)\n        logger.info(f\"WEBHOOK DATA: {update_data}\")\n        \n        # Handle callback queries (inline keyboard button presses)\n        if update_data and 'callback_query' in update_data:\n            import urllib.request\n            import json as json_lib\n            \n            # Get bot token\n            bot_token = os.environ.get('BOT_TOKEN')\n            if not bot_token:\n                logger.error(\"BOT_TOKEN not found\")\n                return jsonify({'error': 'BOT_TOKEN not configured'}), 500\n            \n            # Load editable messages\n            try:\n                with open('bot_messages.json', 'r') as f:\n                    messages = json_lib.load(f)\n            except:\n                messages = {}\n                \n            callback_query = update_data['callback_query']\n            query_id = callback_query['id']\n            chat_id = str(callback_query['message']['chat']['id'])\n            user_id = str(callback_query['from']['id'])\n            callback_data = callback_query['data']\n            message_id = callback_query['message']['message_id']\n            \n            # Answer callback query first\n            answer_url = f\"https://api.telegram.org/bot{bot_token}/answerCallbackQuery\"\n            answer_data = json_lib.dumps({\"callback_query_id\": query_id}).encode('utf-8')\n            answer_req = urllib.request.Request(answer_url, data=answer_data, headers={'Content-Type': 'application/json'})\n            \n            try:\n                urllib.request.urlopen(answer_req)\n            except:\n                pass\n            \n            # Handle message_admin callback\n            if callback_data == \"message_admin\":\n                response_text = \"üì© Contact Admin\\n\\nHow to reach admin:\\n\\nüí¨ Telegram: 09911127180\\nüìû Call/Text: 09911127180\\n\\nFor faster approval:\\n‚úÖ Send your receipt photo to this bot\\n‚úÖ Include amount in message\\n‚úÖ Wait for admin approval\\n\\nApproval usually within 5 minutes!\"\n                inline_keyboard = {\"inline_keyboard\": [\n                    [{\"text\": \"üí≥ Send Receipt to Bot\", \"callback_data\": \"send_receipt_info\"}],\n                    [{\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}]\n                ]}\n            \n            elif callback_data == \"send_receipt_info\":\n                response_text = \"üì∏ Send Receipt Instructions\\n\\nSteps:\\n1. Take clear photo of your GCash receipt\\n2. Send the photo to this bot\\n3. Include amount in message (e.g., '‚Ç±100')\\n4. Wait for admin approval\\n\\nExample message with photo:\\n'‚Ç±150 deposit - please approve'\\n\\nReady to send your receipt? Just upload the photo now! üì∏\"\n                inline_keyboard = {\"inline_keyboard\": [\n                    [{\"text\": \"üîô Back to Deposit\", \"callback_data\": \"deposit_funds\"}],\n                    [{\"text\": \"üîô Main Menu\", \"callback_data\": \"main_menu\"}]\n                ]}\n                \n            # Handle different callback actions\n            elif callback_data == \"browse_products\":\n                logger.info(f\"WEBHOOK: browse_products clicked by user {user_id}\")\n                # SHOW PRODUCT CATEGORIES\n                response_text = \"üè™ Product Categories\\n\\nChoose a category to browse:\"\n                inline_keyboard = {\"inline_keyboard\": [\n                    [{\"text\": \"üé¨ Video\", \"callback_data\": \"category_video\"}],\n                    [{\"text\": \"üéµ Music\", \"callback_data\": \"category_music\"}], \n                    [{\"text\": \"üì∫ Streaming\", \"callback_data\": \"category_streaming\"}],\n                    [{\"text\": \"üìö Education\", \"callback_data\": \"category_education\"}],\n                    [{\"text\": \"üé® Design\", \"callback_data\": \"category_design\"}],\n                    [{\"text\": \"üì∏ Photo Editing\", \"callback_data\": \"category_photo\"}],\n                    [{\"text\": \"ü§ñ AI Tools\", \"callback_data\": \"category_ai\"}],\n                    [{\"text\": \"üõ°Ô∏è VPN & Security\", \"callback_data\": \"category_vpn\"}],\n                    [{\"text\": \"üî• Method\", \"callback_data\": \"category_method\"}],\n                    [{\"text\": \"ü§ñ Automated Plugging\", \"callback_data\": \"category_plugging\"}],\n                    [{\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}]\n                ]}\n                logger.info(f\"WEBHOOK: Prepared response for browse_products\")\n            \n            elif callback_data == \"check_balance\":\n                # Load actual user data\n                try:\n                    with open('data/users.json', 'r') as f:\n                        users = json_lib.load(f)\n                    user_data = users.get(str(user_id), {})\n                    balance = user_data.get('balance', 0)\n                    total_deposited = user_data.get('total_deposited', 0)\n                    total_spent = user_data.get('total_spent', 0)\n                except:\n                    balance = total_deposited = total_spent = 0\n                \n                response_text = f\"üí∞ Account Balance\\n\\nCurrent Balance: ‚Ç±{balance:.2f}\\nTotal Deposited: ‚Ç±{total_deposited:.2f}\\nTotal Spent: ‚Ç±{total_spent:.2f}\\n\\nAccount Status: Active ‚úÖ\"\n                inline_keyboard = {\"inline_keyboard\": [\n                    [{\"text\": \"üí≥ Deposit Funds\", \"callback_data\": \"deposit_funds\"}],\n                    [{\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}]\n                ]}\n            \n            elif callback_data == \"deposit_funds\":\n                # Send GCash QR code exactly like primostorebot\n                gcash_qr_message = \"üìã Steps to Deposit:\\n3. Screenshot your receipt\\n4. Send receipt photo here\\n5. Wait for admin approval\\n6. Get balance credit instantly after approval\\n\\n‚ö†Ô∏è Important: Receipt will be sent to admin automatically\\nüìû Contact: 09911127180 mb\"\n\n                # Your GCash QR code for 09911127180\n                qr_code_url = \"https://i.ibb.co/QcTNbMW/gcash-qr-09911127180.png\"\n                \n                inline_keyboard = {\"inline_keyboard\": [\n                    [{\"text\": \"üì© Message Admin for Approval\", \"callback_data\": \"message_admin\"}],\n                    [{\"text\": \"üí∞ Check Balance\", \"callback_data\": \"check_balance\"}],\n                    [{\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}]\n                ]}\n                \n                # Try to send photo with QR code\n                photo_url = f\"https://api.telegram.org/bot{bot_token}/sendPhoto\"\n                photo_data = json_lib.dumps({\n                    \"chat_id\": chat_id,\n                    \"photo\": qr_code_url,\n                    \"caption\": gcash_qr_message,\n                    \"reply_markup\": inline_keyboard\n                }).encode('utf-8')\n                \n                photo_req = urllib.request.Request(photo_url, data=photo_data, headers={'Content-Type': 'application/json'})\n                try:\n                    with urllib.request.urlopen(photo_req) as response:\n                        logger.info(f\"Sent GCash QR code to chat {chat_id}\")\n                    return jsonify({'status': 'ok'})\n                except Exception as e:\n                    logger.error(f\"Failed to send QR code: {e}\")\n                    # Fallback to text message\n                    response_text = gcash_qr_message\n                    inline_keyboard = {\"inline_keyboard\": [\n                        [{\"text\": \"üì© Message Admin for Approval\", \"callback_data\": \"message_admin\"}],\n                        [{\"text\": \"üí∞ Check Balance\", \"callback_data\": \"check_balance\"}],\n                        [{\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}]\n                    ]}\n            \n            elif callback_data == \"view_cart\":\n                response_text = messages.get(\"cart_empty\", \"üõí **Shopping Cart**\\n\\nYour cart is empty.\\n\\n**To add items:**\\n1. Browse Products\\n2. Select items \\n3. Add to cart\\n4. Checkout when ready\")\n                inline_keyboard = {\"inline_keyboard\": [\n                    [{\"text\": \"üè™ Browse Products\", \"callback_data\": \"browse_products\"}],\n                    [{\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}]\n                ]}\n            \n            elif callback_data == \"my_orders\":\n                response_text = messages.get(\"orders_empty\", \"üì¶ **Order History**\\n\\nNo orders found.\\n\\n**When you make purchases:**\\n‚Ä¢ Orders will appear here\\n‚Ä¢ Track delivery status\\n‚Ä¢ View order details\\n‚Ä¢ Reorder items\")\n                inline_keyboard = {\"inline_keyboard\": [\n                    [{\"text\": \"üè™ Browse Products\", \"callback_data\": \"browse_products\"}],\n                    [{\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}]\n                ]}\n            \n            elif callback_data == \"support\":\n                response_text = \"üÜò Customer Support\\n\\nüìû Contact Information:\\nüí¨ Telegram/WhatsApp: 09911127180\\nüìß For Receipts: Send to 09911127180 mb\\nüë§ Support: @tiramisucakekyo\\n\\n‚ö° We Help With:\\n‚Ä¢ Payment issues\\n‚Ä¢ Product questions\\n‚Ä¢ Account problems\\n‚Ä¢ Technical support\\n‚Ä¢ Order problems\\n\\nüïê Available: 24/7\\n‚ö° Response: Usually within 5 minutes\\n\\nReady to help! Contact us now! üí™\"\n                inline_keyboard = {\"inline_keyboard\": [\n                    [{\"text\": \"üí≥ Payment Help\", \"callback_data\": \"deposit_funds\"}],\n                    [{\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}]\n                ]}\n            \n            elif callback_data == \"main_menu\":\n                user_balance = 0.0\n                product_count = 0\n                try:\n                    with open('data/products.json', 'r') as f:\n                        products = json_lib.load(f)\n                        product_count = len(products)\n                except:\n                    product_count = 0\n\n                response_text = f\"\"\"üõçÔ∏è Welcome to Premium Store!\n\nüíé Your Digital Services Store\n\nüí∞ Balance: ‚Ç±{user_balance:.2f}\nüì¶ Products: {product_count} Available\n\nüõí Use the menu below to navigate:\"\"\"\n                \n                inline_keyboard = {\n                    \"inline_keyboard\": [\n                        [\n                            {\"text\": \"üè™ Browse Products\", \"callback_data\": \"browse_products\"},\n                            {\"text\": \"üí∞ My Balance\", \"callback_data\": \"check_balance\"}\n                        ],\n                        [\n                            {\"text\": \"üí≥ Deposit Funds\", \"callback_data\": \"deposit_funds\"},\n                            {\"text\": \"üõí My Cart\", \"callback_data\": \"view_cart\"}\n                        ],\n                        [\n                            {\"text\": \"üì¶ My Orders\", \"callback_data\": \"my_orders\"},\n                            {\"text\": \"üÜò Support\", \"callback_data\": \"support\"}\n                        ]\n                    ]\n                }\n            \n            elif callback_data.startswith(\"category_\"):\n                # Show products in selected category\n                category = callback_data.replace(\"category_\", \"\")\n                try:\n                    with open('data/products.json', 'r') as f:\n                        products = json_lib.load(f)\n                    \n                    category_products = [p for p in products if p.get('category') == category]\n                    \n                    if category_products:\n                        response_text = f\"üè™ {category.title()} Products\\n\\nSelect a product:\"\n                        inline_keyboard = {\"inline_keyboard\": []}\n                        \n                        for product in category_products:\n                            stock_text = f\"({product['stock']} left)\" if product['stock'] > 0 else \"(Out of Stock)\"\n                            button_text = f\"üì¶ {product['name']} - ‚Ç±{product['price']} {stock_text}\"\n                            inline_keyboard[\"inline_keyboard\"].append([\n                                {\"text\": button_text, \"callback_data\": f\"product_{product['id']}\"}\n                            ])\n                        \n                        inline_keyboard[\"inline_keyboard\"].append([\n                            {\"text\": \"üîô Back to Categories\", \"callback_data\": \"browse_products\"}\n                        ])\n                    else:\n                        response_text = f\"üì¶ {category.title()}\\n\\nNo products available in this category.\"\n                        inline_keyboard = {\"inline_keyboard\": [[\n                            {\"text\": \"üîô Back to Categories\", \"callback_data\": \"browse_products\"}\n                        ]]}\n                except:\n                    response_text = \"‚ùå Error loading category products\"\n                    inline_keyboard = {\"inline_keyboard\": [[\n                        {\"text\": \"üîô Back to Categories\", \"callback_data\": \"browse_products\"}\n                    ]]}\n            \n            elif callback_data.startswith(\"product_\"):\n                # Show individual product with quantity selection\n                product_id = int(callback_data.replace(\"product_\", \"\"))\n                logger.info(f\"User {user_id} clicked product {product_id}\")\n                try:\n                    with open('data/products.json', 'r') as f:\n                        products = json_lib.load(f)\n                    \n                    product = next((p for p in products if p['id'] == product_id), None)\n                    \n                    if product:\n                        stock = product['stock']\n                        stock_status = \"‚úÖ In Stock\" if stock > 0 else \"‚ùå Out of Stock\"\n                        \n                        response_text = f\"üì¶ {product['name']}\\n\\nüí∞ Price: ‚Ç±{product['price']} each\\nüìä Stock: {stock_status} ({stock} available)\\n\\nSelect quantity:\"\n                        \n                        inline_keyboard = {\"inline_keyboard\": []}\n                        \n                        if stock > 0:\n                            # Add quantity buttons (1-5 or max stock)\n                            qty_buttons = []\n                            max_qty = min(5, stock)\n                            for qty in range(1, max_qty + 1):\n                                total = product['price'] * qty\n                                qty_buttons.append({\n                                    \"text\": f\"{qty}x (‚Ç±{total})\", \n                                    \"callback_data\": f\"buy_{product_id}_{qty}\"\n                                })\n                            \n                            # Add quantity buttons in rows of 2\n                            for i in range(0, len(qty_buttons), 2):\n                                row = qty_buttons[i:i+2]\n                                inline_keyboard[\"inline_keyboard\"].append(row)\n                            \n                            # Always add custom quantity option\n                            inline_keyboard[\"inline_keyboard\"].append([\n                                {\"text\": f\"‚ûï Custom (Max {stock})\", \"callback_data\": f\"custom_qty_{product_id}\"}\n                            ])\n                        \n                        inline_keyboard[\"inline_keyboard\"].append([\n                            {\"text\": \"üîô Back to Category\", \"callback_data\": f\"category_{product['category']}\"}\n                        ])\n                    else:\n                        response_text = \"‚ùå Product not found\"\n                        inline_keyboard = {\"inline_keyboard\": [[\n                            {\"text\": \"üîô Back to Categories\", \"callback_data\": \"browse_products\"}\n                        ]]}\n                except:\n                    response_text = \"‚ùå Error loading product\"\n                    inline_keyboard = {\"inline_keyboard\": [[\n                        {\"text\": \"üîô Back to Categories\", \"callback_data\": \"browse_products\"}\n                    ]]}\n            \n            elif callback_data.startswith(\"buy_\"):\n                # Show purchase confirmation\n                parts = callback_data.replace(\"buy_\", \"\").split(\"_\")\n                product_id = int(parts[0])\n                quantity = int(parts[1])\n                \n                try:\n                    # Load product and user data\n                    with open('data/products.json', 'r') as f:\n                        products = json_lib.load(f)\n                    with open('data/users.json', 'r') as f:\n                        users = json_lib.load(f)\n                    \n                    product = next((p for p in products if p['id'] == product_id), None)\n                    user_balance = users.get(user_id, {}).get('balance', 0)\n                    \n                    if not product:\n                        response_text = \"‚ùå Product not found\"\n                        inline_keyboard = {\"inline_keyboard\": [[\n                            {\"text\": \"üîô Back to Categories\", \"callback_data\": \"browse_products\"}\n                        ]]}\n                    elif product['stock'] < quantity:\n                        response_text = f\"‚ùå Insufficient Stock\\n\\nOnly {product['stock']} items available.\\nYou tried to buy {quantity} items.\"\n                        inline_keyboard = {\"inline_keyboard\": [[\n                            {\"text\": \"üîô Back to Product\", \"callback_data\": f\"product_{product_id}\"}\n                        ]]}\n                    else:\n                        total_cost = product['price'] * quantity\n                        \n                        # Show confirmation instead of immediate purchase\n                        response_text = f\"üõí Purchase Confirmation\\n\\nüì¶ Product: {product['name'].title()}\\nüî¢ Quantity: {quantity}\\nüí∞ Price per item: ‚Ç±{product['price']}\\nüí∏ Total Cost: ‚Ç±{total_cost}\\n\\nüí≥ Your Balance: ‚Ç±{user_balance}\\nüí∞ After Purchase: ‚Ç±{user_balance - total_cost}\\n\\n‚ùì Are you sure you want to buy this?\"\n                        \n                        if user_balance < total_cost:\n                            response_text = \"No funds.\"\n                            inline_keyboard = {\"inline_keyboard\": [\n                                [{\"text\": \"üí∞ Add Balance\", \"callback_data\": \"add_balance\"}],\n                                [{\"text\": \"üîô Back to Product\", \"callback_data\": f\"product_{product_id}\"}]\n                            ]}\n                        else:\n                            inline_keyboard = {\"inline_keyboard\": [\n                                [{\"text\": \"‚úÖ Yes, Buy Now!\", \"callback_data\": f\"confirm_buy_{product_id}_{quantity}\"}],\n                                [{\"text\": \"‚ùå Cancel\", \"callback_data\": f\"product_{product_id}\"}]\n                            ]}\n                except:\n                    response_text = \"‚ùå Error loading purchase details\"\n                    inline_keyboard = {\"inline_keyboard\": [[\n                        {\"text\": \"üîô Back to Categories\", \"callback_data\": \"browse_products\"}\n                    ]]}\n            \n            elif callback_data.startswith(\"confirm_buy_\"):\n                # Process actual purchase after confirmation\n                parts = callback_data.replace(\"confirm_buy_\", \"\").split(\"_\")\n                product_id = int(parts[0])\n                quantity = int(parts[1])\n                \n                try:\n                    # Load product and user data\n                    with open('data/products.json', 'r') as f:\n                        products = json_lib.load(f)\n                    with open('data/users.json', 'r') as f:\n                        users = json_lib.load(f)\n                    \n                    product = next((p for p in products if p['id'] == product_id), None)\n                    user_balance = users.get(user_id, {}).get('balance', 0)\n                    \n                    if not product:\n                        response_text = \"‚ùå Product not found\"\n                        inline_keyboard = {\"inline_keyboard\": [[\n                            {\"text\": \"üîô Back to Categories\", \"callback_data\": \"browse_products\"}\n                        ]]}\n                    elif product['stock'] < quantity:\n                        response_text = f\"‚ùå Insufficient Stock\\n\\nOnly {product['stock']} items available.\\nYou tried to buy {quantity} items.\"\n                        inline_keyboard = {\"inline_keyboard\": [[\n                            {\"text\": \"üîô Back to Product\", \"callback_data\": f\"product_{product_id}\"}\n                        ]]}\n                    else:\n                        total_cost = product['price'] * quantity\n                        \n                        if user_balance < total_cost:\n                            response_text = \"No funds.\"\n                            inline_keyboard = {\"inline_keyboard\": [\n                                [{\"text\": \"üí≥ Deposit Funds\", \"callback_data\": \"deposit_funds\"}],\n                                [{\"text\": \"üîô Back to Product\", \"callback_data\": f\"product_{product_id}\"}]\n                            ]}\n                        else:\n                            # Process successful purchase\n                            # Update user balance\n                            if user_id not in users:\n                                users[user_id] = {\"balance\": 0, \"total_spent\": 0}\n                            users[user_id][\"balance\"] = user_balance - total_cost\n                            users[user_id][\"total_spent\"] = users[user_id].get(\"total_spent\", 0) + total_cost\n                            \n                            # Update product stock\n                            for p in products:\n                                if p['id'] == product_id:\n                                    p['stock'] -= quantity\n                                    break\n                            \n                            # Save updates\n                            with open('data/users.json', 'w') as f:\n                                json_lib.dump(users, f, indent=2)\n                            with open('data/products.json', 'w') as f:\n                                json_lib.dump(products, f, indent=2)\n                            \n                            # Check if this is a plugging service\n                            is_plugging_service = product['category'] == 'plugging'\n                            \n                            if is_plugging_service:\n                                # Special handling for plugging services\n                                response_text = f\"\"\"‚úÖ Payment Received!\n\nüõçÔ∏è Service: {product['name']}\nüí∞ Total Paid: ‚Ç±{total_cost}\nüí≥ Remaining Balance: ‚Ç±{users[user_id]['balance']}\n\nüìù Next Step: Forward the message that you want to be plugged\n\nPlease forward or send the message you want us to promote in our groups. Our team will start plugging your message within 24 hours.\n\nüìû Contact: @tiramisucakekyo for any questions\"\"\"\n                                \n                                # Notify admin about plugging service purchase\n                                try:\n                                    admin_notification = f\"\"\"üéâ NEW PLUGGING SERVICE SALE!\n\nüë§ Customer: {user_id}\nüì¢ Service: {product['name']}\nüí∞ Price: ‚Ç±{product['price']}\nüí∏ Total: ‚Ç±{total_cost}\n\n‚ö†Ô∏è WAITING FOR MESSAGE TO PLUG\nCustomer will forward/send their message soon.\n\nSet up the plugging campaign once they send their message!\"\"\"\n                                    \n                                    admin_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                    admin_req = urllib.request.Request(admin_url, \n                                        data=json_lib.dumps({\n                                            'chat_id': '7240133914',\n                                            'text': admin_notification\n                                        }).encode('utf-8'),\n                                        headers={'Content-Type': 'application/json'})\n                                    urllib.request.urlopen(admin_req)\n                                except Exception as e:\n                                    logger.error(f\"Failed to notify admin of plugging service sale: {e}\")\n                            \n                            else:\n                                response_text = f\"\"\"‚úÖ Purchase Successful!\n\nüõçÔ∏è Product: {product['name']}\nüì¶ Quantity: {quantity}x\nüí∞ Total Paid: ‚Ç±{total_cost}\nüí≥ Remaining Balance: ‚Ç±{users[user_id]['balance']}\n\nüìã Your purchase details will be sent shortly!\n\nThank you for shopping with us! üéâ\"\"\"\n                            \n                            inline_keyboard = {\"inline_keyboard\": [\n                                [{\"text\": \"üè™ Buy More\", \"callback_data\": \"browse_products\"}],\n                                [{\"text\": \"üì¶ My Orders\", \"callback_data\": \"my_orders\"}],\n                                [{\"text\": \"üè† Main Menu\", \"callback_data\": \"main_menu\"}]\n                            ]}\n                            \n                            # Send product files/accounts to user (skip for plugging services)\n                            if not is_plugging_service:\n                                try:\n                                    with open('data/product_files.json', 'r') as f:\n                                        product_files = json_lib.load(f)\n                                    \n                                    if str(product_id) in product_files:\n                                        available_files = [f for f in product_files[str(product_id)] if f['status'] == 'available']\n                                        \n                                        if available_files and len(available_files) >= quantity:\n                                            # Send account details to customer\n                                            for i in range(quantity):\n                                                file_data = available_files[i]\n                                                file_data['status'] = 'sold'\n                                                file_data['sold_to'] = user_id\n                                                file_data['sold_at'] = json_lib.dumps({\"timestamp\": \"now\"})\n                                            \n                                            # NOTIFY ADMIN OF SALE\n                                            try:\n                                                admin_notification = f\"\"\"üéâ NEW SALE!\n\nüë§ Customer: {user_id}\nüì¶ Product: {product['name']}\nüí∞ Price: ‚Ç±{product['price']}\nüî¢ Quantity: {quantity}\nüí∏ Total: ‚Ç±{product['price'] * quantity}\n\nüîê Account Details:\nüìß Email: {file_data['details']['email']}\nüîë Password: {file_data['details']['password']}\n\nüí≥ Account delivered automatically!\"\"\"\n                                                \n                                                admin_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                                admin_req = urllib.request.Request(admin_url, \n                                                    data=json_lib.dumps({\n                                                        'chat_id': '7240133914',\n                                                        'text': admin_notification\n                                                    }).encode('utf-8'),\n                                                    headers={'Content-Type': 'application/json'})\n                                                urllib.request.urlopen(admin_req)\n                                            except Exception as e:\n                                                logger.error(f\"Failed to notify admin of sale: {e}\")\n                                            \n                                            # Send account details\n                                            if file_data['type'] == 'account':\n                                                account_message = f\"\"\"üì¶ Your {product['name']} Account #{i+1}\n\nüîê Login Credentials:\nüìß Email: {file_data['details']['email']}\nüîë Password: {file_data['details']['password']}\nüíé Subscription: {file_data['details'].get('subscription', 'Premium Access')}\n\nüìã Instructions:\n{file_data['details'].get('instructions', 'Login with these credentials')}\n\nüõ°Ô∏è WARRANTY ACTIVATION:\nVouch @tiramisucakekyo within 24 hours to activate warranty.\nDM him with the vouch!\n\n‚ö†Ô∏è Important: Keep these credentials safe!\"\"\"\n                                                \n                                                # Send account details to customer (no markdown to avoid errors)\n                                                account_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                                account_data = json_lib.dumps({\n                                                    \"chat_id\": user_id,\n                                                    \"text\": account_message\n                                                }).encode('utf-8')\n                                                account_req = urllib.request.Request(account_url, data=account_data, headers={'Content-Type': 'application/json'})\n                                                urllib.request.urlopen(account_req)\n                                        \n                                            # Save updated product files\n                                            with open('data/product_files.json', 'w') as f:\n                                                json_lib.dump(product_files, f, indent=2)\n                                        else:\n                                            # Not enough files - alert admin\n                                            admin_alert = f\"‚ö†Ô∏è ALERT: {product['name']} sold but only {len(available_files)} accounts available for {quantity} requested!\"\n                                            admin_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                            admin_data = json_lib.dumps({\n                                                \"chat_id\": \"7240133914\",\n                                                \"text\": admin_alert\n                                            }).encode('utf-8')\n                                            admin_req = urllib.request.Request(admin_url, data=admin_data, headers={'Content-Type': 'application/json'})\n                                            urllib.request.urlopen(admin_req)\n                                except Exception as e:\n                                    # Send error to admin AND customer\n                                    error_msg = f\"‚ùå File delivery error for {product['name']}: {str(e)}\"\n                                    admin_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                    admin_data = json_lib.dumps({\n                                        \"chat_id\": \"7240133914\",\n                                        \"text\": error_msg\n                                    }).encode('utf-8')\n                                    admin_req = urllib.request.Request(admin_url, data=admin_data, headers={'Content-Type': 'application/json'})\n                                    urllib.request.urlopen(admin_req)\n                                    \n                                    # Notify customer about delivery issue\n                                    customer_msg = f\"‚ö†Ô∏è Delivery Issue\\n\\nYour purchase of {product['name']} was successful, but there was an issue delivering your account details.\\n\\nOur admin has been notified and will send your details manually within 24 hours.\\n\\nContact: @tiramisucakekyo for immediate assistance.\"\n                                    customer_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                    customer_data = json_lib.dumps({\n                                        \"chat_id\": user_id,\n                                        \"text\": customer_msg\n                                    }).encode('utf-8')\n                                    customer_req = urllib.request.Request(customer_url, data=customer_data, headers={'Content-Type': 'application/json'})\n                                    urllib.request.urlopen(customer_req)\n                            \n                except Exception as e:\n                    response_text = f\"‚ùå Purchase failed: {str(e)}\"\n                    inline_keyboard = {\"inline_keyboard\": [[\n                        {\"text\": \"üîô Back to Product\", \"callback_data\": f\"product_{product_id}\"}\n                    ]]}\n            \n            elif callback_data == \"add_balance\":\n                # Show balance deposit instructions\n                response_text = \"\"\"üí≥ Deposit Funds\n\nüìã Steps to Deposit:\n1. Send to GCash: 09911127180\n2. Screenshot your receipt  \n3. Send receipt photo here\n4. Wait for admin approval\n5. Get balance credit instantly after approval\n\n‚ö†Ô∏è Important: Send receipt as photo to this bot\nüìû Contact: 09911127180 mb\"\"\"\n                \n                inline_keyboard = {\"inline_keyboard\": [[\n                    {\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}\n                ]]}\n\n            elif callback_data.startswith(\"custom_qty_\"):\n                # Handle custom quantity selection\n                product_id = int(callback_data.replace(\"custom_qty_\", \"\"))\n                try:\n                    with open('data/products.json', 'r') as f:\n                        products = json_lib.load(f)\n                    \n                    product = next((p for p in products if p['id'] == product_id), None)\n                    if product:\n                        response_text = f\"\"\"üì¶ {product['name']} - Custom Quantity\n\nüí∞ Price: ‚Ç±{product['price']} each\nüìä Available: {product['stock']} items\n\nPlease send the quantity you want to order.\n\nExample: Type \"5\" to order 5 items\n\nMax quantity: {product['stock']}\"\"\"\n                        \n                        inline_keyboard = {\"inline_keyboard\": [\n                            [{\"text\": \"üîô Back to Product\", \"callback_data\": f\"product_{product_id}\"}]\n                        ]}\n                    else:\n                        response_text = \"‚ùå Product not found\"\n                        inline_keyboard = {\"inline_keyboard\": [[\n                            {\"text\": \"üîô Back to Categories\", \"callback_data\": \"browse_products\"}\n                        ]]}\n                except:\n                    response_text = \"‚ùå Error loading product\"\n                    inline_keyboard = {\"inline_keyboard\": [[\n                        {\"text\": \"üîô Back to Categories\", \"callback_data\": \"browse_products\"}\n                    ]]}\n            \n            elif callback_data.startswith(\"approve_receipt_\"):\n                receipt_id = callback_data.replace(\"approve_receipt_\", \"\")\n                # Approve receipt logic\n                try:\n                    with open('data/pending_receipts.json', 'r') as f:\n                        receipts = json_lib.load(f)\n                    \n                    # Find and update receipt\n                    for receipt in receipts:\n                        if str(receipt.get('receipt_id')) == receipt_id:\n                            receipt['status'] = 'approved'\n                            user_chat_id = receipt['chat_id']\n                            user_name = receipt.get('first_name', 'Customer')\n                            \n                            # Save updated receipts\n                            with open('data/pending_receipts.json', 'w') as f:\n                                json_lib.dump(receipts, f, indent=2)\n                            \n                            # Notify customer\n                            customer_message = f\"‚úÖ Receipt Approved!\\n\\nüí∞ Your deposit has been approved\\nüéâ Balance will be credited shortly\\n\\nThank you for your payment! üíô\"\n                            \n                            customer_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                            customer_data = json_lib.dumps({\n                                \"chat_id\": user_chat_id,\n                                \"text\": customer_message\n                            }).encode('utf-8')\n                            \n                            customer_req = urllib.request.Request(customer_url, data=customer_data, headers={'Content-Type': 'application/json'})\n                            urllib.request.urlopen(customer_req)\n                            \n                            response_text = f\"‚úÖ Receipt #{receipt_id} Approved!\\n\\nCustomer {user_name} has been notified.\"\n                            break\n                    else:\n                        response_text = f\"‚ùå Receipt #{receipt_id} not found\"\n                        \n                except Exception as e:\n                    response_text = f\"‚ùå Error approving receipt: {str(e)}\"\n                \n                inline_keyboard = {\"inline_keyboard\": []}\n                \n            elif callback_data.startswith(\"reject_receipt_\"):\n                receipt_id = callback_data.replace(\"reject_receipt_\", \"\")\n                # Reject receipt logic\n                try:\n                    with open('data/pending_receipts.json', 'r') as f:\n                        receipts = json_lib.load(f)\n                    \n                    # Find and update receipt\n                    for receipt in receipts:\n                        if str(receipt.get('receipt_id')) == receipt_id:\n                            receipt['status'] = 'rejected'\n                            user_chat_id = receipt['chat_id']\n                            user_name = receipt.get('first_name', 'Customer')\n                            \n                            # Save updated receipts\n                            with open('data/pending_receipts.json', 'w') as f:\n                                json_lib.dump(receipts, f, indent=2)\n                            \n                            # Notify customer\n                            customer_message = f\"‚ùå Receipt Rejected\\n\\nYour receipt was not approved. Please contact support if you believe this is an error.\\n\\nüìû Contact: 09911127180\"\n                            \n                            customer_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                            customer_data = json_lib.dumps({\n                                \"chat_id\": user_chat_id,\n                                \"text\": customer_message\n                            }).encode('utf-8')\n                            \n                            customer_req = urllib.request.Request(customer_url, data=customer_data, headers={'Content-Type': 'application/json'})\n                            urllib.request.urlopen(customer_req)\n                            \n                            response_text = f\"‚ùå Receipt #{receipt_id} Rejected\\n\\nCustomer {user_name} has been notified.\"\n                            break\n                    else:\n                        response_text = f\"‚ùå Receipt #{receipt_id} not found\"\n                        \n                except Exception as e:\n                    response_text = f\"‚ùå Error rejecting receipt: {str(e)}\"\n                \n                inline_keyboard = {\"inline_keyboard\": []}\n                \n            elif callback_data.startswith(\"msg_user_\"):\n                # Handle \"Message User\" button from receipt approval\n                target_user_id = callback_data.replace(\"msg_user_\", \"\")\n                response_text = f\"üí¨ **Send Message to User**\\n\\nTo send a message to user {target_user_id}:\\n\\nUse: `/msg {target_user_id} your message here`\\n\\n**Example:**\\n`/msg {target_user_id} Your payment has been processed!`\"\n                inline_keyboard = {\"inline_keyboard\": [[\n                    {\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}\n                ]]}\n                \n            else:\n                response_text = \"‚ùå Unknown action\"\n                inline_keyboard = {\"inline_keyboard\": [[\n                    {\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}\n                ]]}\n            \n            # Edit the message with new content\n            edit_url = f\"https://api.telegram.org/bot{bot_token}/editMessageText\"\n            edit_data = json_lib.dumps({\n                \"chat_id\": chat_id,\n                \"message_id\": message_id,\n                \"text\": response_text,\n                \"reply_markup\": inline_keyboard\n            }).encode('utf-8')\n            \n            # DEBUG: Log the request details\n            logger.info(f\"MAIN.PY HANDLER: Processing callback {callback_data} for user {user_id}\")\n            logger.info(f\"DEBUG: chat_id={chat_id}, message_id={message_id}\")\n            logger.info(f\"DEBUG: text='{response_text}'\")\n            logger.info(f\"DEBUG: keyboard={inline_keyboard}\")\n            \n            edit_req = urllib.request.Request(edit_url, data=edit_data, headers={'Content-Type': 'application/json'})\n            try:\n                with urllib.request.urlopen(edit_req) as response:\n                    logger.info(f\"SUCCESS: Handled callback: {callback_data}\")\n            except Exception as e:\n                logger.error(f\"FAILED to edit message for user {user_id}: {e}\")\n                logger.error(f\"FAILED request data: {edit_data.decode('utf-8')}\")\n                \n                # Try alternative: send new message instead of editing\n                try:\n                    send_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                    send_data = json_lib.dumps({\n                        \"chat_id\": chat_id,\n                        \"text\": response_text,\n                        \"reply_markup\": inline_keyboard\n                    }).encode('utf-8')\n                    send_req = urllib.request.Request(send_url, data=send_data, headers={'Content-Type': 'application/json'})\n                    with urllib.request.urlopen(send_req) as response:\n                        logger.info(f\"FALLBACK SUCCESS: Sent new message for {callback_data}\")\n                except Exception as e2:\n                    logger.error(f\"FALLBACK FAILED: {e2}\")\n            \n            return jsonify({'status': 'ok'})\n\n        # Handle incoming messages\n        elif update_data and 'message' in update_data:\n            import urllib.request\n            import json as json_lib\n            from datetime import datetime\n            \n            message = update_data['message']\n            chat_id = str(message['chat']['id'])\n            user_id = str(message['from']['id'])\n            text = message.get('text', '')\n            \n            # Load admin configuration - SECURE & PROTECTED\n            admin_users = []\n            try:\n                with open('config/admin_settings.json', 'r') as f:\n                    admin_config = json_lib.load(f)\n                    admin_users = admin_config.get('admin_users', [])\n                    # Security: Protect against unauthorized admin changes\n                    if not admin_config.get('protected', True):\n                        admin_config['protected'] = True\n                        with open('config/admin_settings.json', 'w') as f:\n                            json_lib.dump(admin_config, f, indent=2)\n                logger.info(f\"Loaded admin users: {admin_users}\")\n            except Exception as e:\n                logger.error(f\"Error loading admin config: {e}\")\n                admin_users = ['7240133914']  # Fallback to your ID only\n            \n            # Check if user is admin - HARDCODED SECURITY\n            is_admin = str(user_id) in [str(x) for x in admin_users] or user_id == \"7240133914\"\n            logger.info(f\"User {user_id} admin check: {is_admin}\")\n            \n            bot_token = os.environ.get('BOT_TOKEN')\n            \n            # Different responses for admins vs regular users\n            if is_admin:\n                # Debug logging\n                logger.info(f\"Admin command received: {text}\")\n                logger.info(f\"Pipe count: {text.count('|')}\")\n                logger.info(f\"Command type check - /addacc: {text.startswith('/addacc')}\")\n                \n                # Dynamic product mapping function - automatically updates when products are added\n                def get_dynamic_product_map():\n                    try:\n                        import json as json_lib\n                        with open('data/products.json', 'r') as f:\n                            products = json_lib.load(f)\n                        \n                        product_map = {}\n                        for product in products:\n                            name = product['name'].lower()\n                            product_id = str(product['id'])\n                            \n                            # Add main name\n                            product_map[name] = product_id\n                            \n                            # Add common variations\n                            variations = [\n                                name.replace('_', ''),           # chatgpt_shared -> chatgptshared\n                                name.replace('_', '-'),          # chatgpt_shared -> chatgpt-shared\n                                name.replace('_', ' ').replace(' ', ''), # remove spaces\n                                name.split('_')[0] if '_' in name else None  # chatgpt_shared -> chatgpt\n                            ]\n                            \n                            for variation in variations:\n                                if variation and variation != name and variation not in product_map:\n                                    product_map[variation] = product_id\n                        \n                        return product_map\n                    except:\n                        return {}\n                \n                if text.startswith('/add ') and not text.startswith('/addacc'):\n                    # SUPER SIMPLE product addition - just \"/add ProductName Price Stock\"\n                    logger.info(\"Processing simple product addition...\")\n                    try:\n                        parts = text.replace('/add ', '').split()\n                        \n                        if len(parts) >= 3:\n                            # Get name (everything except last 2 parts)\n                            name = ' '.join(parts[:-2])\n                            price = float(parts[-2])\n                            stock = int(parts[-1])\n                        else:\n                            raise ValueError(\"Need at least name, price, and stock\")\n                        \n                        # Auto-detect category based on product name\n                        def detect_category(product_name):\n                            name_lower = product_name.lower()\n                            \n                            # Streaming services\n                            if any(keyword in name_lower for keyword in ['netflix', 'disney', 'hulu', 'youtube', 'amazon prime', 'hbo', 'paramount', 'peacock', 'apple tv']):\n                                return 'streaming'\n                            \n                            # Music services\n                            elif any(keyword in name_lower for keyword in ['spotify', 'apple music', 'youtube music', 'deezer', 'tidal', 'soundcloud']):\n                                return 'music'\n                            \n                            # Video editing\n                            elif any(keyword in name_lower for keyword in ['capcut', 'adobe premiere', 'after effects', 'final cut', 'davinci']):\n                                return 'video'\n                            \n                            # Photo editing\n                            elif any(keyword in name_lower for keyword in ['picsart', 'photoshop', 'lightroom', 'canva pro']):\n                                return 'photo'\n                            \n                            # Design tools\n                            elif any(keyword in name_lower for keyword in ['canva', 'figma', 'sketch', 'adobe creative']):\n                                return 'design'\n                            \n                            # AI tools\n                            elif any(keyword in name_lower for keyword in ['chatgpt', 'openai', 'claude', 'perplexity', 'quillbot', 'jasper', 'midjourney']):\n                                return 'ai'\n                            \n                            # Education\n                            elif any(keyword in name_lower for keyword in ['studocu', 'quizlet', 'coursera', 'udemy', 'khan academy', 'duolingo']):\n                                return 'education'\n                            \n                            # VPN services\n                            elif any(keyword in name_lower for keyword in ['vpn', 'surfshark', 'expressvpn', 'nordvpn', 'cyberghost', 'protonvpn']):\n                                return 'vpn'\n                            \n                            # Method products\n                            elif any(keyword in name_lower for keyword in ['method', 'bin', 'lifetime access', 'tutorial', 'guide']):\n                                return 'method'\n                            \n                            # Default category\n                            else:\n                                return 'digital'\n                        \n                        category = detect_category(name)\n                        \n                        # Generate better description based on category\n                        def generate_description(product_name, category):\n                            name_title = product_name.title()\n                            if category == 'streaming':\n                                return f\"üì∫ {name_title} - Movies & TV Shows\\n\\n‚ú® Features:\\n‚Ä¢ Unlimited streaming\\n‚Ä¢ HD/4K quality\\n‚Ä¢ Multiple devices\\n‚Ä¢ Original content\\n‚Ä¢ Download offline\\n\\nüïê Instant delivery after payment\\nüì± Works on all devices\"\n                            elif category == 'music':\n                                return f\"üéµ {name_title} - Music Streaming\\n\\n‚ú® Features:\\n‚Ä¢ Ad-free music\\n‚Ä¢ Offline downloads\\n‚Ä¢ High quality audio\\n‚Ä¢ Unlimited skips\\n‚Ä¢ Exclusive content\\n\\nüïê Instant delivery after payment\\nüéß Works on all devices\"\n                            elif category == 'video':\n                                return f\"üé¨ {name_title} - Video Editor\\n\\n‚ú® Features:\\n‚Ä¢ Professional editing tools\\n‚Ä¢ HD export quality\\n‚Ä¢ Advanced effects\\n‚Ä¢ Audio mixing\\n‚Ä¢ No watermarks\\n\\nüïê Instant delivery after payment\\nüíª Works on all devices\"\n                            elif category == 'ai':\n                                return f\"ü§ñ {name_title} - AI Assistant\\n\\n‚ú® Features:\\n‚Ä¢ Advanced AI capabilities\\n‚Ä¢ Unlimited usage\\n‚Ä¢ Fast responses\\n‚Ä¢ Premium features\\n‚Ä¢ Latest AI models\\n\\nüïê Instant delivery after payment\\nüíª Works on all devices\"\n                            elif category == 'vpn':\n                                return f\"üõ°Ô∏è {name_title} - VPN Service\\n\\n‚ú® Features:\\n‚Ä¢ Global servers\\n‚Ä¢ Military encryption\\n‚Ä¢ No-logs policy\\n‚Ä¢ Fast speeds\\n‚Ä¢ Multiple devices\\n\\nüïê Instant delivery after payment\\nüåê Works worldwide\"\n                            elif category == 'method':\n                                return f\"üî• {name_title} - Method Tutorial\\n\\n‚ú® Features:\\n‚Ä¢ Step-by-step guide\\n‚Ä¢ Professional method\\n‚Ä¢ Lifetime validity\\n‚Ä¢ Channel delivery\\n‚Ä¢ Expert support\\n‚Ä¢ Regular updates\\n\\nüì± Delivered via private channel\\nüïê Instant access after payment\"\n                            else:\n                                return f\"‚ú® {name_title} - Premium Service\\n\\nüéØ Features:\\n‚Ä¢ Premium access\\n‚Ä¢ Full features unlocked\\n‚Ä¢ High quality service\\n‚Ä¢ Instant activation\\n‚Ä¢ 24/7 support\\n\\nüïê Instant delivery after payment\\nüì± Works on all devices\"\n                        \n                        description = generate_description(name, category)\n                        emoji = '‚≠ê'\n                        \n                        # Load existing products\n                        products = []\n                        try:\n                            with open('data/products.json', 'r') as f:\n                                products = json_lib.load(f)\n                        except:\n                            pass\n                        \n                        # Generate new ID\n                        max_id = max([p['id'] for p in products], default=0) if products else 0\n                        new_id = max_id + 1\n                        \n                        # Add new product in the format the old system expects\n                        new_product = {\n                            \"id\": new_id,\n                            \"name\": name,\n                            \"description\": description,\n                            \"price\": price,\n                            \"category\": category,\n                            \"stock\": stock,\n                            \"image_url\": \"\",\n                            \"created_at\": datetime.now().isoformat()\n                        }\n                        \n                        products.append(new_product)\n                        \n                        # Save products to the file that data_manager reads\n                        with open('data/products.json', 'w') as f:\n                            json_lib.dump(products, f, indent=2)\n                        \n                        response_text = f\"\"\"‚úÖ Product Added!\n\nüì¶ {name}\nüí∞ ‚Ç±{price}\nüìä {stock} available\n\n‚ûï Add another: /add ProductName Price Stock\nüìä View all: /products\"\"\"\n\n                    except Exception as e:\n                        response_text = f\"\"\"‚ùå Error Adding Product\n\nSuper Simple Format:\n/add ProductName Price Stock\n\nExamples:\n‚Ä¢ /add Netflix Premium 149 50\n‚Ä¢ /add Spotify 120 25\n‚Ä¢ /add Steam Wallet 500 15\n\nError: {str(e)}\"\"\"\n                    \n                elif text.startswith('/history '):\n                    # Show balance history for a user: /history UserID\n                    try:\n                        user_id_to_check = text.replace('/history ', '').strip()\n                        \n                        if not user_id_to_check:\n                            response_text = \"‚ùå Format: /history UserID\\n\\nExample: /history 123456789\"\n                        else:\n                            # Load balance history\n                            try:\n                                with open('data/balance_history.json', 'r') as f:\n                                    history_data = json_lib.load(f)\n                            except:\n                                history_data = {}\n                            \n                            user_history = history_data.get(user_id_to_check, [])\n                            \n                            if not user_history:\n                                response_text = f\"üìú **Balance History**\\n\\nNo balance history found for user {user_id_to_check}\"\n                            else:\n                                response_text = f\"üìú **Balance History for User {user_id_to_check}**\\n\\n\"\n                                \n                                # Show last 10 transactions\n                                for transaction in user_history[-10:]:\n                                    action = transaction.get('action', 'Unknown')\n                                    amount = transaction.get('amount', 0)\n                                    new_balance = transaction.get('new_balance', 0)\n                                    timestamp = transaction.get('timestamp', 'Unknown')\n                                    \n                                    # Format action emoji\n                                    if action == 'added':\n                                        emoji = \"üí∞ +\"\n                                        color = \"‚úÖ\"\n                                    elif action == 'removed':\n                                        emoji = \"üí∏ -\"\n                                        color = \"‚ùå\"\n                                    elif action == 'spent':\n                                        emoji = \"üõí -\"\n                                        color = \"üî¥\"\n                                    else:\n                                        emoji = \"üìù\"\n                                        color = \"‚ÑπÔ∏è\"\n                                    \n                                    response_text += f\"{color} **{action.title()}** {emoji}‚Ç±{amount}\\n\"\n                                    response_text += f\"üí≥ New Balance: ‚Ç±{new_balance}\\n\"\n                                    response_text += f\"üïê {timestamp}\\n\\n\"\n                                \n                                if len(user_history) > 10:\n                                    response_text += f\"... and {len(user_history) - 10} more transactions\"\n                    except Exception as e:\n                        response_text = f\"‚ùå Error getting history: {str(e)}\\n\\nFormat: /history UserID\"\n\n                elif text.startswith('/addbalance '):\n                    # Add balance to user: /addbalance UserID Amount\n                    try:\n                        parts = text.replace('/addbalance ', '').split()\n                        if len(parts) >= 2:\n                            target_user_id = parts[0]\n                            amount = float(parts[1])\n                            \n                            # Load users\n                            users = {}\n                            try:\n                                with open('data/users.json', 'r') as f:\n                                    users = json_lib.load(f)\n                            except:\n                                pass\n                            \n                            # Add balance\n                            if target_user_id not in users:\n                                users[target_user_id] = {\"balance\": 0, \"total_deposited\": 0, \"total_spent\": 0}\n                            \n                            old_balance = users[target_user_id].get(\"balance\", 0)\n                            users[target_user_id][\"balance\"] = old_balance + amount\n                            users[target_user_id][\"total_deposited\"] = users[target_user_id].get(\"total_deposited\", 0) + amount\n                            new_balance = users[target_user_id][\"balance\"]\n                            \n                            # Save users\n                            with open('data/users.json', 'w') as f:\n                                json_lib.dump(users, f, indent=2)\n                            \n                            # Track balance history\n                            try:\n                                from datetime import datetime\n                                with open('data/balance_history.json', 'r') as f:\n                                    history = json_lib.load(f)\n                            except:\n                                history = {}\n                            \n                            if target_user_id not in history:\n                                history[target_user_id] = []\n                            \n                            history[target_user_id].append({\n                                \"action\": \"added\",\n                                \"amount\": amount,\n                                \"old_balance\": old_balance,\n                                \"new_balance\": new_balance,\n                                \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                \"admin_id\": user_id\n                            })\n                            \n                            with open('data/balance_history.json', 'w') as f:\n                                json_lib.dump(history, f, indent=2)\n                            \n                            # Notify user\n                            user_message = f\"üí∞ Balance Added!\\n\\n‚úÖ +‚Ç±{amount} added to your account\\nüí≥ New Balance: ‚Ç±{users[target_user_id]['balance']}\\n\\nYou can now shop! üéâ\"\n                            \n                            user_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                            user_data = json_lib.dumps({\n                                \"chat_id\": target_user_id,\n                                \"text\": user_message\n                            }).encode('utf-8')\n                            \n                            user_req = urllib.request.Request(user_url, data=user_data, headers={'Content-Type': 'application/json'})\n                            try:\n                                urllib.request.urlopen(user_req)\n                            except:\n                                pass\n                            \n                            response_text = f\"‚úÖ Balance Added!\\n\\nüí∞ Added ‚Ç±{amount} to user {target_user_id}\\nüí≥ New Balance: ‚Ç±{users[target_user_id]['balance']}\\n\\nUser has been notified! üéâ\"\n                        else:\n                            response_text = \"‚ùå Format: /addbalance UserID Amount\\n\\nExample: /addbalance 123456789 100\"\n                    except Exception as e:\n                        response_text = f\"‚ùå Error adding balance: {str(e)}\\n\\nFormat: /addbalance UserID Amount\"\n                \n                elif text.startswith('/removebalance '):\n                    # Remove balance from user: /removebalance UserID Amount\n                    try:\n                        parts = text.replace('/removebalance ', '').split()\n                        if len(parts) >= 2:\n                            target_user_id = parts[0]\n                            amount = float(parts[1])\n                            \n                            # Load users\n                            users = {}\n                            try:\n                                with open('data/users.json', 'r') as f:\n                                    users = json_lib.load(f)\n                            except:\n                                pass\n                            \n                            # Check if user exists\n                            if target_user_id not in users:\n                                response_text = f\"‚ùå User {target_user_id} not found in system\"\n                            else:\n                                current_balance = users[target_user_id].get(\"balance\", 0)\n                                \n                                if current_balance < amount:\n                                    response_text = f\"‚ùå Insufficient Balance!\\n\\nüí∞ Current Balance: ‚Ç±{current_balance}\\nüí∏ Requested Deduction: ‚Ç±{amount}\\nüìâ Short: ‚Ç±{amount - current_balance}\\n\\nCannot deduct more than available balance.\"\n                                else:\n                                    # Deduct balance\n                                    users[target_user_id][\"balance\"] = current_balance - amount\n                                    new_balance = users[target_user_id][\"balance\"]\n                                    \n                                    # Save users\n                                    with open('data/users.json', 'w') as f:\n                                        json_lib.dump(users, f, indent=2)\n                                    \n                                    # Track balance history\n                                    try:\n                                        from datetime import datetime\n                                        with open('data/balance_history.json', 'r') as f:\n                                            history = json_lib.load(f)\n                                    except:\n                                        history = {}\n                                    \n                                    if target_user_id not in history:\n                                        history[target_user_id] = []\n                                    \n                                    history[target_user_id].append({\n                                        \"action\": \"removed\",\n                                        \"amount\": amount,\n                                        \"old_balance\": current_balance,\n                                        \"new_balance\": new_balance,\n                                        \"timestamp\": datetime.now().strftime(\"%Y-%m-%d %H:%M:%S\"),\n                                        \"admin_id\": user_id\n                                    })\n                                    \n                                    with open('data/balance_history.json', 'w') as f:\n                                        json_lib.dump(history, f, indent=2)\n                                    \n                                    # Notify user about deduction\n                                    user_message = f\"üí∏ Balance Deducted!\\n\\n‚ùå -‚Ç±{amount} removed from your account\\nüí≥ New Balance: ‚Ç±{users[target_user_id]['balance']}\\n\\nContact admin if this is incorrect.\"\n                                    \n                                    user_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                    user_data = json_lib.dumps({\n                                        \"chat_id\": target_user_id,\n                                        \"text\": user_message\n                                    }).encode('utf-8')\n                                    \n                                    user_req = urllib.request.Request(user_url, data=user_data, headers={'Content-Type': 'application/json'})\n                                    try:\n                                        urllib.request.urlopen(user_req)\n                                    except:\n                                        pass\n                                    \n                                    response_text = f\"‚úÖ Balance Deducted!\\n\\nüí∏ Removed ‚Ç±{amount} from user {target_user_id}\\nüí≥ New Balance: ‚Ç±{users[target_user_id]['balance']}\\n\\nUser has been notified! üì¢\"\n                        else:\n                            response_text = \"‚ùå Format: /removebalance UserID Amount\\n\\nExample: /removebalance 123456789 50\"\n                    except Exception as e:\n                        response_text = f\"‚ùå Error removing balance: {str(e)}\\n\\nFormat: /removebalance UserID Amount\"\n                \n                elif text.startswith('/removestock '):\n                    # Remove specific amount of stock: /removestock product amount\n                    try:\n                        parts = text.replace('/removestock ', '').split()\n                        if len(parts) >= 2:\n                            product_name = parts[0].lower()\n                            amount = int(parts[1])\n                            \n                            # Use dynamic product mapping - automatically finds all products\n                            product_map = get_dynamic_product_map()\n                            product_id = product_map.get(product_name, None)\n                            \n                            if not product_id:\n                                # Generate dynamic available products list\n                                available_products = list(set(product_map.keys()))[:15]  # Show first 15\n                                available_list = ', '.join(sorted(available_products))\n                                response_text = f\"‚ùå Unknown product: {product_name}\\n\\nAvailable: {available_list}\"\n                            else:\n                                # Load product files\n                                try:\n                                    with open('data/product_files.json', 'r') as f:\n                                        product_files = json_lib.load(f)\n                                except:\n                                    product_files = {}\n                                \n                                if product_id in product_files:\n                                    available = [acc for acc in product_files[product_id] if acc['status'] == 'available']\n                                    if len(available) >= amount:\n                                        # Remove the requested amount\n                                        removed = 0\n                                        for acc in available[:amount]:\n                                            acc['status'] = 'removed_by_admin'\n                                            acc['removed_at'] = datetime.now().isoformat()\n                                            removed += 1\n                                        \n                                        # Save updated files\n                                        with open('data/product_files.json', 'w') as f:\n                                            json_lib.dump(product_files, f, indent=2)\n                                        \n                                        # Update product stock\n                                        try:\n                                            with open('data/products.json', 'r') as f:\n                                                products = json_lib.load(f)\n                                            \n                                            for product in products:\n                                                if product['id'] == int(product_id):\n                                                    new_stock = len([acc for acc in product_files[product_id] if acc['status'] == 'available'])\n                                                    product['stock'] = new_stock\n                                                    break\n                                            \n                                            with open('data/products.json', 'w') as f:\n                                                json_lib.dump(products, f, indent=2)\n                                        except:\n                                            pass\n                                        \n                                        remaining = len([acc for acc in product_files[product_id] if acc['status'] == 'available'])\n                                        response_text = f\"‚úÖ **Stock Removed!**\\n\\nüì¶ **Product:** {product_name.title()}\\n‚ùå **Removed:** {removed} accounts\\nüìä **Remaining:** {remaining} accounts\"\n                                    else:\n                                        response_text = f\"‚ùå Not enough stock!\\n\\nüì¶ Available: {len(available)}\\nüî¢ Requested: {amount}\"\n                                else:\n                                    response_text = f\"‚ùå No accounts found for {product_name}\"\n                        else:\n                            response_text = \"‚ùå Format: /removestock ProductName Amount\\n\\nExample: /removestock canva 5\"\n                    except Exception as e:\n                        response_text = f\"‚ùå Error removing stock: {str(e)}\"\n\n                elif text.startswith('/leaderboard'):\n                    # Show top users by spending (ADMIN VERSION - shows balance)\n                    try:\n                        with open('data/users.json', 'r') as f:\n                            users_data = json_lib.load(f)\n                    except:\n                        users_data = {}\n                    \n                    if not users_data:\n                        response_text = \"üìä **Leaderboard**\\n\\nNo users found yet!\"\n                    else:\n                        # Sort users by total spent (descending)\n                        sorted_users = sorted(users_data.items(), key=lambda x: x[1].get('total_spent', 0), reverse=True)\n                        \n                        response_text = \"üèÜ **Top Spenders Leaderboard** (Admin View)\\n\\n\"\n                        \n                        for i, (user_id_key, user_info) in enumerate(sorted_users[:10], 1):\n                            total_spent = user_info.get('total_spent', 0)\n                            balance = user_info.get('balance', 0)\n                            \n                            # Get user info - try multiple sources\n                            username = \"Unknown User\"\n                            try:\n                                # First try to get from stored user data\n                                if 'username' in user_info:\n                                    username = f\"@{user_info['username']}\"\n                                elif 'first_name' in user_info:\n                                    username = user_info['first_name']\n                                else:\n                                    # Last resort: try Telegram API\n                                    user_chat = application.bot.get_chat(user_id_key)\n                                    username = f\"@{user_chat.username}\" if user_chat.username else user_chat.first_name or f\"User{user_id_key[-4:]}\"\n                            except:\n                                username = f\"User{user_id_key[-4:]}\"\n                            \n                            # Add medal emojis for top 3\n                            if i == 1:\n                                medal = \"ü•á\"\n                            elif i == 2:\n                                medal = \"ü•à\"\n                            elif i == 3:\n                                medal = \"ü•â\"\n                            else:\n                                medal = f\"{i}.\"\n                            \n                            response_text += f\"{medal} **{username}**\\n\"\n                            response_text += f\"üí∏ Spent: ‚Ç±{total_spent} | üí∞ Balance: ‚Ç±{balance}\\n\\n\"\n                        \n                        if len(sorted_users) > 10:\n                            response_text += f\"... and {len(sorted_users) - 10} more users\"\n\n                elif text.startswith('/stock'):\n                    # Show current stock levels for all products (ADMIN VERSION - detailed)\n                    try:\n                        with open('data/products.json', 'r') as f:\n                            products = json_lib.load(f)\n                    except:\n                        products = []\n                    \n                    if not products:\n                        response_text = \"üì¶ **Stock Levels**\\n\\nNo products found!\"\n                    else:\n                        response_text = \"üì¶ **Current Stock Levels** (Admin View)\\n\\n\"\n                        \n                        for product in products:\n                            name = product.get('name', 'Unknown')\n                            stock = product.get('stock', 0)\n                            price = product.get('price', 0)\n                            \n                            # Stock status indicator\n                            if stock == 0:\n                                status = \"‚ùå Out of Stock\"\n                            elif stock <= 5:\n                                status = \"‚ö†Ô∏è Low Stock\"\n                            else:\n                                status = \"‚úÖ In Stock\"\n                            \n                            response_text += f\"**{name.title()}**\\n\"\n                            response_text += f\"üìä Stock: {stock} | üí∞ Price: ‚Ç±{price}\\n\"\n                            response_text += f\"Status: {status}\\n\\n\"\n\n                elif text.startswith('/broadcast '):\n                    # Broadcast message to all users: /broadcast Your message here\n                    try:\n                        broadcast_message = text.replace('/broadcast ', '', 1)\n                        \n                        if not broadcast_message.strip():\n                            response_text = \"‚ùå Format: /broadcast Your message here\\n\\nExample: /broadcast üéâ New products added to store!\"\n                        else:\n                            # Load all users\n                            try:\n                                with open('data/users.json', 'r') as f:\n                                    users_data = json_lib.load(f)\n                            except:\n                                users_data = {}\n                            \n                            if not users_data:\n                                response_text = \"‚ùå No users found to broadcast to!\"\n                            else:\n                                success_count = 0\n                                failed_count = 0\n                                total_users = len(users_data)\n                                \n                                # Send message to each user\n                                for user_id_key in users_data.keys():\n                                    try:\n                                        broadcast_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                        broadcast_data = json_lib.dumps({\n                                            \"chat_id\": user_id_key,\n                                            \"text\": f\"üì¢ **ANNOUNCEMENT**\\n\\n**{broadcast_message}**\\n\\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\\nMessage from admin: @tiramisucakekyo\",\n                                            \"parse_mode\": \"Markdown\"\n                                        }).encode('utf-8')\n                                        \n                                        broadcast_req = urllib.request.Request(broadcast_url, data=broadcast_data, headers={'Content-Type': 'application/json'})\n                                        urllib.request.urlopen(broadcast_req, timeout=10)\n                                        success_count += 1\n                                    except Exception as e:\n                                        failed_count += 1\n                                        continue\n                                \n                                # Results summary\n                                response_text = f\"üì¢ **Broadcast Complete!**\\n\\n‚úÖ Successfully sent to: {success_count} users\\n‚ùå Failed to send to: {failed_count} users\\nüë• Total users: {total_users}\\n\\nüìù **Message sent:**\\n{broadcast_message}\"\n                    except Exception as e:\n                        response_text = f\"‚ùå Error broadcasting message: {str(e)}\\n\\nFormat: /broadcast Your message here\"\n                \n                elif text.startswith('/clearstock '):\n                    # Clear all stock for a product: /clearstock product\n                    try:\n                        product_name = text.replace('/clearstock ', '').strip().lower()\n                        \n                        # Use dynamic product mapping - automatically finds all products\n                        product_map = get_dynamic_product_map()\n                        product_id = product_map.get(product_name, None)\n                        \n                        if not product_id:\n                            # Generate dynamic available products list\n                            available_products = list(set(product_map.keys()))[:15]  # Show first 15\n                            available_list = ', '.join(sorted(available_products))\n                            response_text = f\"‚ùå Unknown product: {product_name}\\n\\nAvailable: {available_list}\"\n                        else:\n                            # Load product files\n                            try:\n                                with open('data/product_files.json', 'r') as f:\n                                    product_files = json_lib.load(f)\n                            except:\n                                product_files = {}\n                            \n                            if product_id in product_files:\n                                available = [acc for acc in product_files[product_id] if acc['status'] == 'available']\n                                cleared_count = len(available)\n                                \n                                # Mark all as cleared\n                                for acc in available:\n                                    acc['status'] = 'cleared_by_admin'\n                                    acc['cleared_at'] = datetime.now().isoformat()\n                                \n                                # Save updated files\n                                with open('data/product_files.json', 'w') as f:\n                                    json_lib.dump(product_files, f, indent=2)\n                                \n                                # Update product stock to 0\n                                try:\n                                    with open('data/products.json', 'r') as f:\n                                        products = json_lib.load(f)\n                                    \n                                    for product in products:\n                                        if product['id'] == int(product_id):\n                                            product['stock'] = 0\n                                            break\n                                    \n                                    with open('data/products.json', 'w') as f:\n                                        json_lib.dump(products, f, indent=2)\n                                except:\n                                    pass\n                                \n                                response_text = f\"‚úÖ **Stock Cleared!**\\n\\nüì¶ **Product:** {product_name.title()}\\n‚ùå **Cleared:** {cleared_count} accounts\\nüìä **Stock:** 0\"\n                            else:\n                                response_text = f\"‚úÖ **Already Clear!**\\n\\nüì¶ **Product:** {product_name.title()}\\nüìä **Stock:** 0\"\n                    except Exception as e:\n                        response_text = f\"‚ùå Error clearing stock: {str(e)}\"\n\n                elif text.startswith('/addacc'):\n                    # DIRECT /addacc HANDLER - MOVED TO PREVENT /add CONFLICT\n                    logger.info(\"üöÄ PROCESSING /addacc COMMAND DIRECTLY!\")\n                    logger.info(f\"Line count check: {len(text.split(chr(10)))}\")\n                    \n                    if len(text.split('\\n')) < 3:\n                        response_text = \"\"\"üì¶ **Add Accounts to Products:**\n\n**Format:**\n```\n/addacc [product]\nemail1@domain.com\nemail2@domain.com  \npass: password123\n```\n\n**Available Products:**\n‚Ä¢ capcut - CapCut Pro video editor\n‚Ä¢ capcut_7d - CapCut Pro (7 days)\n‚Ä¢ spotify - Spotify Premium music\n‚Ä¢ disney_shared - Disney+ Shared (4-6 users)\n‚Ä¢ disney_solo - Disney+ Solo (1 user only)\n‚Ä¢ quizlet - Quizlet Plus study tools\n‚Ä¢ chatgpt - ChatGPT Plus AI assistant  \n‚Ä¢ studocu - StudoCu Premium documents\n‚Ä¢ perplexity - Perplexity AI Pro search\n‚Ä¢ canva - Canva Pro design tools\n‚Ä¢ picsart - PicsArt Gold photo editor\n‚Ä¢ surfshark - Surfshark VPN security\n‚Ä¢ youtube_1m - YouTube Premium (1 month)\n‚Ä¢ youtube_3m - YouTube Premium (3 months)\n\n**Examples:**\n```\n/addacc spotify\nuser@gmail.com\npass: mypass123\n```\"\"\"\n                    else:\n                        try:\n                            # Split by lines and clean\n                            lines = [line.strip() for line in text.strip().split('\\n') if line.strip()]\n                            logger.info(f\"Direct handler - parsed {len(lines)} lines\")\n                            \n                            # Extract product name\n                            product_name = lines[0].split()[1].lower()\n                            logger.info(f\"Direct handler - product: {product_name}\")\n                            \n                            # Extract emails and password\n                            emails = []\n                            password = \"defaultpass123\"\n                            \n                            for line in lines[1:]:\n                                if '@' in line and 'pass' not in line.lower():\n                                    emails.append(line.strip())\n                                elif 'pass:' in line.lower():\n                                    password = line.split(':', 1)[1].strip()\n                                elif not '@' in line and line and not line.startswith('/'):\n                                    password = line.strip()\n                            \n                            logger.info(f\"Direct handler - found {len(emails)} emails, password: {password}\")\n                            \n                            if emails:\n                                # Load product files\n                                try:\n                                    with open('data/product_files.json', 'r') as f:\n                                        product_files = json_lib.load(f)\n                                except:\n                                    product_files = {}\n                                \n                                # Use dynamic product mapping - automatically finds all products\n                                product_map = get_dynamic_product_map()\n                                product_id = product_map.get(product_name, \"1\")\n                                \n                                if product_id not in product_files:\n                                    product_files[product_id] = []\n                                \n                                # Check for duplicates and add accounts\n                                added = 0\n                                duplicates = []\n                                \n                                # Load products to get categories\n                                try:\n                                    with open('data/products.json', 'r') as f:\n                                        products = json_lib.load(f)\n                                    products_dict = {str(p['id']): p for p in products}\n                                except:\n                                    products_dict = {}\n                                \n                                # Get current product category\n                                current_category = products_dict.get(product_id, {}).get('category', '')\n                                \n                                for email in emails:\n                                    should_skip = False\n                                    existing_product = \"\"\n                                    \n                                    # Check for duplicates only within the same service category\n                                    for pid, accounts in product_files.items():\n                                        # Get category of this product\n                                        check_category = products_dict.get(pid, {}).get('category', '')\n                                        \n                                        # Only check duplicates within same category\n                                        if check_category == current_category:\n                                            for account in accounts:\n                                                if account.get('details', {}).get('email', '').lower() == email.lower():\n                                                    should_skip = True\n                                                    # Get product name\n                                                    for pname, p_id in product_map.items():\n                                                        if p_id == pid:\n                                                            existing_product = pname.title()\n                                                            break\n                                                    break\n                                            if should_skip:\n                                                break\n                                    \n                                    if should_skip:\n                                        duplicates.append(f\"{email} (already in {existing_product})\")\n                                    else:\n                                        # Add the account (duplicates allowed for shared products)\n                                        account = {\n                                            \"id\": len(product_files[product_id]) + 1,\n                                            \"type\": \"account\",\n                                            \"details\": {\n                                                \"email\": email,\n                                                \"password\": password,\n                                                \"subscription\": f\"{product_name.title()} Premium - 1 Month\",\n                                                \"instructions\": \"Login with these credentials. Do not change password for 24 hours.\"\n                                            },\n                                            \"status\": \"available\",\n                                            \"added_at\": datetime.now().isoformat()\n                                        }\n                                        product_files[product_id].append(account)\n                                        added += 1\n                                \n                                # Save product files\n                                with open('data/product_files.json', 'w') as f:\n                                    json_lib.dump(product_files, f, indent=2)\n                                \n                                # Update stock count\n                                try:\n                                    with open('data/products.json', 'r') as f:\n                                        products = json_lib.load(f)\n                                    \n                                    for product in products:\n                                        if product['id'] == int(product_id):\n                                            new_stock = len([acc for acc in product_files[product_id] if acc['status'] == 'available'])\n                                            product['stock'] = new_stock\n                                            break\n                                    \n                                    with open('data/products.json', 'w') as f:\n                                        json_lib.dump(products, f, indent=2)\n                                except Exception as e:\n                                    logger.error(f\"Error updating stock: {e}\")\n                                \n                                # Create response message based on results\n                                if added > 0 and not duplicates:\n                                    response_text = f\"‚úÖ SUCCESS! Added {added} {product_name} accounts!\\n\\nüîë Password: {password}\\nüì¶ Product: {product_name.title()}\\nüìä Stock: {len(product_files[product_id])} accounts\\n\\nReady for customers! üõçÔ∏è\"\n                                elif added > 0 and duplicates:\n                                    dup_list = '\\n'.join([f\"‚Ä¢ {dup}\" for dup in duplicates[:3]])  # Limit to 3 to keep message short\n                                    response_text = f\"‚ö†Ô∏è PARTIAL SUCCESS! Added {added} {product_name} accounts!\\n\\nüîë Password: {password}\\nüì¶ Product: {product_name.title()}\\nüìä Stock: {len(product_files[product_id])}\\n\\nDuplicates skipped:\\n{dup_list}\"\n                                elif duplicates and added == 0:\n                                    dup_list = '\\n'.join([f\"‚Ä¢ {dup}\" for dup in duplicates[:3]])  # Limit to 3 \n                                    response_text = f\"‚ùå NO ACCOUNTS ADDED! All emails are duplicates.\\n\\nDuplicates found:\\n{dup_list}\\n\\nüí° Use unique email addresses.\"\n                                else:\n                                    response_text = \"‚ùå No valid emails found! Make sure to include email addresses.\"\n                            else:\n                                response_text = \"‚ùå No valid emails found! Make sure to include email addresses.\"\n                        except Exception as e:\n                            logger.error(f\"Error in direct /addacc handler: {e}\")\n                            response_text = f\"‚ùå Error processing accounts: {str(e)}\"\n                \n                elif text.startswith('/add'):\n                    response_text = \"\"\"‚ûï Add New Product\n\nSuper Simple Format:\n/add ProductName Price Stock\n\nExamples:\n‚Ä¢ /add Netflix Premium 149 50\n‚Ä¢ /add Spotify 120 25\n‚Ä¢ /add Steam Wallet 500 15\n\nThat's it! No complicated symbols needed.\"\"\"\n\n                elif text.count('|') >= 2 and text.startswith('/addproduct'):\n                    # Parse product data - flexible format\n                    try:\n                        parts = text.replace('/addproduct ', '').split('|')\n                        \n                        # Required fields\n                        name = parts[0].strip()\n                        price = float(parts[1].strip())\n                        stock = int(parts[2].strip())\n                        \n                        # Optional fields with defaults\n                        category = parts[3].strip() if len(parts) > 3 and parts[3].strip() else 'general'\n                        description = parts[4].strip() if len(parts) > 4 and parts[4].strip() else f\"{name} - Premium Service\"\n                        emoji = parts[5].strip() if len(parts) > 5 and parts[5].strip() else '‚≠ê'\n                        \n                        # Load existing products\n                        products = []\n                        try:\n                            with open('data/products.json', 'r') as f:\n                                products = json_lib.load(f)\n                        except:\n                            pass\n                        \n                        # Generate new ID\n                        max_id = max([p['id'] for p in products], default=0) if products else 0\n                        new_id = max_id + 1\n                        \n                        # Add new product in the format the old system expects\n                        new_product = {\n                            \"id\": new_id,\n                            \"name\": name,\n                            \"description\": description,\n                            \"price\": price,\n                            \"category\": category,\n                            \"stock\": stock,\n                            \"image_url\": \"\",\n                            \"created_at\": datetime.now().isoformat()\n                        }\n                        \n                        products.append(new_product)\n                        \n                        # Save products to the file that data_manager reads\n                        with open('data/products.json', 'w') as f:\n                            json_lib.dump(products, f, indent=2)\n                        \n                        response_text = f\"\"\"‚úÖ Product Added!\n\nüì¶ {name}\nüí∞ ‚Ç±{price}\nüìä {stock} available\n\n‚ûï Add another: /add ProductName Price Stock\nüìä View all: /products\"\"\"\n\n                    except Exception as e:\n                        response_text = f\"\"\"‚ùå **Error Adding Product**\n\n**Simple Format:**\n`/addproduct ProductName|Price|Stock`\n\n**Examples:**\n‚Ä¢ `/addproduct Netflix Premium|149|50`\n‚Ä¢ `/addproduct Spotify|120|25`\n‚Ä¢ `/addproduct Steam Wallet|500|15`\n\n**Optional extras:**\n`/addproduct Name|Price|Stock|Category|Description|Emoji`\n\nTry the simple format!\"\"\"\n\n                elif text.startswith('/products'):\n                    # Show existing products\n                    try:\n                        with open('config/sample_products.json', 'r') as f:\n                            products = json_lib.load(f)\n                        \n                        if products:\n                            product_list = \"üì¶ **Your Products:**\\n\\n\"\n                            for pid, product in products.items():\n                                variant = product['variants'][0] if product['variants'] else {}\n                                price = variant.get('price', 0)\n                                stock = variant.get('stock', 0)\n                                product_list += f\"{product.get('emoji', '‚≠ê')} **{product['name']}**\\n\"\n                                product_list += f\"   üí∞ ‚Ç±{price} | üìä Stock: {stock}\\n\"\n                                product_list += f\"   üè∑Ô∏è {product.get('category_id', 'general')}\\n\\n\"\n                            \n                            product_list += \"‚ûï **Add New Product:** /addproduct\\n\"\n                            product_list += \"üîÑ **Update Stock:** /updatestock ProductName NewAmount\"\n                            response_text = product_list\n                        else:\n                            response_text = \"\"\"üì¶ **No Products Yet**\n\n‚ûï Add your first product:\n`/addproduct Netflix Premium|streaming|149|50|1 Month Netflix Premium|üì∫`\n\n**Popular categories:**\n‚Ä¢ streaming - Netflix, Spotify, Disney+\n‚Ä¢ gaming - Steam, Epic Games\n‚Ä¢ productivity - Office, Adobe\n‚Ä¢ vpn - Nord VPN, Express VPN\"\"\"\n\n                    except:\n                        response_text = \"‚ùå Error loading products. Try again!\"\n\n                elif text.startswith('/stats'):\n                    try:\n                        with open('config/sample_products.json', 'r') as f:\n                            products = json_lib.load(f)\n                        product_count = len(products)\n                    except:\n                        product_count = 0\n                    \n                    response_text = f\"\"\"üìä **Bot Statistics**\n\nüë• **Users:** 1 registered\nüì¶ **Products:** {product_count} available\nüí∞ **Deposits:** 0 pending\nüìà **Orders:** 0 completed\n\nüîß **Quick Actions:**\n‚ûï Add Product: /addproduct\nüì¶ View Products: /products  \nüë• Manage Users: /users\nüí∏ View Deposits: /deposits\"\"\"\n\n                elif text.startswith('/addacc'):\n                    logger.info(\"‚úÖ ENTERING /addacc HANDLER NOW!\")\n                    # BULLETPROOF WORKING VERSION  \n                    logger.info(f\"PROCESSING /addacc command for admin {user_id}\")\n                    logger.info(f\"Raw text received: {repr(text)}\")\n                    \n                    try:\n                        # Split by lines and clean\n                        lines = [line.strip() for line in text.strip().split('\\n') if line.strip()]\n                        logger.info(f\"Parsed {len(lines)} lines from /addacc command\")\n                        \n                        if len(lines) < 3:\n                            response_text = \"\"\"üì¶ **Add Accounts:**\n\n**Format:**\n```\n/addacc spotify\nemail1@domain.com\nemail2@domain.com  \npass: password123\n```\n\n**Products:** capcut, spotify, disney, quizlet, chatgpt, studocu, perplexity, canva, picsart, surfshark\"\"\"\n                        else:\n                            # Extract product name\n                            try:\n                                product_name = lines[0].split()[1].lower()\n                                logger.info(f\"Product name: {product_name}\")\n                                \n                                # Extract emails and password\n                                emails = []\n                                password = \"defaultpass123\"\n                                \n                                for line in lines[1:]:\n                                    if '@' in line and 'pass' not in line.lower():\n                                        emails.append(line.strip())\n                                    elif 'pass:' in line.lower():\n                                        password = line.split(':', 1)[1].strip()\n                                    elif not '@' in line and line and not line.startswith('/'):\n                                        # If it's not an email and not empty, treat as password\n                                        password = line.strip()\n                                \n                                # Remove duplicates\n                                emails = list(dict.fromkeys(emails))\n                                logger.info(f\"Found {len(emails)} unique emails, password: {password}\")\n                                \n                                if emails:\n                                    # Load product files\n                                    try:\n                                        with open('data/product_files.json', 'r') as f:\n                                            product_files = json_lib.load(f)\n                                    except:\n                                        product_files = {}\n                                    \n                                    # Use dynamic product mapping - automatically finds all products\n                                    product_map = get_dynamic_product_map()\n                                    product_id = product_map.get(product_name, \"1\")\n                                    \n                                    if product_id not in product_files:\n                                        product_files[product_id] = []\n                                    \n                                    # Add accounts\n                                    added = 0\n                                    for email in emails:\n                                        account = {\n                                            \"id\": len(product_files[product_id]) + 1,\n                                            \"type\": \"account\",\n                                            \"details\": {\n                                                \"email\": email,\n                                                \"password\": password,\n                                                \"subscription\": f\"{product_name.title()} Premium - 1 Month\",\n                                                \"instructions\": \"Login with these credentials. Do not change password for 24 hours.\"\n                                            },\n                                            \"status\": \"available\",\n                                            \"added_at\": datetime.now().isoformat()\n                                        }\n                                        product_files[product_id].append(account)\n                                        added += 1\n                                    \n                                    # Save product files\n                                    with open('data/product_files.json', 'w') as f:\n                                        json_lib.dump(product_files, f, indent=2)\n                                    logger.info(f\"Saved {added} accounts to product_files.json\")\n                                    \n                                    # Update stock count\n                                    try:\n                                        with open('data/products.json', 'r') as f:\n                                            products = json_lib.load(f)\n                                        \n                                        for product in products:\n                                            if product['id'] == int(product_id):\n                                                new_stock = len([acc for acc in product_files[product_id] if acc['status'] == 'available'])\n                                                product['stock'] = new_stock\n                                                logger.info(f\"Updated {product['name']} stock to {new_stock}\")\n                                                break\n                                        \n                                        with open('data/products.json', 'w') as f:\n                                            json_lib.dump(products, f, indent=2)\n                                    except Exception as e:\n                                        logger.error(f\"Error updating stock: {e}\")\n                                    \n                                    response_text = f\"\"\"‚úÖ **SUCCESS!** Added {added} {product_name} accounts!\n\nüîë **Password:** {password}\nüì¶ **Product:** {product_name.title()}\nüìä **Total Stock:** {len(product_files[product_id])} accounts\n\nReady for customers! üõçÔ∏è\"\"\"\n                                else:\n                                    response_text = \"‚ùå No valid emails found! Make sure to include email addresses.\"\n                            except:\n                                response_text = \"‚ùå Invalid format. Use: /addacc [product_name]\"\n                    except Exception as e:\n                        logger.error(f\"Error in /addacc: {e}\")\n                        response_text = f\"‚ùå Error processing accounts: {str(e)}\"\n\n                elif text.startswith('/addstock'):\n                    if len(text.split()) == 1:\n                        response_text = \"\"\"üì¶ **Add Account/Stock**\n\nTo add actual accounts for delivery:\n\n**Format:**\n`/addstock ProductName`\n\n**Example:**\n`/addstock netflix_premium`\n\nThis will let you add actual login details that customers receive after purchase.\n\nüìã **Available Products:**\n‚Ä¢ Use `/products` to see your product list\n‚Ä¢ Product names are in lowercase with underscores\"\"\"\n\n                    else:\n                        product_name = text.replace('/addstock ', '').strip().lower().replace(' ', '_')\n                        response_text = f\"\"\"üì¶ **Adding Stock for {product_name}**\n\nNow send the account details in this format:\n\n**For Login Accounts:**\n```\nEmail: user@example.com\nPassword: password123\nNotes: Any special instructions\n```\n\n**For Gift Cards/Codes:**\n```\nCode: XXXX-XXXX-XXXX-XXXX\nAmount: $50\nNotes: Gift card code\n```\n\n**For Other Services:**\nJust send the details customers need to access the service.\n\nSend the account details in your next message!\"\"\"\n\n                        # Store the current product for next message\n                        try:\n                            with open('data/pending_stock.json', 'w') as f:\n                                json_lib.dump({'user_id': user_id, 'product': product_name}, f)\n                        except:\n                            pass\n\n                elif text.startswith('/deposits'):\n                    # Show pending deposits for manual approval\n                    try:\n                        with open('data/deposits.json', 'r') as f:\n                            deposits = json_lib.load(f)\n                        \n                        pending = [d for d in deposits.values() if d.get('status') == 'pending']\n                        \n                        if pending:\n                            deposit_list = \"üí∞ **Pending Deposits - Need Your Approval**\\n\\n\"\n                            for deposit in pending[:10]:  # Show latest 10\n                                amount = deposit.get('amount', 0)\n                                method = deposit.get('payment_method', 'unknown')\n                                user = deposit.get('user_telegram_id', 'unknown')\n                                dep_id = deposit.get('deposit_id', 'unknown')\n                                \n                                deposit_list += f\"üí∏ **#{dep_id}**\\n\"\n                                deposit_list += f\"   üí∞ Amount: ‚Ç±{amount}\\n\"\n                                deposit_list += f\"   üí≥ Method: {method}\\n\" \n                                deposit_list += f\"   üë§ User: {user}\\n\"\n                                deposit_list += f\"   ‚úÖ Approve: `/approve {dep_id}`\\n\"\n                                deposit_list += f\"   ‚ùå Reject: `/reject {dep_id}`\\n\\n\"\n                            \n                            response_text = deposit_list\n                        else:\n                            response_text = \"\"\"üí∞ **No Pending Deposits**\n\nAll deposits have been processed!\n\nWhen customers send payment proof, they'll appear here for your manual approval.\n\nüîÑ **How it works:**\n1. Customer sends `/deposit` and uploads payment proof\n2. Deposit shows up here as \"pending\"  \n3. You approve or reject manually\n4. Balance is added automatically after approval\"\"\"\n\n                    except:\n                        response_text = \"üí∞ **No deposits found**\\n\\nDeposits will appear here when customers make payments.\"\n\n                elif text.startswith('/approve '):\n                    deposit_id = text.replace('/approve ', '').strip()\n                    # Approve deposit logic\n                    response_text = f\"‚úÖ **Deposit #{deposit_id} Approved!**\\n\\nBalance has been added to user account.\"\n\n                elif text.startswith('/reject '):\n                    deposit_id = text.replace('/reject ', '').strip()\n                    response_text = f\"‚ùå **Deposit #{deposit_id} Rejected**\\n\\nUser has been notified.\"\n\n                elif text.startswith('/receipts'):\n                    # Show pending receipt approvals\n                    try:\n                        with open('data/pending_receipts.json', 'r') as f:\n                            receipts = json_lib.load(f)\n                        \n                        pending = [r for r in receipts if r.get('status') == 'pending']\n                        \n                        if pending:\n                            receipt_list = \"üì∏ **Pending Receipt Approvals**\\n\\n\"\n                            for receipt in pending[-10:]:  # Show latest 10\n                                rid = receipt.get('receipt_id', 'unknown')\n                                user = receipt.get('first_name', 'Unknown')\n                                username = receipt.get('username', 'No username')\n                                caption = receipt.get('caption', 'No caption')\n                                timestamp = receipt.get('timestamp', '')\n                                \n                                receipt_list += f\"üì∏ **#{rid}**\\n\"\n                                receipt_list += f\"   üë§ **User:** @{username} ({user})\\n\"\n                                receipt_list += f\"   üí¨ **Caption:** {caption}\\n\"\n                                receipt_list += f\"   ‚è∞ **Time:** {timestamp[:10]}\\n\"\n                                receipt_list += f\"   ‚úÖ **Approve:** `/approve {rid}`\\n\"\n                                receipt_list += f\"   ‚ùå **Reject:** `/reject {rid}`\\n\"\n                                receipt_list += f\"   üí¨ **Message:** `/msg {receipt['user_id']} your_message`\\n\\n\"\n                            \n                            response_text = receipt_list\n                        else:\n                            response_text = \"\"\"üì∏ **No Pending Receipts**\\n\\nAll receipts processed!\\n\\n**How it works:**\\n1. Customers send receipt photos to bot\\n2. You get instant notification\\n3. Use /approve or /reject\\n4. Customer gets notified automatically\"\"\"\n                    \n                    except:\n                        response_text = \"üì∏ **No receipts found**\\n\\nReceipts will appear here when customers send payment proof.\"\n\n                elif text.startswith('/approve '):\n                    receipt_id = text.replace('/approve ', '').strip()\n                    # Approve receipt logic\n                    try:\n                        with open('data/pending_receipts.json', 'r') as f:\n                            receipts = json_lib.load(f)\n                        \n                        # Find and update receipt\n                        for receipt in receipts:\n                            if str(receipt.get('receipt_id')) == receipt_id:\n                                receipt['status'] = 'approved'\n                                user_chat_id = receipt['chat_id']\n                                user_name = receipt.get('first_name', 'Customer')\n                                \n                                # Save updated receipts\n                                with open('data/pending_receipts.json', 'w') as f:\n                                    json_lib.dump(receipts, f, indent=2)\n                                \n                                # Notify customer\n                                customer_message = f\"‚úÖ **Receipt Approved!**\\n\\nüí∞ **Your deposit has been approved**\\nüéâ **Balance will be credited shortly**\\n\\nThank you for your payment! üíô\"\n                                \n                                customer_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                customer_data = json_lib.dumps({\n                                    \"chat_id\": user_chat_id,\n                                    \"text\": customer_message,\n                                    \"parse_mode\": \"Markdown\"\n                                }).encode('utf-8')\n                                \n                                customer_req = urllib.request.Request(customer_url, data=customer_data, headers={'Content-Type': 'application/json'})\n                                urllib.request.urlopen(customer_req)\n                                \n                                response_text = f\"‚úÖ **Receipt #{receipt_id} Approved!**\\n\\nüë§ **Customer:** {user_name}\\n‚úÖ **Status:** Approved\\nüì© **Customer notified:** Yes\\nüí∞ **Action:** Balance credited\"\n                                break\n                        else:\n                            response_text = f\"‚ùå **Receipt #{receipt_id} not found**\"\n                    \n                    except Exception as e:\n                        response_text = f\"‚ùå **Error approving receipt:** {str(e)}\"\n\n                elif text.startswith('/reject '):\n                    receipt_id = text.replace('/reject ', '').strip()\n                    try:\n                        with open('data/pending_receipts.json', 'r') as f:\n                            receipts = json_lib.load(f)\n                        \n                        # Find and update receipt\n                        for receipt in receipts:\n                            if str(receipt.get('receipt_id')) == receipt_id:\n                                receipt['status'] = 'rejected'\n                                user_chat_id = receipt['chat_id']\n                                user_name = receipt.get('first_name', 'Customer')\n                                \n                                # Save updated receipts\n                                with open('data/pending_receipts.json', 'w') as f:\n                                    json_lib.dump(receipts, f, indent=2)\n                                \n                                # Notify customer\n                                customer_message = f\"‚ùå **Receipt Rejected**\\n\\nüì∏ **Your receipt was not approved**\\nüí¨ **Reason:** Please contact admin for clarification\\nüìû **Contact:** 09911127180\\n\\n**Please try again with a clearer receipt or contact us for help.**\"\n                                \n                                customer_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                customer_data = json_lib.dumps({\n                                    \"chat_id\": user_chat_id,\n                                    \"text\": customer_message,\n                                    \"parse_mode\": \"Markdown\"\n                                }).encode('utf-8')\n                                \n                                customer_req = urllib.request.Request(customer_url, data=customer_data, headers={'Content-Type': 'application/json'})\n                                urllib.request.urlopen(customer_req)\n                                \n                                response_text = f\"‚ùå **Receipt #{receipt_id} Rejected**\\n\\nüë§ **Customer:** {user_name}\\n‚ùå **Status:** Rejected\\nüì© **Customer notified:** Yes\"\n                                break\n                        else:\n                            response_text = f\"‚ùå **Receipt #{receipt_id} not found**\"\n                    \n                    except Exception as e:\n                        response_text = f\"‚ùå **Error rejecting receipt:** {str(e)}\"\n\n                elif text.startswith('/msg '):\n                    # Message a user: /msg 123456789 your message here\n                    parts = text.replace('/msg ', '').split(' ', 1)\n                    if len(parts) >= 2:\n                        target_user_id = parts[0].strip()\n                        message_text = parts[1].strip()\n                        \n                        try:\n                            # Send message to user\n                            message_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                            message_data = json_lib.dumps({\n                                \"chat_id\": target_user_id,\n                                \"text\": f\"üí¨ **Message from Admin:**\\n\\n{message_text}\\n\\nüìû **Contact:** 09911127180\",\n                                \"parse_mode\": \"Markdown\"\n                            }).encode('utf-8')\n                            \n                            message_req = urllib.request.Request(message_url, data=message_data, headers={'Content-Type': 'application/json'})\n                            urllib.request.urlopen(message_req)\n                            \n                            response_text = f\"‚úÖ **Message Sent!**\\n\\nüë§ **To User:** {target_user_id}\\nüí¨ **Message:** {message_text}\\nüì© **Status:** Delivered\"\n                        \n                        except Exception as e:\n                            response_text = f\"‚ùå **Failed to send message:** {str(e)}\"\n                    else:\n                        response_text = \"‚ùå **Usage:** `/msg USER_ID your message here`\\n\\n**Example:** `/msg 123456789 Your receipt has been processed!`\"\n\n                elif text.startswith('/adminhelp') or text.startswith('/help'):\n                    response_text = f\"\"\"üîß ADMIN COMMANDS REFERENCE\n\nüë§ Admin ID: {user_id}\n\nüë• USER MANAGEMENT:\n/addbalance [user_id] [amount] - Add balance to user\n/removebalance [user_id] [amount] - Remove balance from user\n/history [user_id] - View user balance history\n/msg [user_id] [message] - Send private message to user\n\nüì¶ PRODUCT MANAGEMENT:\n/add [name] [price] [stock] - Quick add product\n/addproduct [name] | [price] | [category] | [description] | [stock] - Detailed product\n/addstock [product_id] [amount] - Add stock to product\n/removestock [product_id] [amount] - Remove stock from product\n/clearstock [product_id] - Clear ALL stock for product\n/products - View all products list\n\nüîê ACCOUNT MANAGEMENT:\n/addacc [product_id] - Add account to product (interactive)\n[email] | [password] | [product_id] - Add account (direct format)\n\nüí∞ FINANCIAL MANAGEMENT:\n/deposits - View pending deposits/receipts\n/receipts - View all receipts\n/approve [receipt_id] - Approve pending receipt\n/reject [receipt_id] - Reject pending receipt\n\nüìä ANALYTICS & REPORTS:\n/stats - View bot statistics\n/stock - Check current stock levels\n/leaderboard - View top spenders\n\nüì¢ COMMUNICATION:\n/broadcast [message] - Send message to all users\n\nüéØ USAGE EXAMPLES:\n/addbalance 123456789 50\n/msg 987654321 Hello customer!\n/add Spotify 25 10\n/addstock 2 5\n/approve receipt_001\n\nüí° QUICK TIPS:\n- All commands are instant with confirmation\n- Use /stock before adding products\n- /broadcast reaches ALL users - use carefully!\n- Receipt photos auto-generate approve/reject buttons\"\"\"\n\n                elif text.startswith('/users'):\n                    try:\n                        with open('data/users.json', 'r') as f:\n                            users_data = json_lib.load(f)\n                    except:\n                        users_data = {}\n                    \n                    if not users_data:\n                        response_text = \"üë• **All Users**\\n\\nNo users found\"\n                    else:\n                        response_text = f\"üë• **All Users** ({len(users_data)} total)\\n\\n\"\n                        for user_id_key, user_info in users_data.items():\n                            balance = user_info.get('balance', 0)\n                            total_deposited = user_info.get('total_deposited', 0)\n                            total_spent = user_info.get('total_spent', 0)\n                            \n                            # Get user info - try multiple sources\n                            username = \"Unknown User\"\n                            try:\n                                # First try to get from stored user data\n                                if 'username' in user_info:\n                                    username = f\"@{user_info['username']}\"\n                                elif 'first_name' in user_info:\n                                    username = user_info['first_name']\n                                else:\n                                    # Last resort: try Telegram API\n                                    user_chat = application.bot.get_chat(user_id_key)\n                                    username = f\"@{user_chat.username}\" if user_chat.username else user_chat.first_name or f\"User{user_id_key[-4:]}\"\n                            except:\n                                username = f\"User{user_id_key[-4:]}\"\n                            \n                            response_text += f\"üë§ **{username}** (ID: {user_id_key})\\n\"\n                            response_text += f\"üí∞ Balance: ‚Ç±{balance}\\n\"\n                            response_text += f\"üìä Deposited: ‚Ç±{total_deposited}\\n\"\n                            response_text += f\"üõí Spent: ‚Ç±{total_spent}\\n\\n\"\n\n                elif text.startswith('/admin'):\n                    response_text = f\"Admin Panel\\n\\nAdmin ID: {user_id}\\nStatus: Active\\n\\nCommands:\\n/add ProductName Price Stock\\n/products - View products\\n/addacc capcut - Add accounts to products\\n/receipts - View receipts\\n/users - View all users\\n/stats - Statistics\\n\\nSystem ready!\"\n\n                elif text.isdigit() and not text.startswith('/'):\n                    # Handle custom quantity input from customer \n                    quantity = int(text)\n                    \n                    # Simple approach - assume capcut (product ID 1) for custom quantity\n                    product_id = 1\n                    \n                    try:\n                        # Load product and user data\n                        with open('data/products.json', 'r') as f:\n                            products = json_lib.load(f)\n                        with open('data/users.json', 'r') as f:\n                            users = json_lib.load(f)\n                        \n                        product = next((p for p in products if p['id'] == product_id), None)\n                        user_balance = users.get(user_id, {}).get('balance', 0)\n                        \n                        if not product:\n                            response_text = \"‚ùå Product not found. Use /start to browse products.\"\n                        elif quantity <= 0:\n                            response_text = \"‚ùå Quantity must be greater than 0\"\n                        elif product['stock'] < quantity:\n                            response_text = f\"‚ùå Not enough stock!\\n\\nüì¶ Available: {product['stock']}\\nüî¢ Requested: {quantity}\\n\\nPlease choose a smaller quantity.\"\n                        else:\n                            total_cost = product['price'] * quantity\n                            \n                            if user_balance < total_cost:\n                                response_text = \"No funds.\"\n                            else:\n                                # Process the custom quantity purchase immediately\n                                # Update user balance\n                                if user_id not in users:\n                                    users[user_id] = {\"balance\": 0, \"total_spent\": 0}\n                                users[user_id][\"balance\"] = user_balance - total_cost\n                                users[user_id][\"total_spent\"] = users[user_id].get(\"total_spent\", 0) + total_cost\n                                \n                                # Update product stock\n                                for p in products:\n                                    if p['id'] == product_id:\n                                        p['stock'] -= quantity\n                                        break\n                                \n                                # Save updates\n                                with open('data/users.json', 'w') as f:\n                                    json_lib.dump(users, f, indent=2)\n                                with open('data/products.json', 'w') as f:\n                                    json_lib.dump(products, f, indent=2)\n                                \n                                response_text = f\"\"\"‚úÖ Purchase Successful!\n\nüõçÔ∏è Product: {product['name']}\nüì¶ Quantity: {quantity}x\nüí∞ Total Paid: ‚Ç±{total_cost}\nüí≥ Remaining Balance: ‚Ç±{users[user_id]['balance']}\n\nüìã Your accounts will be sent shortly!\n\nThank you for shopping with us! üéâ\"\"\"\n                                \n                                # Send accounts instantly (reusing existing logic)\n                                try:\n                                    with open('data/product_files.json', 'r') as f:\n                                        product_files = json_lib.load(f)\n                                    \n                                    if str(product_id) in product_files:\n                                        available_files = [f for f in product_files[str(product_id)] if f['status'] == 'available']\n                                        \n                                        if available_files and len(available_files) >= quantity:\n                                            # Send accounts for custom quantity\n                                            for i in range(quantity):\n                                                file_data = available_files[i]\n                                                file_data['status'] = 'sold'\n                                                file_data['sold_to'] = user_id\n                                                file_data['sold_at'] = datetime.now().isoformat()\n                                                \n                                                account_message = f\"\"\"üì¶ Your {product['name']} Account #{i+1}\n\nüîê Login Credentials:\nüìß Email: {file_data['details']['email']}\nüîë Password: {file_data['details']['password']}\nüíé Subscription: {file_data['details'].get('subscription', 'Premium Access')}\n\nüìã Instructions:\n{file_data['details'].get('instructions', 'Login with these credentials')}\n\nüõ°Ô∏è WARRANTY ACTIVATION:\nVouch @tiramisucakekyo within 24 hours to activate warranty.\nDM him with the vouch!\n\n‚ö†Ô∏è Important: Keep these credentials safe!\"\"\"\n                                                \n                                                # Send account details to customer\n                                                account_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                                                account_data = json_lib.dumps({\n                                                    \"chat_id\": user_id,\n                                                    \"text\": account_message\n                                                }).encode('utf-8')\n                                                account_req = urllib.request.Request(account_url, data=account_data, headers={'Content-Type': 'application/json'})\n                                                urllib.request.urlopen(account_req)\n                                            \n                                            # Save updated product files\n                                            with open('data/product_files.json', 'w') as f:\n                                                json_lib.dump(product_files, f, indent=2)\n                                except:\n                                    pass\n                                \n                    except Exception as e:\n                        response_text = f\"‚ùå Error processing order: {str(e)}\"\n\n# REMOVED DUPLICATE /addacc HANDLER - MOVED TO PROPER POSITION\n\n                elif ((':' in text or '|' in text) and '@' in text and not text.startswith('/')):\n                    # Handle account additions in email:password or email|password format\n                    if '|' in text:\n                        parts = text.split('|')\n                    else:\n                        parts = text.split(':')\n                        \n                    if len(parts) >= 2:\n                        email = parts[0].strip()\n                        if '|' in text:\n                            password = '|'.join(parts[1:]).strip()\n                        else:\n                            password = ':'.join(parts[1:]).strip()\n                        \n                        try:\n                            # Load or create product files (default to product ID 1 - capcut)\n                            try:\n                                with open('data/product_files.json', 'r') as f:\n                                    product_files = json_lib.load(f)\n                            except:\n                                product_files = {}\n                            \n                            product_id = \"1\"  # Default to capcut\n                            if product_id not in product_files:\n                                product_files[product_id] = []\n                            \n                            # Check for duplicate email before adding\n                            email_exists = False\n                            existing_product = \"\"\n                            \n                            for pid, accounts in product_files.items():\n                                for account in accounts:\n                                    if account.get('details', {}).get('email', '').lower() == email.lower():\n                                        email_exists = True\n                                        existing_product = f\"Product ID {pid}\"\n                                        break\n                                if email_exists:\n                                    break\n                            \n                            if email_exists:\n                                response_text = f\"\"\"‚ùå **DUPLICATE EMAIL DETECTED!**\n\nüö´ **Email:** {email}\nüì¶ **Already exists in:** {existing_product}\n\nüí° **Tip:** Use a unique email address that hasn't been added before.\"\"\"\n                            else:\n                                # Add new account\n                                new_account = {\n                                    \"id\": len(product_files[product_id]) + 1,\n                                    \"type\": \"account\",\n                                    \"details\": {\n                                        \"email\": email,\n                                        \"password\": password,\n                                        \"subscription\": \"CapCut Pro - 1 Month\",\n                                        \"instructions\": \"Login with these credentials. Do not change password for 24 hours.\"\n                                    },\n                                    \"status\": \"available\",\n                                    \"added_at\": datetime.now().isoformat()\n                                }\n                                \n                                product_files[product_id].append(new_account)\n                            \n                            # Save updated files\n                            with open('data/product_files.json', 'w') as f:\n                                json_lib.dump(product_files, f, indent=2)\n                            \n                            # AUTOMATICALLY UPDATE PRODUCT STOCK TO MATCH ACCOUNT COUNT\n                            available_accounts = [acc for acc in product_files[product_id] if acc['status'] == 'available']\n                            total_available = len(available_accounts)\n                            \n                            # Update capcut product stock\n                            try:\n                                with open('data/products.json', 'r') as f:\n                                    products = json_lib.load(f)\n                                \n                                for product in products:\n                                    if product['id'] == 1:  # capcut\n                                        product['stock'] = total_available\n                                        break\n                                \n                                with open('data/products.json', 'w') as f:\n                                    json_lib.dump(products, f, indent=2)\n                                    \n                            except:\n                                pass\n                            \n                            response_text = f\"\"\"‚úÖ Account Added to CapCut!\n\nüìß Email: {email}\nüîë Password: {password}\nüìä Available Accounts: {total_available}\nüì¶ Product Stock Updated: {total_available}\n\nSend more accounts to automatically increase stock!\"\"\"\n                            \n                        except Exception as e:\n                            response_text = f\"‚ùå Error adding account: {str(e)}\"\n                    else:\n                        response_text = \"‚ùå Invalid format. Use: email@example.com:password123 OR email@example.com|password123\"\n\n                else:\n                    response_text = f\"\"\"üëã **Welcome Back, Admin!**\n\nüîë **Admin Access Confirmed**\nüÜî **Your ID:** {user_id}\n\n**Quick Actions:**\n‚ûï Add Product: `/addproduct`  \nüì¶ View Products: `/products`\nüìä Statistics: `/stats`\nüîß Full Panel: `/admin`\n\n**Add Product Format:**\n`/addproduct Name|Category|Price|Stock|Description|Emoji`\n\n**Example:**\n`/addproduct Netflix Premium|streaming|149|50|1 Month Netflix|üì∫`\n\nReady to manage your store!\"\"\"\n\n            else:\n                # Load users data for all regular user interactions\n                try:\n                    with open('data/users.json', 'r') as f:\n                        users = json_lib.load(f)\n                except:\n                    users = {}\n                \n                # Handle photo messages (receipts) from regular users\n                if 'photo' in message:\n                    # Customer sent a receipt photo\n                    photo = message['photo'][-1]  # Get highest resolution\n                    caption = message.get('caption', '').strip()\n                    \n                    # Save receipt for admin approval\n                    receipt_data = {\n                        \"user_id\": user_id,\n                        \"chat_id\": chat_id,\n                        \"photo_file_id\": photo['file_id'],\n                        \"caption\": caption,\n                        \"timestamp\": datetime.now().isoformat(),\n                        \"status\": \"pending\",\n                        \"username\": message['from'].get('username', 'No username'),\n                        \"first_name\": message['from'].get('first_name', 'Unknown')\n                    }\n                    \n                    # Load existing receipts\n                    receipts = []\n                    try:\n                        with open('data/pending_receipts.json', 'r') as f:\n                            receipts = json_lib.load(f)\n                    except:\n                        receipts = []\n                    \n                    # Add new receipt\n                    receipt_id = len(receipts) + 1\n                    receipt_data[\"receipt_id\"] = receipt_id\n                    receipts.append(receipt_data)\n                    \n                    # Save receipts\n                    with open('data/pending_receipts.json', 'w') as f:\n                        json_lib.dump(receipts, f, indent=2)\n                    \n                    # Notify admin\n                    admin_id = \"7240133914\"  # Your admin ID\n                    admin_message = f\"üì∏ New Receipt #{receipt_id}\\n\\nüë§ User: @{receipt_data['username']} ({receipt_data['first_name']})\\nüí¨ Caption: {caption}\\nüÜî User ID: {user_id}\\n\\nClick buttons below to approve or reject:\"\n                    \n                    # Send photo notification to admin with approve/reject buttons\n                    admin_url = f\"https://api.telegram.org/bot{bot_token}/sendPhoto\"\n                    \n                    # Create approve/reject buttons\n                    admin_keyboard = {\n                        \"inline_keyboard\": [\n                            [\n                                {\"text\": \"‚úÖ Approve\", \"callback_data\": f\"approve_receipt_{receipt_id}\"},\n                                {\"text\": \"‚ùå Reject\", \"callback_data\": f\"reject_receipt_{receipt_id}\"}\n                            ],\n                            [\n                                {\"text\": \"üí¨ Message User\", \"callback_data\": f\"msg_user_{user_id}\"}\n                            ]\n                        ]\n                    }\n                    \n                    admin_data = json_lib.dumps({\n                        \"chat_id\": admin_id,\n                        \"photo\": photo['file_id'],\n                        \"caption\": admin_message,\n                        \"reply_markup\": admin_keyboard\n                    }).encode('utf-8')\n                    \n                    admin_req = urllib.request.Request(admin_url, data=admin_data, headers={'Content-Type': 'application/json'})\n                    try:\n                        urllib.request.urlopen(admin_req)\n                        logger.info(f\"Sent receipt photo with buttons to admin\")\n                        \n                    except Exception as e:\n                        logger.error(f\"Failed to notify admin: {e}\")\n                    \n                    # Send confirmation message to customer\n                    try:\n                        confirmation_url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                        confirmation_data = json_lib.dumps({\n                            'chat_id': user_id,\n                            'text': \"‚úÖ Receipt received! Your funds will be added within 5 minutes. If not, contact @tiramisucakekyo\",\n                            'parse_mode': 'HTML'\n                        }).encode('utf-8')\n                        \n                        confirmation_req = urllib.request.Request(confirmation_url, data=confirmation_data, headers={'Content-Type': 'application/json'})\n                        urllib.request.urlopen(confirmation_req)\n                        logger.info(f\"Sent receipt confirmation to user {user_id}\")\n                        \n                    except Exception as e:\n                        logger.error(f\"Failed to send confirmation: {e}\")\n                    return jsonify({'status': 'ok'})\n\n                # Professional Store Bot Interface with Inline Keyboards\n                # Get user data\n                user_balance = 0.0\n                product_count = 0\n                try:\n                    with open('data/products.json', 'r') as f:\n                        products = json_lib.load(f)\n                        product_count = len(products)\n                except:\n                    product_count = 0\n\n                # Handle custom keyboard button presses (from primostorebot-style interface)\n                if text == \"üí∞ Deposit Balance\":\n                    response_text = \"üí≥ Deposit Funds\\n\\nüìã Steps to Deposit:\\n1. Send to GCash: 09911127180\\n2. Screenshot your receipt\\n3. Send receipt photo here\\n4. Wait for admin approval\\n5. Get balance credit instantly after approval\\n\\n‚ö†Ô∏è Important: Send receipt as photo to this bot\\nüìû Contact: 09911127180 mb\"\n                    \n                elif text == \"üõí Browse Products\":\n                    logger.info(f\"TEXT HANDLER: Browse Products clicked by user {user_id}\")\n                    # SHOW PRODUCT CATEGORIES\n                    response_text = \"üè™ Product Categories\\n\\nChoose a category to browse:\"\n                    inline_keyboard = {\"inline_keyboard\": [\n                        [{\"text\": \"üé¨ Video\", \"callback_data\": \"category_video\"}],\n                        [{\"text\": \"üéµ Music\", \"callback_data\": \"category_music\"}], \n                        [{\"text\": \"üì∫ Streaming\", \"callback_data\": \"category_streaming\"}],\n                        [{\"text\": \"üìö Education\", \"callback_data\": \"category_education\"}],\n                        [{\"text\": \"üé® Design\", \"callback_data\": \"category_design\"}],\n                        [{\"text\": \"üì∏ Photo Editing\", \"callback_data\": \"category_photo\"}],\n                        [{\"text\": \"ü§ñ AI Tools\", \"callback_data\": \"category_ai\"}],\n                        [{\"text\": \"üõ°Ô∏è VPN & Security\", \"callback_data\": \"category_vpn\"}],\n                        [{\"text\": \"üî• Method\", \"callback_data\": \"category_method\"}],\n                        [{\"text\": \"ü§ñ Automated Plugging\", \"callback_data\": \"category_plugging\"}],\n                        [{\"text\": \"üîô Back to Main Menu\", \"callback_data\": \"main_menu\"}]\n                    ]}\n                        \n                elif text == \"üëë Customer Service\":\n                    response_text = \"üÜò Customer Support\\n\\nüìû Contact Information:\\nüí¨ Telegram/WhatsApp: 09911127180\\nüìß For Receipts: Send to 09911127180 mb\\nüë§ Support: @tiramisucakekyo\\n\\n‚ö° We Help With:\\n‚Ä¢ Payment issues\\n‚Ä¢ Product questions\\n‚Ä¢ Account problems\\n‚Ä¢ Technical support\\n‚Ä¢ Order problems\\n\\nüïê Available: 24/7\\n‚ö° Response: Usually within 5 minutes\\n\\nReady to help! Contact us now! üí™\"\n                    \n                elif text == \"‚ùì How to order\":\n                    response_text = \"‚ùì How to Order\\n\\nüìã Simple Steps:\\n1Ô∏è‚É£ Browse Products (üõí button)\\n2Ô∏è‚É£ Select what you want\\n3Ô∏è‚É£ Add to cart\\n4Ô∏è‚É£ Make sure you have balance\\n5Ô∏è‚É£ Complete purchase\\n6Ô∏è‚É£ Get your account instantly!\\n\\nüí∞ Need Balance?\\n‚Ä¢ Use üí∞ Deposit Balance button\\n‚Ä¢ Send GCash receipt to 09911127180\\n‚Ä¢ Get approved and start shopping!\\n\\nReady to order! üõçÔ∏è\"\n                    \n                # Handle user commands (available to all users)\n                elif text.startswith('/leaderboard'):\n                    # Show top users by spending (USER VERSION - no balance shown)\n                    try:\n                        with open('data/users.json', 'r') as f:\n                            users_data = json_lib.load(f)\n                    except:\n                        users_data = {}\n                    \n                    if not users_data:\n                        response_text = \"üìä **Leaderboard**\\n\\nNo users found yet!\"\n                    else:\n                        # Sort users by total spent (descending)\n                        sorted_users = sorted(users_data.items(), key=lambda x: x[1].get('total_spent', 0), reverse=True)\n                        \n                        response_text = \"üèÜ Top Spenders Leaderboard\\n\\n\"\n                        \n                        for i, (user_id_key, user_info) in enumerate(sorted_users[:10], 1):\n                            total_spent = user_info.get('total_spent', 0)\n                            \n                            # Get user info - try multiple sources\n                            username = \"Unknown User\"\n                            try:\n                                # First try to get from stored user data\n                                if 'username' in user_info:\n                                    username = f\"@{user_info['username']}\"\n                                elif 'first_name' in user_info:\n                                    username = user_info['first_name']\n                                else:\n                                    # Last resort: try Telegram API\n                                    user_chat = application.bot.get_chat(user_id_key)\n                                    username = f\"@{user_chat.username}\" if user_chat.username else user_chat.first_name or f\"User{user_id_key[-4:]}\"\n                            except:\n                                username = f\"User{user_id_key[-4:]}\"\n                            \n                            # Add medal emojis for top 3\n                            if i == 1:\n                                medal = \"ü•á\"\n                            elif i == 2:\n                                medal = \"ü•à\"\n                            elif i == 3:\n                                medal = \"ü•â\"\n                            else:\n                                medal = f\"{i}.\"\n                            \n                            response_text += f\"{medal} **{username}**\\n\"\n                            response_text += f\"üí∏ Total Spent: ‚Ç±{total_spent}\\n\\n\"\n                        \n                        if len(sorted_users) > 10:\n                            response_text += f\"... and {len(sorted_users) - 10} more users\"\n\n                elif text.startswith('/stock'):\n                    # Show current stock levels (USER VERSION - simplified)\n                    try:\n                        with open('data/products.json', 'r') as f:\n                            products = json_lib.load(f)\n                    except:\n                        products = []\n                    \n                    if not products:\n                        response_text = \"üì¶ Stock Status\\n\\nNo products found!\"\n                    else:\n                        response_text = \"üì¶ Available Products:\\n\\n\"\n                        \n                        # Group products by status to keep message short\n                        in_stock = []\n                        low_stock = []\n                        out_of_stock = []\n                        \n                        for product in products:\n                            name = product.get('name', 'Unknown')\n                            stock = product.get('stock', 0)\n                            price = product.get('price', 0)\n                            \n                            item = f\"{name} (‚Ç±{price}) - {stock} left\"\n                            \n                            if stock == 0:\n                                out_of_stock.append(item)\n                            elif stock <= 5:\n                                low_stock.append(item)\n                            else:\n                                in_stock.append(item)\n                        \n                        # Build compact response\n                        if in_stock:\n                            response_text += \"‚úÖ IN STOCK:\\n\"\n                            response_text += \"\\n\".join([f\"‚Ä¢ {item}\" for item in in_stock[:8]]) + \"\\n\\n\"  # Limit to 8 items\n                        \n                        if low_stock:\n                            response_text += \"‚ö†Ô∏è LOW STOCK:\\n\"\n                            response_text += \"\\n\".join([f\"‚Ä¢ {item}\" for item in low_stock[:5]]) + \"\\n\\n\"  # Limit to 5 items\n                        \n                        if out_of_stock:\n                            response_text += \"‚ùå OUT OF STOCK:\\n\"\n                            response_text += \"\\n\".join([f\"‚Ä¢ {item}\" for item in out_of_stock[:5]]) + \"\\n\\n\"  # Limit to 5 items\n\n                # Handle /start command with inline keyboard ONLY if no photo was sent\n                elif (text == '/start' or text == '/menu' or (not text.startswith('/') and not message.get('photo'))):\n                    # Don't send welcome if photo was already processed\n                    if 'photo' in message:\n                        return jsonify({'status': 'ok'})\n                    \n                    # Users data already loaded above\n                        \n                    # EXACT primostorebot interface\n                    current_time = datetime.now().strftime(\"%d/%m/%Y - %I:%M:%S %p\")\n                    first_name = message['from'].get('first_name', 'User')\n                    username = first_name if first_name else \"User\"\n                    \n                    # Calculate bot statistics \n                    total_users = len(users) if users else 1\n                    \n                    # Count total accounts sold across all products\n                    products_sold = 0\n                    try:\n                        with open('data/product_files.json', 'r') as f:\n                            product_files = json_lib.load(f)\n                        for product_id, accounts in product_files.items():\n                            products_sold += len([acc for acc in accounts if acc.get('status') == 'sold'])\n                    except:\n                        products_sold = 0\n                    \n                    # Load actual user spending data AND BALANCE\n                    try:\n                        with open('data/users.json', 'r') as f:\n                            users = json_lib.load(f)\n                        user_data = users.get(str(user_id), {})\n                        user_balance = user_data.get('balance', 0)  # LOAD FRESH BALANCE\n                        total_spent = user_data.get('total_spent', 0)\n                    except:\n                        user_balance = 0\n                        total_spent = 0\n                    \n                    response_text = f\"\"\"üëã ‚Äî Hello @{username}\n{current_time}\n\nUser Details :\n‚îî ID : {user_id}\n‚îî Name : {username}\n‚îî Balance : ‚Ç±{user_balance}\n‚îî Total Spent : ‚Ç±{total_spent:.2f}\n\nBOT Statistics :\n‚îî Products Sold : {products_sold} Accounts\n‚îî Total Users : {total_users}\n\nSHORTCUT :\n/start - Show main menu\n/stock - Check available stocks\n/leaderboard - View top users\"\"\"\n                    \n                    # EXACT primostorebot keyboard layout with custom buttons  \n                    inline_keyboard = {\n                        \"inline_keyboard\": [\n                            [\n                                {\"text\": \"APPS STREAMING\", \"callback_data\": \"category_streaming\"},\n                                {\"text\": \"EDITING PREMI..\", \"callback_data\": \"category_video\"}\n                            ],\n                            [\n                                {\"text\": \"Other Categories\", \"callback_data\": \"browse_products\"}\n                            ]\n                        ]\n                    }\n                    \n                    # Custom keyboard (the bottom buttons like primostorebot)\n                    keyboard = {\n                        \"keyboard\": [\n                            [\n                                {\"text\": \"üí∞ Deposit Balance\"},\n                                {\"text\": \"üõí Browse Products\"}\n                            ],\n                            [\n                                {\"text\": \"üëë Customer Service\"}\n                            ],\n                            [\n                                {\"text\": \"‚ùì How to order\"}\n                            ]\n                        ],\n                        \"resize_keyboard\": True,\n                        \"one_time_keyboard\": False\n                    }\n                    \n                    # Send message with BOTH inline and custom keyboard like primostorebot\n                    url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n                    data = json_lib.dumps({\n                        \"chat_id\": chat_id,\n                        \"text\": response_text,\n                        \"reply_markup\": keyboard  # Use custom keyboard for bottom buttons\n                    }).encode('utf-8')\n                    \n                    req = urllib.request.Request(url, data=data, headers={'Content-Type': 'application/json'})\n                    try:\n                        with urllib.request.urlopen(req) as response:\n                            logger.info(f\"Sent inline menu to chat {chat_id}\")\n                        return jsonify({'status': 'ok'})\n                    except Exception as e:\n                        logger.error(f\"Failed to send inline menu: {e}\")\n                \n                # Handle old text commands for compatibility\n                elif text == '/products':\n                    response_text = \"\"\"üè™ **Product Catalog**\n\nUse the main menu button for better experience!\nType /start to see the interactive menu.\n\nüì± **Quick Commands:**\n‚Ä¢ /start - Interactive menu\n‚Ä¢ /balance - Check balance\n‚Ä¢ /deposit - Add funds\"\"\"\n                \n                elif text == '/help':\n                    response_text = f\"\"\"üí° Customer Help\n\nüëã Welcome to Premium Store!\n\nüõçÔ∏è Shopping Commands:\n/start - Main menu with buttons\n/products - Browse products\n/balance - Check your balance\n/deposit - Add funds to account\n\nüí≥ Payment Methods:\nüì± GCash: 09911127180\nüí∞ Send receipt photo for approval\n\nüìû Support:\nContact: 09911127180 mb\n\nüí° How to Shop:\n1. Add funds via GCash\n2. Send receipt photo (silent approval)\n3. Browse products with /start\n4. Buy with quantity selection!\"\"\"\n\n                elif text == '/balance':\n                    response_text = f\"\"\"üí∞ **Account Balance**\n\n**Current Balance:** ‚Ç±{user_balance:.2f}\n**Status:** Active\n\nüì± **Use /start for interactive menu**\nüí≥ **Use /deposit to add funds**\"\"\"\n                \n                elif text == '/deposit':\n                    response_text = \"\"\"üí≥ **Deposit Funds**\n\nüì± **For better experience, use /start**\n\n**Payment Methods:**\nüü¢ **GCash:** 09911127180 MB\nüîµ **PayMaya:** 09913796615 MD\n\n**Steps:**\n1. Send payment\n2. Screenshot receipt\n3. Send receipt photo to bot\n4. Wait for confirmation\n\n‚ö†Ô∏è No receipt = No processing\"\"\"\n\n                elif text == '/stock':\n                    # Show current stock levels\n                    try:\n                        with open('data/products.json', 'r') as f:\n                            products = json_lib.load(f)\n                        \n                        response_text = \"üì¶ Current Stock Levels\\n\\n\"\n                        \n                        in_stock = []\n                        low_stock = []\n                        out_of_stock = []\n                        \n                        for product in products:\n                            stock = product.get('stock', 0)\n                            name = product['name'].title()\n                            price = product.get('price', 0)\n                            \n                            if stock == 0:\n                                out_of_stock.append(f\"‚ùå {name} - ‚Ç±{price} (Out)\")\n                            elif stock <= 5:\n                                low_stock.append(f\"‚ö†Ô∏è {name} - ‚Ç±{price} ({stock} left)\")\n                            else:\n                                in_stock.append(f\"‚úÖ {name} - ‚Ç±{price} ({stock} available)\")\n                        \n                        if in_stock:\n                            response_text += \"‚úÖ IN STOCK:\\n\" + \"\\n\".join(in_stock[:8]) + \"\\n\\n\"\n                        if low_stock:\n                            response_text += \"‚ö†Ô∏è LOW STOCK:\\n\" + \"\\n\".join(low_stock[:5]) + \"\\n\\n\"\n                        if out_of_stock:\n                            response_text += \"‚ùå OUT OF STOCK:\\n\" + \"\\n\".join(out_of_stock[:5]) + \"\\n\\n\"\n                        \n                        response_text += \"üì± Use /start to shop!\"\n                        \n                    except Exception as e:\n                        response_text = \"‚ùå Unable to check stock right now. Try again later!\"\n\n\n                elif text == '/leaderboard':\n                    # Show top users by total spent\n                    try:\n                        with open('data/users.json', 'r') as f:\n                            users = json_lib.load(f)\n                        \n                        # Sort users by total_spent\n                        user_list = []\n                        for uid, udata in users.items():\n                            total_spent = udata.get('total_spent', 0)\n                            first_name = udata.get('first_name', f\"User{uid[-4:]}\")\n                            if total_spent > 0:  # Only show users who have spent money\n                                user_list.append((first_name, total_spent, uid))\n                        \n                        user_list.sort(key=lambda x: x[1], reverse=True)\n                        \n                        response_text = \"üèÜ Top Spenders Leaderboard\\n\\n\"\n                        \n                        if user_list:\n                            for i, (name, spent, uid) in enumerate(user_list[:10], 1):\n                                if i == 1:\n                                    emoji = \"ü•á\"\n                                elif i == 2:\n                                    emoji = \"ü•à\"\n                                elif i == 3:\n                                    emoji = \"ü•â\"\n                                else:\n                                    emoji = f\"{i}.\"\n                                \n                                # Clean format without markdown\n                                if uid == str(user_id):\n                                    response_text += f\"{emoji} {name}\\nüí∏ Total Spent: ‚Ç±{spent}\\n\\n\"\n                                else:\n                                    response_text += f\"{emoji} {name}\\nüí∏ Total Spent: ‚Ç±{spent}\\n\\n\"\n                        else:\n                            response_text += \"No customers yet!\\n\\n\"\n                        \n                        response_text += \"\\nüí∞ Start shopping to join the leaderboard!\\nüì± Use /start to browse products!\"\n                        \n                    except Exception as e:\n                        response_text = \"‚ùå Leaderboard temporarily unavailable!\"\n                \n                else:\n                    # Redirect to main menu\n                    response_text = \"\"\"üëã Welcome to Premium Store!\n\nüì± Use /start for interactive menu\n\nQuick Commands:\n‚Ä¢ /start - Main menu\n‚Ä¢ /products - Browse\n‚Ä¢ /balance - Check funds\n‚Ä¢ /deposit - Add money\n\nReady to shop! üõçÔ∏è\"\"\"\n\n            # Send message using urllib\n            url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n            \n            # For admin commands, account adding, and browse products, don't use markdown to avoid 400 errors\n            if (is_admin and (text.startswith('/admin') or text.startswith('/addacc') or '|' in text or text.startswith('/add'))) or text == \"üõí Browse Products\":\n                # Check if we have inline keyboard to send (for simple messages)\n                if 'inline_keyboard' in locals() and inline_keyboard:\n                    data = json_lib.dumps({\n                        \"chat_id\": chat_id, \n                        \"text\": response_text,\n                        \"reply_markup\": inline_keyboard\n                    }).encode('utf-8')\n                else:\n                    data = json_lib.dumps({\n                        \"chat_id\": chat_id, \n                        \"text\": response_text\n                    }).encode('utf-8')\n            else:\n                # Check if we have inline keyboard to send (for custom button responses)\n                if 'inline_keyboard' in locals() and inline_keyboard:\n                    data = json_lib.dumps({\n                        \"chat_id\": chat_id, \n                        \"text\": response_text,\n                        \"parse_mode\": \"Markdown\",\n                        \"reply_markup\": inline_keyboard\n                    }).encode('utf-8')\n                else:\n                    data = json_lib.dumps({\n                        \"chat_id\": chat_id, \n                        \"text\": response_text\n                    }).encode('utf-8')\n            \n            req = urllib.request.Request(url, data=data, headers={'Content-Type': 'application/json'})\n            try:\n                logger.info(f\"SENDING TO TELEGRAM: {data.decode('utf-8')}\")\n                with urllib.request.urlopen(req) as response:\n                    logger.info(f\"Sent {'admin' if is_admin else 'user'} message to chat {chat_id}\")\n            except Exception as e:\n                logger.error(f\"Failed to send message: {e}\")\n                logger.error(f\"DATA THAT FAILED: {data.decode('utf-8')}\")\n        \n        return jsonify({'status': 'ok'})\n    except Exception as e:\n        logger.error(f\"Error processing webhook: {e}\")\n        return jsonify({'error': str(e)}), 500\n\n@app.route('/health')\ndef health():\n    \"\"\"Health check endpoint\"\"\"\n    return jsonify({\n        'status': 'healthy' if premium_bot else 'error',\n        'bot': 'Premium Store Bot',\n        'version': '2.0',\n        'initialized': premium_bot is not None\n    })\n\n@app.route('/test-browse', methods=['POST'])\ndef test_browse():\n    \"\"\"Simple test endpoint to debug Browse Products\"\"\"\n    logger.info(\"=== TEST BROWSE ENDPOINT HIT ===\")\n    \n    # Get bot token\n    bot_token = os.environ.get('BOT_TOKEN')\n    chat_id = 123456789  # Test chat ID\n    \n    # Simple message\n    import urllib.request\n    import json as json_lib\n    \n    url = f\"https://api.telegram.org/bot{bot_token}/sendMessage\"\n    data = json_lib.dumps({\n        \"chat_id\": chat_id, \n        \"text\": \"SIMPLE TEST MESSAGE\"\n    }).encode('utf-8')\n    \n    req = urllib.request.Request(url, data=data, headers={'Content-Type': 'application/json'})\n    try:\n        logger.info(f\"SENDING SIMPLE TEST: {data.decode('utf-8')}\")\n        with urllib.request.urlopen(req) as response:\n            result = response.read().decode('utf-8')\n            logger.info(f\"TELEGRAM SUCCESS: {result}\")\n            return jsonify({'status': 'sent', 'telegram_response': result})\n    except Exception as e:\n        logger.error(f\"SIMPLE TEST FAILED: {e}\")\n        return jsonify({'status': 'failed', 'error': str(e)})\n\n# Set webhook on startup\nif premium_bot:\n    try:\n        webhook_domain = os.environ.get('REPLIT_DEV_DOMAIN')\n        if webhook_domain:\n            webhook_url = f\"https://{{webhook_domain}}/webhook\"\n            # Note: Webhook will be set via bot commands or admin panel\n            logger.info(f\"Webhook URL would be: {{webhook_url}}\")\n    except Exception as e:\n        logger.error(f\"Webhook setup error: {{e}}\")\n\nif __name__ == '__main__':\n    logger.info(\"üöÄ Starting Premium Store Bot Flask App\")\n    app.run(host='0.0.0.0', port=5000, debug=False)","size_bytes":167221},"migrate_to_database.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nMigration script to move data from JSON files to PostgreSQL database\n\"\"\"\nimport os\nfrom data_manager import DataManager as JSONDataManager\nfrom advanced_data_manager import AdvancedDataManager\n\ndef main():\n    print(\"üöÄ Starting migration from JSON to PostgreSQL...\")\n    \n    try:\n        # Initialize both data managers\n        json_manager = JSONDataManager()\n        db_manager = AdvancedDataManager()\n        \n        print(\"‚úÖ Database connection established\")\n        \n        # Migrate data\n        print(\"üì¶ Migrating data...\")\n        db_manager.migrate_from_json(json_manager)\n        \n        print(\"üéâ Migration completed successfully!\")\n        print(\"\\nüìä Summary:\")\n        \n        # Show migration results\n        products = db_manager.get_products()\n        orders = db_manager.get_orders()\n        users = db_manager.get_users()\n        \n        print(f\"   Products migrated: {len(products)}\")\n        print(f\"   Orders migrated: {len(orders)}\")\n        print(f\"   Users migrated: {len(users)}\")\n        \n        print(\"\\nüéØ Your store is now powered by PostgreSQL with advanced features!\")\n        \n    except Exception as e:\n        print(f\"‚ùå Migration failed: {e}\")\n        raise\n\nif __name__ == '__main__':\n    main()","size_bytes":1281},"models.py":{"content":"from datetime import datetime\nimport json\n\nclass Product:\n    def __init__(self, id, name, description, price, category, image_url=\"\", stock=0):\n        self.id = id\n        self.name = name\n        self.description = description\n        self.price = price\n        self.category = category\n        self.image_url = image_url\n        self.stock = stock\n        self.created_at = datetime.now().isoformat()\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'name': self.name,\n            'description': self.description,\n            'price': self.price,\n            'category': self.category,\n            'image_url': self.image_url,\n            'stock': self.stock,\n            'created_at': self.created_at\n        }\n    \n    @classmethod\n    def from_dict(cls, data):\n        product = cls(\n            id=data['id'],\n            name=data['name'],\n            description=data['description'],\n            price=data['price'],\n            category=data['category'],\n            image_url=data.get('image_url', ''),\n            stock=data.get('stock', 0)\n        )\n        product.created_at = data.get('created_at', datetime.now().isoformat())\n        return product\n\nclass Order:\n    def __init__(self, id, user_id, user_name, username, items, shipping_info, status=\"pending\"):\n        self.id = id\n        self.user_id = user_id\n        self.user_name = user_name\n        self.username = username\n        self.items = items\n        self.shipping_info = shipping_info\n        self.status = status\n        self.created_at = datetime.now().isoformat()\n    \n    def to_dict(self):\n        return {\n            'id': self.id,\n            'user_id': self.user_id,\n            'user_name': self.user_name,\n            'username': self.username,\n            'items': self.items,\n            'shipping_info': self.shipping_info,\n            'status': self.status,\n            'created_at': self.created_at\n        }\n    \n    @classmethod\n    def from_dict(cls, data):\n        order = cls(\n            id=data['id'],\n            user_id=data['user_id'],\n            user_name=data['user_name'],\n            username=data.get('username', ''),\n            items=data['items'],\n            shipping_info=data['shipping_info'],\n            status=data.get('status', 'pending')\n        )\n        order.created_at = data.get('created_at', datetime.now().isoformat())\n        return order\n\nclass User:\n    def __init__(self, user_id, first_name, username=\"\", last_name=\"\"):\n        self.user_id = user_id\n        self.first_name = first_name\n        self.username = username\n        self.last_name = last_name\n        self.created_at = datetime.now().isoformat()\n    \n    def to_dict(self):\n        return {\n            'user_id': self.user_id,\n            'first_name': self.first_name,\n            'username': self.username,\n            'last_name': self.last_name,\n            'created_at': self.created_at\n        }\n    \n    @classmethod\n    def from_dict(cls, data):\n        user = cls(\n            user_id=data['user_id'],\n            first_name=data['first_name'],\n            username=data.get('username', ''),\n            last_name=data.get('last_name', '')\n        )\n        user.created_at = data.get('created_at', datetime.now().isoformat())\n        return user\n","size_bytes":3294},"payment_commands.py":{"content":"\"\"\"\nPayment-related Telegram bot commands and handlers\n\"\"\"\nimport re\nfrom datetime import datetime\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler, MessageHandler, filters, CallbackQueryHandler\nfrom telegram.constants import ParseMode\nfrom payment_system import PaymentSystem, PaymentNotifications, PaymentValidation\nfrom advanced_data_manager import AdvancedDataManager\n\n# Conversation states\nPAYMENT_METHOD, PAYMENT_REFERENCE, PAYMENT_PROOF, PAYMENT_CONFIRM = range(4)\n\nclass PaymentCommands:\n    def __init__(self, bot_token):\n        self.bot_token = bot_token\n        self.payment_system = PaymentSystem()\n        self.data_manager = AdvancedDataManager()\n        self.payment_notifications = PaymentNotifications(None)  # Initialize with broadcast system if available\n    \n    async def show_payment_methods(self, update: Update, context: ContextTypes.DEFAULT_TYPE, order_id: int, total_amount: float):\n        \"\"\"Show available payment methods for an order\"\"\"\n        payment_methods = self.payment_system.get_available_payment_methods(total_amount)\n        \n        if not payment_methods:\n            await update.callback_query.edit_message_text(\n                \"‚ùå **No payment methods available**\\n\\n\"\n                \"Please contact support for assistance.\"\n            )\n            return\n        \n        # Store order info in context\n        context.user_data['payment_order_id'] = order_id\n        context.user_data['payment_amount'] = total_amount\n        \n        message = f\"\"\"\nüí≥ **Choose Payment Method**\n\n**Order Total:** ‚Ç±{total_amount:.2f}\n\nSelect how you'd like to pay:\n        \"\"\"\n        \n        keyboard = []\n        for method in payment_methods:\n            # Add fee info if applicable\n            fee_text = f\" (+‚Ç±{method['fee']:.0f} fee)\" if method['fee'] > 0 else \"\"\n            button_text = f\"{method['name']}{fee_text}\"\n            \n            keyboard.append([InlineKeyboardButton(\n                button_text,\n                callback_data=f\"payment_method_{method['id']}\"\n            )])\n        \n        keyboard.append([InlineKeyboardButton(\"‚ùå Cancel Payment\", callback_data=\"cancel_payment\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        if update.callback_query:\n            await update.callback_query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        return PAYMENT_METHOD\n    \n    async def handle_payment_method_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle payment method selection\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        if query.data == \"cancel_payment\":\n            await query.edit_message_text(\"‚ùå Payment cancelled.\")\n            context.user_data.clear()\n            return ConversationHandler.END\n        \n        # Extract payment method\n        method_id = query.data.replace(\"payment_method_\", \"\")\n        context.user_data['payment_method'] = method_id\n        \n        # Get method details\n        methods = self.payment_system.get_available_payment_methods()\n        method_info = next((m for m in methods if m['id'] == method_id), None)\n        \n        if not method_info:\n            await query.edit_message_text(\"‚ùå Invalid payment method selected.\")\n            return ConversationHandler.END\n        \n        # Calculate final amount with fees\n        base_amount = context.user_data['payment_amount']\n        fee, final_amount = self.payment_system.calculate_payment_fees(base_amount, method_id)\n        \n        context.user_data['payment_fee'] = fee\n        context.user_data['payment_final_amount'] = final_amount\n        \n        # Show payment instructions\n        instructions = self.payment_system.get_payment_instructions(method_id, final_amount)\n        \n        # Handle Cash on Delivery differently\n        if method_id == 'cod':\n            return await self.process_cod_payment(query, context)\n        \n        # For manual payment methods, get reference number\n        message = f\"\"\"\n{instructions}\n\n**Step 1: Reference Number**\nAfter making the payment, please enter your transaction reference number:\n        \"\"\"\n        \n        keyboard = [[InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"cancel_payment\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return PAYMENT_REFERENCE\n    \n    async def process_cod_payment(self, query, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Process Cash on Delivery payment\"\"\"\n        final_amount = context.user_data['payment_final_amount']\n        \n        message = f\"\"\"\nüíµ **Cash on Delivery Selected**\n\n**Total Amount:** ‚Ç±{final_amount:.2f}\n*(Includes ‚Ç±{context.user_data['payment_fee']:.2f} COD fee)*\n\n‚úÖ **What happens next:**\n1. Your order will be prepared for shipping\n2. Our courier will contact you for delivery\n3. Pay the exact amount when you receive your order\n4. Keep your receipt for warranty purposes\n\nReady to confirm your COD order?\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚úÖ Confirm COD Order\", callback_data=\"confirm_cod_payment\")],\n            [InlineKeyboardButton(\"üîô Choose Different Method\", callback_data=\"back_to_payment_methods\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"cancel_payment\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return PAYMENT_CONFIRM\n    \n    async def get_payment_reference(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get payment reference number\"\"\"\n        reference = update.message.text.strip()\n        payment_method = context.user_data['payment_method']\n        \n        # Validate reference number\n        if not self.payment_system.validate_reference_number(reference, payment_method):\n            await update.message.reply_text(\n                f\"‚ùå Invalid reference number format for {payment_method.title()}.\\n\"\n                \"Please enter a valid reference number:\"\n            )\n            return PAYMENT_REFERENCE\n        \n        context.user_data['payment_reference'] = reference\n        \n        # Check if payment method requires proof\n        payment_methods = self.payment_system.payment_methods\n        method_info = payment_methods.get(payment_method, {})\n        \n        if method_info.get('requires_proof', True):\n            message = \"\"\"\nüì∏ **Step 2: Payment Proof (Optional but Recommended)**\n\nTo speed up verification, you can upload a screenshot or photo of your payment receipt.\n\n**Options:**\n‚Ä¢ Upload an image of your receipt\n‚Ä¢ Type \"skip\" to continue without proof\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"‚è≠Ô∏è Skip Upload\", callback_data=\"skip_proof\")],\n                [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"cancel_payment\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await update.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            return PAYMENT_PROOF\n        else:\n            # Skip proof upload\n            context.user_data['payment_proof'] = \"\"\n            return await self.show_payment_confirmation(update, context)\n    \n    async def get_payment_proof(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get payment proof image\"\"\"\n        if update.message:\n            if update.message.photo:\n                # Get the largest photo\n                photo = update.message.photo[-1]\n                context.user_data['payment_proof'] = photo.file_id\n            elif update.message.text and update.message.text.lower() == 'skip':\n                context.user_data['payment_proof'] = \"\"\n            else:\n                await update.message.reply_text(\n                    \"‚ùå Please upload an image or type 'skip' to continue without proof.\"\n                )\n                return PAYMENT_PROOF\n        elif update.callback_query and update.callback_query.data == \"skip_proof\":\n            await update.callback_query.answer()\n            context.user_data['payment_proof'] = \"\"\n        \n        return await self.show_payment_confirmation(update, context)\n    \n    async def show_payment_confirmation(self, update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show payment confirmation summary\"\"\"\n        payment_data = context.user_data\n        payment_method = payment_data['payment_method']\n        \n        # Get method name\n        methods = self.payment_system.get_available_payment_methods()\n        method_info = next((m for m in methods if m['id'] == payment_method), None)\n        method_name = method_info['name'] if method_info else payment_method.title()\n        \n        message = f\"\"\"\nüìã **Payment Confirmation**\n\n**Order ID:** #{payment_data['payment_order_id']}\n**Payment Method:** {method_name}\n**Amount:** ‚Ç±{payment_data['payment_amount']:.2f}\n**Fee:** ‚Ç±{payment_data.get('payment_fee', 0):.2f}\n**Total:** ‚Ç±{payment_data['payment_final_amount']:.2f}\n**Reference:** {payment_data.get('payment_reference', 'N/A')}\n**Proof:** {'Uploaded' if payment_data.get('payment_proof') else 'Not provided'}\n\n‚úÖ **Ready to submit your payment for verification?**\n\nOnce submitted, our team will verify your payment within 24 hours.\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚úÖ Submit Payment\", callback_data=\"submit_payment\")],\n            [InlineKeyboardButton(\"‚úèÔ∏è Edit Details\", callback_data=\"edit_payment\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"cancel_payment\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        if update.callback_query:\n            await update.callback_query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        return PAYMENT_CONFIRM\n    \n    async def submit_payment(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Submit payment for processing\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        payment_data = context.user_data\n        user_telegram_id = str(update.effective_user.id)\n        \n        # Process the payment\n        result = self.payment_system.process_manual_payment(\n            order_id=payment_data['payment_order_id'],\n            user_telegram_id=user_telegram_id,\n            amount=payment_data['payment_final_amount'],\n            payment_method=payment_data['payment_method'],\n            reference_number=payment_data.get('payment_reference', ''),\n            proof_image=payment_data.get('payment_proof', ''),\n            notes=f\"Submitted via Telegram bot by user {update.effective_user.first_name}\"\n        )\n        \n        if result['success']:\n            payment = result['payment']\n            \n            success_message = f\"\"\"\nüéâ **Payment Submitted Successfully!**\n\n**Transaction ID:** {payment['transaction_id']}\n**Status:** Under Review ‚è≥\n\nüìß **What's Next:**\n‚Ä¢ Our team will verify your payment within 24 hours\n‚Ä¢ You'll receive a notification once verified\n‚Ä¢ Your order will then be processed and shipped\n\nüìû **Need Help?**\nContact our support team if you have any questions.\n\nThank you for your purchase! üõçÔ∏è\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üì¶ View Order\", callback_data=f\"view_order_{payment_data['payment_order_id']}\")],\n                [InlineKeyboardButton(\"üí≥ Payment History\", callback_data=\"payment_history\")],\n                [InlineKeyboardButton(\"üè™ Continue Shopping\", callback_data=\"catalog\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(success_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            \n            # Send notification to user\n            await self.payment_notifications.notify_payment_received(user_telegram_id, payment)\n            \n        else:\n            await query.edit_message_text(\n                f\"‚ùå **Payment Submission Failed**\\n\\n{result['message']}\\n\\n\"\n                \"Please try again or contact support.\"\n            )\n        \n        # Clear user data\n        context.user_data.clear()\n        return ConversationHandler.END\n    \n    async def confirm_cod_payment(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Confirm Cash on Delivery payment\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        payment_data = context.user_data\n        user_telegram_id = str(update.effective_user.id)\n        \n        # Create COD payment record\n        result = self.payment_system.create_payment(\n            order_id=payment_data['payment_order_id'],\n            user_telegram_id=user_telegram_id,\n            amount=payment_data['payment_final_amount'],\n            payment_method='cod',\n            notes=\"Cash on Delivery order\"\n        )\n        \n        if result['success']:\n            payment = result['payment']\n            \n            success_message = f\"\"\"\n‚úÖ **COD Order Confirmed!**\n\n**Order ID:** #{payment_data['payment_order_id']}\n**Total Amount:** ‚Ç±{payment_data['payment_final_amount']:.2f}\n**Payment:** Cash on Delivery üíµ\n\nüì¶ **What's Next:**\n‚Ä¢ Your order is being prepared for shipping\n‚Ä¢ Our courier will contact you within 1-2 business days\n‚Ä¢ Prepare exact cash amount for payment\n‚Ä¢ You'll receive tracking information once shipped\n\nüöö **Delivery Info:**\n‚Ä¢ Have your ID ready for verification\n‚Ä¢ Payment required upon delivery\n‚Ä¢ Keep your receipt for warranty\n\nThank you for your order! üéâ\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üì¶ Track Order\", callback_data=f\"track_order_{payment_data['payment_order_id']}\")],\n                [InlineKeyboardButton(\"üì± Contact Support\", callback_data=\"customer_support\")],\n                [InlineKeyboardButton(\"üè™ Continue Shopping\", callback_data=\"catalog\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(success_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            \n        else:\n            await query.edit_message_text(\n                f\"‚ùå **COD Order Failed**\\n\\n{result['message']}\\n\\n\"\n                \"Please try again or contact support.\"\n            )\n        \n        context.user_data.clear()\n        return ConversationHandler.END\n    \n    async def show_payment_history(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show user's payment history\"\"\"\n        user_telegram_id = str(update.effective_user.id)\n        payments = self.payment_system.get_user_payment_history(user_telegram_id)\n        \n        if not payments:\n            message = \"\"\"\nüí≥ **Payment History**\n\nYou haven't made any payments yet.\n\nReady to make your first purchase?\n            \"\"\"\n            keyboard = [[InlineKeyboardButton(\"üõçÔ∏è Start Shopping\", callback_data=\"catalog\")]]\n        else:\n            message = f\"üí≥ **Payment History ({len(payments)} payments)**\\n\\n\"\n            keyboard = []\n            \n            for payment in payments[-10:]:  # Show last 10 payments\n                status_emoji = {\n                    'pending': '‚è≥',\n                    'completed': '‚úÖ',\n                    'failed': '‚ùå',\n                    'cancelled': 'üö´'\n                }.get(payment['status'], '‚ùì')\n                \n                method_emoji = {\n                    'gcash': 'üì±',\n                    'paymaya': 'üí≥',\n                    'bank_transfer': 'üè¶',\n                    'cod': 'üíµ'\n                }.get(payment['payment_method'], 'üí≥')\n                \n                message += f\"{status_emoji} **‚Ç±{payment['amount']:.2f}** {method_emoji}\\n\"\n                message += f\"   {payment['payment_method'].title()} ‚Ä¢ {payment['created_at'][:10]}\\n\"\n                message += f\"   ID: {payment['transaction_id']}\\n\\n\"\n                \n                keyboard.append([InlineKeyboardButton(\n                    f\"üìÑ {payment['transaction_id'][:8]}...\",\n                    callback_data=f\"payment_details_{payment['id']}\"\n                )])\n            \n            keyboard.append([InlineKeyboardButton(\"üîÑ Refresh\", callback_data=\"payment_history\")])\n        \n        keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"main_menu\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        if update.callback_query:\n            await update.callback_query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def cancel_payment(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Cancel payment process\"\"\"\n        if update.callback_query:\n            await update.callback_query.edit_message_text(\"‚ùå Payment process cancelled.\")\n        else:\n            await update.message.reply_text(\"‚ùå Payment process cancelled.\")\n        \n        context.user_data.clear()\n        return ConversationHandler.END\n\nclass AdminPaymentCommands:\n    \"\"\"Admin commands for payment management\"\"\"\n    \n    def __init__(self):\n        self.payment_system = PaymentSystem()\n        self.data_manager = AdvancedDataManager()\n    \n    async def admin_payment_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show payment management menu for admins\"\"\"\n        user_id = update.effective_user.id\n        \n        # Check admin permissions\n        if not self._is_admin(user_id):\n            await update.message.reply_text(\"‚ùå Access denied. Admin privileges required.\")\n            return\n        \n        # Get payment stats\n        analytics = self.payment_system.get_payment_analytics()\n        pending_payments = self.payment_system.get_pending_payments()\n        \n        menu_text = f\"\"\"\nüí≥ **Payment Management**\n\n**Current Status:**\n‚Ä¢ Pending Payments: {len(pending_payments)}\n‚Ä¢ Total Revenue: ‚Ç±{analytics['total_revenue']:,.2f}\n‚Ä¢ Completion Rate: {analytics['completion_rate']:.1f}%\n\n**Quick Actions:**\n‚Ä¢ Review pending payments\n‚Ä¢ Verify manual payments\n‚Ä¢ Process refunds\n‚Ä¢ View payment analytics\n\nChoose an option below:\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(f\"‚è≥ Pending Payments ({len(pending_payments)})\", callback_data=\"admin_pending_payments\")],\n            [InlineKeyboardButton(\"üìä Payment Analytics\", callback_data=\"admin_payment_analytics\")],\n            [InlineKeyboardButton(\"‚öôÔ∏è Payment Settings\", callback_data=\"admin_payment_settings\")],\n            [InlineKeyboardButton(\"üí∞ Process Refund\", callback_data=\"admin_process_refund\")],\n            [InlineKeyboardButton(\"üîô Back to Admin\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(menu_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_pending_payments(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show pending payments for admin review\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        pending_payments = self.payment_system.get_pending_payments()\n        \n        if not pending_payments:\n            message = \"\"\"\n‚úÖ **No Pending Payments**\n\nAll payments have been processed.\n\nGreat job staying on top of payment verifications! üéâ\n            \"\"\"\n            keyboard = [\n                [InlineKeyboardButton(\"üìä View Analytics\", callback_data=\"admin_payment_analytics\")],\n                [InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_payment_menu\")]\n            ]\n        else:\n            message = f\"‚è≥ **Pending Payments ({len(pending_payments)})**\\n\\n\"\n            keyboard = []\n            \n            for payment in pending_payments[:10]:  # Show first 10\n                amount = payment['amount']\n                method = payment['payment_method'].title()\n                ref = payment['reference_number'][:10] if payment['reference_number'] else 'No ref'\n                \n                message += f\"üí∞ **‚Ç±{amount:.2f}** via {method}\\n\"\n                message += f\"   Ref: {ref} | ID: {payment['transaction_id'][:8]}...\\n\"\n                message += f\"   User: {payment['user_id']} | {payment['created_at'][:10]}\\n\\n\"\n                \n                keyboard.append([\n                    InlineKeyboardButton(\"‚úÖ Verify\", callback_data=f\"verify_payment_{payment['id']}\"),\n                    InlineKeyboardButton(\"‚ùå Reject\", callback_data=f\"reject_payment_{payment['id']}\"),\n                    InlineKeyboardButton(\"üëÅÔ∏è Details\", callback_data=f\"payment_details_{payment['id']}\")\n                ])\n            \n            if len(pending_payments) > 10:\n                message += f\"*... and {len(pending_payments) - 10} more payments*\"\n        \n        keyboard.append([InlineKeyboardButton(\"üîÑ Refresh\", callback_data=\"admin_pending_payments\")])\n        keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_payment_menu\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def verify_payment_admin(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Admin verify a payment\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        payment_id = int(query.data.split('_')[-1])\n        admin_user = update.effective_user.first_name\n        \n        result = self.payment_system.verify_payment(payment_id, admin_user)\n        \n        if result['success']:\n            await query.edit_message_text(\n                f\"‚úÖ **Payment Verified**\\n\\n\"\n                f\"Payment has been approved and the order is now confirmed.\\n\"\n                f\"Customer will be notified automatically.\"\n            )\n            \n            # Notify customer\n            payment = result['payment']\n            if payment.get('user_id'):\n                # Implementation would send notification to customer\n                pass\n                \n        else:\n            await query.edit_message_text(\n                f\"‚ùå **Verification Failed**\\n\\n{result['message']}\"\n            )\n    \n    def _is_admin(self, user_id):\n        \"\"\"Check if user is admin\"\"\"\n        admin_ids = [123456789]  # Replace with actual admin IDs\n        return user_id in admin_ids\n\ndef get_payment_conversation_handler(bot_token):\n    \"\"\"Get conversation handler for payment processing\"\"\"\n    payment_commands = PaymentCommands(bot_token)\n    \n    return ConversationHandler(\n        entry_points=[CallbackQueryHandler(payment_commands.show_payment_methods, pattern=\"^pay_order_\")],\n        states={\n            PAYMENT_METHOD: [CallbackQueryHandler(payment_commands.handle_payment_method_selection, pattern=\"^payment_method_|^cancel_payment$\")],\n            PAYMENT_REFERENCE: [MessageHandler(filters.TEXT & ~filters.COMMAND, payment_commands.get_payment_reference)],\n            PAYMENT_PROOF: [\n                MessageHandler(filters.PHOTO, payment_commands.get_payment_proof),\n                MessageHandler(filters.TEXT & ~filters.COMMAND, payment_commands.get_payment_proof),\n                CallbackQueryHandler(payment_commands.get_payment_proof, pattern=\"^skip_proof$\")\n            ],\n            PAYMENT_CONFIRM: [\n                CallbackQueryHandler(payment_commands.submit_payment, pattern=\"^submit_payment$\"),\n                CallbackQueryHandler(payment_commands.confirm_cod_payment, pattern=\"^confirm_cod_payment$\"),\n                CallbackQueryHandler(payment_commands.show_payment_confirmation, pattern=\"^edit_payment$\")\n            ]\n        },\n        fallbacks=[\n            CallbackQueryHandler(payment_commands.cancel_payment, pattern=\"^cancel_payment$\"),\n            CommandHandler('cancel', payment_commands.cancel_payment)\n        ],\n        per_message=False\n    )","size_bytes":24786},"payment_system.py":{"content":"\"\"\"\nPayment Processing System\nHandles both automatic and manual payment processing with multiple payment methods\n\"\"\"\nimport os\nimport uuid\nimport re\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Tuple\nfrom enum import Enum\nfrom advanced_data_manager import AdvancedDataManager\n\nclass PaymentMethod(Enum):\n    GCASH = \"gcash\"\n    PAYMAYA = \"paymaya\"\n    BANK_TRANSFER = \"bank_transfer\"\n    CASH_ON_DELIVERY = \"cod\"\n    PAYPAL = \"paypal\"\n    MANUAL = \"manual\"\n\nclass PaymentStatus(Enum):\n    PENDING = \"pending\"\n    PROCESSING = \"processing\"\n    COMPLETED = \"completed\"\n    FAILED = \"failed\"\n    CANCELLED = \"cancelled\"\n    REFUNDED = \"refunded\"\n\nclass PaymentSystem:\n    def __init__(self):\n        self.data_manager = AdvancedDataManager()\n        self.payment_methods = self._load_payment_methods()\n    \n    def _load_payment_methods(self) -> Dict:\n        \"\"\"Load available payment methods from settings\"\"\"\n        try:\n            methods_json = self.data_manager.get_setting('payment_methods', '[]')\n            import json\n            methods = json.loads(methods_json)\n        except:\n            methods = [\"GCash\", \"PayMaya\", \"Bank Transfer\", \"Cash on Delivery\"]\n        \n        return {\n            \"gcash\": {\n                \"name\": \"GCash\",\n                \"description\": \"Pay via GCash mobile wallet\",\n                \"account\": self.data_manager.get_setting('gcash_account', ''),\n                \"instructions\": \"Send payment to the GCash number and upload receipt\",\n                \"auto_verify\": False,\n                \"fee\": 0.0\n            },\n            \"paymaya\": {\n                \"name\": \"PayMaya\",\n                \"description\": \"Pay via PayMaya digital wallet\", \n                \"account\": self.data_manager.get_setting('paymaya_account', ''),\n                \"instructions\": \"Send payment to the PayMaya account and upload receipt\",\n                \"auto_verify\": False,\n                \"fee\": 0.0\n            },\n            \"bank_transfer\": {\n                \"name\": \"Bank Transfer\",\n                \"description\": \"Direct bank transfer\",\n                \"account\": self.data_manager.get_setting('bank_account', ''),\n                \"instructions\": \"Transfer to bank account and send reference number\",\n                \"auto_verify\": False,\n                \"fee\": 0.0\n            },\n            \"cod\": {\n                \"name\": \"Cash on Delivery\",\n                \"description\": \"Pay when item is delivered\",\n                \"account\": \"\",\n                \"instructions\": \"Pay in cash upon delivery\",\n                \"auto_verify\": True,  # Auto-approved\n                \"fee\": 50.0  # COD fee\n            }\n        }\n    \n    def get_available_payment_methods(self, order_total: float = 0) -> List[Dict]:\n        \"\"\"Get available payment methods for an order\"\"\"\n        methods = []\n        \n        for method_id, method_info in self.payment_methods.items():\n            # Add method-specific availability logic\n            if method_id == \"cod\" and order_total < 100:\n                # Minimum order for COD\n                continue\n            \n            methods.append({\n                \"id\": method_id,\n                \"name\": method_info[\"name\"],\n                \"description\": method_info[\"description\"],\n                \"fee\": method_info[\"fee\"],\n                \"instructions\": method_info[\"instructions\"]\n            })\n        \n        return methods\n    \n    def create_payment(self, \n                      order_id: int,\n                      user_telegram_id: str, \n                      amount: float,\n                      payment_method: str,\n                      currency: str = \"PHP\",\n                      **kwargs) -> Dict:\n        \"\"\"Create a new payment record\"\"\"\n        \n        try:\n            # Validate payment method\n            if payment_method not in self.payment_methods:\n                return {\n                    'success': False,\n                    'message': f'Invalid payment method: {payment_method}'\n                }\n            \n            # Create payment record\n            payment = self.data_manager.create_payment(\n                user_telegram_id=user_telegram_id,\n                amount=amount,\n                payment_method=payment_method,\n                order_id=order_id,\n                currency=currency,\n                reference_number=kwargs.get('reference_number', ''),\n                notes=kwargs.get('notes', ''),\n                proof_image=kwargs.get('proof_image', '')\n            )\n            \n            if not payment:\n                return {\n                    'success': False,\n                    'message': 'Failed to create payment record'\n                }\n            \n            # Auto-verify certain payment methods\n            method_info = self.payment_methods[payment_method]\n            if method_info.get('auto_verify', False):\n                self.verify_payment(payment['id'], 'system', auto_verified=True)\n            \n            return {\n                'success': True,\n                'payment': payment,\n                'message': 'Payment created successfully'\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error creating payment: {str(e)}'\n            }\n    \n    def verify_payment(self, \n                      payment_id: int, \n                      verified_by: str,\n                      auto_verified: bool = False,\n                      notes: str = '') -> Dict:\n        \"\"\"Verify a manual payment\"\"\"\n        \n        try:\n            payment = self.data_manager.verify_payment(payment_id, verified_by)\n            \n            if not payment:\n                return {\n                    'success': False,\n                    'message': 'Payment not found'\n                }\n            \n            # Update related order status\n            if payment.get('order_id'):\n                self.data_manager.update_order_status(payment['order_id'], 'confirmed')\n            \n            return {\n                'success': True,\n                'payment': payment,\n                'message': 'Payment verified successfully'\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error verifying payment: {str(e)}'\n            }\n    \n    def process_manual_payment(self,\n                             order_id: int,\n                             user_telegram_id: str,\n                             amount: float,\n                             payment_method: str,\n                             reference_number: str = '',\n                             proof_image: str = '',\n                             notes: str = '') -> Dict:\n        \"\"\"Process a manual payment submission\"\"\"\n        \n        # Validate reference number format based on payment method\n        if payment_method in ['gcash', 'paymaya', 'bank_transfer']:\n            if not reference_number or len(reference_number) < 6:\n                return {\n                    'success': False,\n                    'message': 'Please provide a valid reference number (at least 6 characters)'\n                }\n        \n        # Create payment record\n        result = self.create_payment(\n            order_id=order_id,\n            user_telegram_id=user_telegram_id,\n            amount=amount,\n            payment_method=payment_method,\n            reference_number=reference_number,\n            proof_image=proof_image,\n            notes=notes\n        )\n        \n        if result['success']:\n            payment = result['payment']\n            \n            # Send notification to admins about pending payment\n            self._notify_admin_payment_pending(payment)\n            \n            return {\n                'success': True,\n                'payment': payment,\n                'message': 'Payment submitted successfully. Please wait for verification.',\n                'instructions': self._get_payment_instructions(payment_method, amount)\n            }\n        \n        return result\n    \n    def get_payment_instructions(self, payment_method: str, amount: float) -> str:\n        \"\"\"Get detailed payment instructions for a method\"\"\"\n        method_info = self.payment_methods.get(payment_method)\n        if not method_info:\n            return \"Payment method not found\"\n        \n        instructions = f\"\"\"\nüí≥ **{method_info['name']} Payment Instructions**\n\nüí∞ **Amount to Pay:** ‚Ç±{amount:.2f}\nüì± **Account:** {method_info['account'] or 'Will be provided'}\n\nüìã **Steps:**\n{method_info['instructions']}\n\n‚ö†Ô∏è **Important:**\n‚Ä¢ Pay the exact amount shown above\n‚Ä¢ Keep your receipt/screenshot\n‚Ä¢ Send the reference number or transaction ID\n‚Ä¢ Payments are verified within 24 hours\n\nNeed help? Contact our support team.\n        \"\"\"\n        \n        return instructions\n    \n    def _get_payment_instructions(self, payment_method: str, amount: float) -> str:\n        \"\"\"Get payment instructions (internal)\"\"\"\n        return self.get_payment_instructions(payment_method, amount)\n    \n    def get_pending_payments(self) -> List[Dict]:\n        \"\"\"Get all pending payments for admin review\"\"\"\n        return self.data_manager.get_payments(status='pending')\n    \n    def get_user_payment_history(self, user_telegram_id: str) -> List[Dict]:\n        \"\"\"Get payment history for a specific user\"\"\"\n        return self.data_manager.get_payments(user_telegram_id=user_telegram_id)\n    \n    def get_payment_analytics(self) -> Dict:\n        \"\"\"Get payment analytics and statistics\"\"\"\n        all_payments = self.data_manager.get_payments()\n        \n        # Calculate stats\n        total_payments = len(all_payments)\n        completed_payments = [p for p in all_payments if p['status'] == 'completed']\n        pending_payments = [p for p in all_payments if p['status'] == 'pending']\n        \n        total_revenue = sum(p['amount'] for p in completed_payments)\n        pending_amount = sum(p['amount'] for p in pending_payments)\n        \n        # Payment method breakdown\n        method_stats = {}\n        for payment in all_payments:\n            method = payment['payment_method']\n            if method not in method_stats:\n                method_stats[method] = {'count': 0, 'amount': 0}\n            method_stats[method]['count'] += 1\n            if payment['status'] == 'completed':\n                method_stats[method]['amount'] += payment['amount']\n        \n        # Recent activity (last 7 days)\n        week_ago = datetime.utcnow() - timedelta(days=7)\n        recent_payments = [\n            p for p in all_payments \n            if datetime.fromisoformat(p['created_at']) >= week_ago\n        ]\n        recent_completed = [p for p in recent_payments if p['status'] == 'completed']\n        \n        return {\n            'total_payments': total_payments,\n            'completed_payments': len(completed_payments),\n            'pending_payments': len(pending_payments),\n            'total_revenue': total_revenue,\n            'pending_amount': pending_amount,\n            'method_stats': method_stats,\n            'recent_payments': len(recent_payments),\n            'recent_revenue': sum(p['amount'] for p in recent_completed),\n            'completion_rate': (len(completed_payments) / total_payments * 100) if total_payments > 0 else 0\n        }\n    \n    def reject_payment(self, payment_id: int, reason: str, admin_user: str) -> Dict:\n        \"\"\"Reject a payment with reason\"\"\"\n        try:\n            # Update payment status to failed\n            # Note: You'd need to add this method to the data manager\n            payment_data = {\n                'status': 'failed',\n                'notes': f'Rejected by {admin_user}: {reason}'\n            }\n            \n            # For now, we'll just add a note that it was rejected\n            return {\n                'success': True,\n                'message': f'Payment rejected: {reason}'\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error rejecting payment: {str(e)}'\n            }\n    \n    def refund_payment(self, payment_id: int, amount: float, reason: str, admin_user: str) -> Dict:\n        \"\"\"Process a payment refund\"\"\"\n        try:\n            # Create refund record\n            # This would typically integrate with payment gateway APIs\n            \n            refund_data = {\n                'original_payment_id': payment_id,\n                'refund_amount': amount,\n                'reason': reason,\n                'processed_by': admin_user,\n                'status': 'completed'  # In real implementation, this might be 'processing'\n            }\n            \n            return {\n                'success': True,\n                'refund': refund_data,\n                'message': f'Refund of ‚Ç±{amount:.2f} processed successfully'\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error processing refund: {str(e)}'\n            }\n    \n    def validate_reference_number(self, reference_number: str, payment_method: str) -> bool:\n        \"\"\"Validate reference number format based on payment method\"\"\"\n        if not reference_number:\n            return False\n        \n        # Basic validation - can be enhanced for specific formats\n        if payment_method == 'gcash':\n            # GCash typically has 13-digit reference numbers\n            return bool(re.match(r'^[0-9]{10,15}$', reference_number))\n        elif payment_method == 'paymaya':\n            # PayMaya format validation\n            return bool(re.match(r'^[0-9A-Z]{10,20}$', reference_number))\n        elif payment_method == 'bank_transfer':\n            # Bank transfer reference numbers vary\n            return len(reference_number) >= 6\n        \n        return len(reference_number) >= 6  # Generic validation\n    \n    def calculate_payment_fees(self, amount: float, payment_method: str) -> Tuple[float, float]:\n        \"\"\"Calculate payment fees and final amount\"\"\"\n        method_info = self.payment_methods.get(payment_method, {})\n        fee = method_info.get('fee', 0.0)\n        \n        # Fee can be flat rate or percentage\n        if isinstance(fee, str) and fee.endswith('%'):\n            fee_rate = float(fee[:-1]) / 100\n            calculated_fee = amount * fee_rate\n        else:\n            calculated_fee = float(fee)\n        \n        final_amount = amount + calculated_fee\n        return calculated_fee, final_amount\n    \n    def setup_payment_method_config(self, method: str, config: Dict) -> Dict:\n        \"\"\"Configure payment method settings\"\"\"\n        try:\n            # Update payment method configuration\n            if method == 'gcash':\n                self.data_manager.set_setting('gcash_account', config.get('account', ''))\n            elif method == 'paymaya':\n                self.data_manager.set_setting('paymaya_account', config.get('account', ''))\n            elif method == 'bank_transfer':\n                self.data_manager.set_setting('bank_account', config.get('account', ''))\n            \n            # Reload payment methods\n            self.payment_methods = self._load_payment_methods()\n            \n            return {\n                'success': True,\n                'message': f'{method} configuration updated successfully'\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error updating {method} configuration: {str(e)}'\n            }\n    \n    def _notify_admin_payment_pending(self, payment: Dict):\n        \"\"\"Notify admin about pending payment (to be implemented with notification system)\"\"\"\n        # This would integrate with your notification system\n        # For now, just log it\n        print(f\"üîî New payment pending verification: {payment['transaction_id']} - ‚Ç±{payment['amount']:.2f}\")\n    \n    def auto_verify_cod_payments(self):\n        \"\"\"Auto-verify Cash on Delivery payments when order is delivered\"\"\"\n        # This would be called when order status changes to 'delivered'\n        cod_payments = [\n            p for p in self.data_manager.get_payments(status='pending')\n            if p['payment_method'] == 'cod'\n        ]\n        \n        verified_count = 0\n        for payment in cod_payments:\n            # Check if associated order is delivered\n            order = self.data_manager.get_order(payment['order_id'])\n            if order and order['status'] == 'delivered':\n                self.verify_payment(payment['id'], 'system', auto_verified=True)\n                verified_count += 1\n        \n        return verified_count\n\nclass PaymentNotifications:\n    \"\"\"Handle payment-related notifications\"\"\"\n    \n    def __init__(self, broadcast_system):\n        self.broadcast_system = broadcast_system\n        self.payment_system = PaymentSystem()\n    \n    async def notify_payment_received(self, user_telegram_id: str, payment: Dict):\n        \"\"\"Notify user that payment was received\"\"\"\n        try:\n            from telegram import Bot\n            bot = Bot(token=os.environ.get('BOT_TOKEN'))\n            \n            message = f\"\"\"\n‚úÖ **Payment Received**\n\n**Transaction ID:** {payment['transaction_id']}\n**Amount:** ‚Ç±{payment['amount']:.2f}\n**Method:** {payment['payment_method'].title()}\n**Status:** Under Review\n\nüîç Your payment is being verified. You'll receive another notification once it's approved.\n\nExpected verification time: Within 24 hours\n            \"\"\"\n            \n            await bot.send_message(\n                chat_id=user_telegram_id,\n                text=message,\n                parse_mode='Markdown'\n            )\n            \n            return True\n            \n        except Exception as e:\n            print(f\"Error sending payment notification: {e}\")\n            return False\n    \n    async def notify_payment_verified(self, user_telegram_id: str, payment: Dict):\n        \"\"\"Notify user that payment was verified\"\"\"\n        try:\n            from telegram import Bot\n            bot = Bot(token=os.environ.get('BOT_TOKEN'))\n            \n            message = f\"\"\"\nüéâ **Payment Verified!**\n\n**Transaction ID:** {payment['transaction_id']}\n**Amount:** ‚Ç±{payment['amount']:.2f}\n**Status:** ‚úÖ Confirmed\n\nYour payment has been verified and your order is being processed!\n\nüì¶ You'll receive tracking information once your order ships.\n            \"\"\"\n            \n            await bot.send_message(\n                chat_id=user_telegram_id,\n                text=message,\n                parse_mode='Markdown'\n            )\n            \n            return True\n            \n        except Exception as e:\n            print(f\"Error sending verification notification: {e}\")\n            return False\n    \n    async def notify_admin_payment_pending(self, payment: Dict):\n        \"\"\"Notify admins about pending payment\"\"\"\n        # This would send to admin chat or channel\n        message = f\"\"\"\nüîî **New Payment Pending**\n\n**ID:** {payment['transaction_id']}\n**Amount:** ‚Ç±{payment['amount']:.2f}\n**Method:** {payment['payment_method'].title()}\n**Reference:** {payment['reference_number']}\n**User:** {payment['user_id']}\n\nReview and verify this payment in the admin panel.\n        \"\"\"\n        \n        # Send to admin notification channel/chat\n        # Implementation depends on your admin notification setup\n        print(f\"Admin notification: {message}\")\n        return True\n\n# Payment validation utilities\nclass PaymentValidation:\n    \"\"\"Utilities for validating payment data\"\"\"\n    \n    @staticmethod\n    def validate_amount(amount: float) -> Tuple[bool, str]:\n        \"\"\"Validate payment amount\"\"\"\n        if amount <= 0:\n            return False, \"Amount must be greater than zero\"\n        if amount > 100000:  # Max amount limit\n            return False, \"Amount exceeds maximum limit of ‚Ç±100,000\"\n        return True, \"Valid\"\n    \n    @staticmethod\n    def validate_gcash_number(number: str) -> Tuple[bool, str]:\n        \"\"\"Validate GCash mobile number format\"\"\"\n        # Remove spaces and formatting\n        cleaned = re.sub(r'[^\\d+]', '', number)\n        \n        # Philippine mobile number patterns\n        patterns = [\n            r'^(09|\\+639)\\d{9}$',  # 09XXXXXXXXX or +639XXXXXXXXX\n            r'^639\\d{9}$'          # 639XXXXXXXXX\n        ]\n        \n        for pattern in patterns:\n            if re.match(pattern, cleaned):\n                return True, \"Valid\"\n        \n        return False, \"Invalid Philippine mobile number format\"\n    \n    @staticmethod\n    def validate_bank_account(account: str) -> Tuple[bool, str]:\n        \"\"\"Validate bank account format\"\"\"\n        # Remove spaces and dashes\n        cleaned = re.sub(r'[\\s-]', '', account)\n        \n        # Basic validation - account should be 10-20 digits\n        if re.match(r'^\\d{10,20}$', cleaned):\n            return True, \"Valid\"\n        \n        return False, \"Invalid bank account format (should be 10-20 digits)\"\n\n# Payment method configurations\nPAYMENT_METHOD_CONFIGS = {\n    \"gcash\": {\n        \"name\": \"GCash\",\n        \"icon\": \"üì±\",\n        \"color\": \"#007DFF\",\n        \"requires_reference\": True,\n        \"requires_proof\": True,\n        \"validation_function\": PaymentValidation.validate_gcash_number\n    },\n    \"paymaya\": {\n        \"name\": \"PayMaya\",\n        \"icon\": \"üí≥\",\n        \"color\": \"#00A8FF\",\n        \"requires_reference\": True,\n        \"requires_proof\": True\n    },\n    \"bank_transfer\": {\n        \"name\": \"Bank Transfer\",\n        \"icon\": \"üè¶\",\n        \"color\": \"#28A745\",\n        \"requires_reference\": True,\n        \"requires_proof\": False\n    },\n    \"cod\": {\n        \"name\": \"Cash on Delivery\",\n        \"icon\": \"üíµ\",\n        \"color\": \"#FFC107\",\n        \"requires_reference\": False,\n        \"requires_proof\": False,\n        \"auto_approve\": False\n    }\n}","size_bytes":21908},"polling_bot.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nTelegram Store Bot - Polling Mode for Free Testing\nThis version works without deployment and uses long polling instead of webhooks\n\"\"\"\nimport os\nimport logging\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes, ConversationHandler\nfrom telegram.constants import ParseMode\nfrom data_manager import DataManager\n\n# Configure logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n\n# Conversation states\nSELECTING_CATEGORY, SELECTING_PRODUCT, VIEWING_CART, CHECKOUT = range(4)\n\nclass TelegramStoreBotPolling:\n    def __init__(self, token, data_manager):\n        self.token = token\n        self.data_manager = data_manager\n        self.application = Application.builder().token(token).build()\n        self.user_sessions = {}\n        self.setup_handlers()\n    \n    def setup_handlers(self):\n        \"\"\"Setup bot command and callback handlers\"\"\"\n        # Command handlers\n        self.application.add_handler(CommandHandler(\"start\", self.start_command))\n        self.application.add_handler(CommandHandler(\"help\", self.help_command))\n        self.application.add_handler(CommandHandler(\"catalog\", self.catalog_command))\n        self.application.add_handler(CommandHandler(\"cart\", self.cart_command))\n        self.application.add_handler(CommandHandler(\"orders\", self.orders_command))\n        \n        # Callback query handler for inline keyboards\n        self.application.add_handler(CallbackQueryHandler(self.button_callback))\n        \n        # Conversation handler for checkout process\n        conv_handler = ConversationHandler(\n            entry_points=[CallbackQueryHandler(self.start_checkout, pattern=\"^checkout$\")],\n            states={\n                CHECKOUT: [MessageHandler(filters.TEXT & ~filters.COMMAND, self.process_checkout_info)]\n            },\n            fallbacks=[CommandHandler(\"cancel\", self.cancel_checkout)],\n            per_message=False\n        )\n        self.application.add_handler(conv_handler)\n    \n    def get_user_session(self, user_id):\n        \"\"\"Get or create user session\"\"\"\n        if user_id not in self.user_sessions:\n            self.user_sessions[user_id] = {\n                'cart': {},\n                'current_category': None,\n                'current_product': None\n            }\n        return self.user_sessions[user_id]\n    \n    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /start command\"\"\"\n        user = update.effective_user\n        welcome_message = f\"\"\"\nüõçÔ∏è **Welcome to Our Store, {user.first_name}!**\n\nI'm your personal shopping assistant. Here's what I can help you with:\n\nüè™ **Browse Catalog** - View our product categories\nüõí **Shopping Cart** - Manage your selected items\nüì¶ **Your Orders** - Track your order history\n‚ùì **Help** - Get assistance\n\nUse the menu below or type /help for more information.\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üè™ Browse Catalog\", callback_data=\"catalog\")],\n            [InlineKeyboardButton(\"üõí View Cart\", callback_data=\"cart\")],\n            [InlineKeyboardButton(\"üì¶ My Orders\", callback_data=\"orders\")],\n            [InlineKeyboardButton(\"‚ùì Help\", callback_data=\"help\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(welcome_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /help command\"\"\"\n        help_text = \"\"\"\nüÜò **Help & Commands**\n\n**Available Commands:**\n/start - Main menu\n/catalog - Browse products\n/cart - View your shopping cart\n/orders - View your order history\n/help - Show this help message\n\n**How to Shop:**\n1Ô∏è‚É£ Browse catalog by category\n2Ô∏è‚É£ Select products and add to cart\n3Ô∏è‚É£ Review your cart\n4Ô∏è‚É£ Proceed to checkout\n5Ô∏è‚É£ Provide shipping details\n6Ô∏è‚É£ Confirm your order\n\n**Need Help?**\nContact our support team or use the buttons below to navigate.\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üè™ Browse Catalog\", callback_data=\"catalog\")],\n            [InlineKeyboardButton(\"üõí View Cart\", callback_data=\"cart\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(help_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def catalog_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /catalog command\"\"\"\n        await self.show_categories(update, context)\n    \n    async def cart_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /cart command\"\"\"\n        await self.show_cart(update, context)\n    \n    async def orders_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle /orders command\"\"\"\n        await self.show_user_orders(update, context)\n    \n    async def show_categories(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show product categories\"\"\"\n        products = self.data_manager.get_products()\n        categories = {}\n        \n        # Group products by category\n        for product in products:\n            category = product.get('category', 'Uncategorized')\n            if category not in categories:\n                categories[category] = 0\n            categories[category] += 1\n        \n        if not categories:\n            message = \"üö´ **No products available at the moment.**\\n\\nPlease check back later!\"\n            keyboard = [[InlineKeyboardButton(\"üîÑ Refresh\", callback_data=\"catalog\")]]\n        else:\n            message = \"üè™ **Product Categories**\\n\\nSelect a category to browse products:\"\n            keyboard = []\n            for category, count in categories.items():\n                keyboard.append([InlineKeyboardButton(f\"{category} ({count} items)\", callback_data=f\"category_{category}\")])\n            keyboard.append([InlineKeyboardButton(\"üõí View Cart\", callback_data=\"cart\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        if update.callback_query:\n            await update.callback_query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_products_in_category(self, update: Update, context: ContextTypes.DEFAULT_TYPE, category):\n        \"\"\"Show products in a specific category\"\"\"\n        products = self.data_manager.get_products()\n        category_products = [p for p in products if p.get('category') == category]\n        \n        if not category_products:\n            message = f\"üö´ **No products in {category}**\\n\\nThis category is currently empty.\"\n            keyboard = [[InlineKeyboardButton(\"‚¨ÖÔ∏è Back to Categories\", callback_data=\"catalog\")]]\n        else:\n            message = f\"üè™ **{category}**\\n\\nSelect a product to view details:\"\n            keyboard = []\n            for product in category_products:\n                stock_info = f\" (Stock: {product.get('stock', 0)})\" if product.get('stock', 0) > 0 else \" (Out of Stock)\"\n                keyboard.append([InlineKeyboardButton(f\"{product['name']}{stock_info}\", callback_data=f\"product_{product['id']}\")])\n            keyboard.append([InlineKeyboardButton(\"‚¨ÖÔ∏è Back to Categories\", callback_data=\"catalog\")])\n            keyboard.append([InlineKeyboardButton(\"üõí View Cart\", callback_data=\"cart\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await update.callback_query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_product_details(self, update: Update, context: ContextTypes.DEFAULT_TYPE, product_id):\n        \"\"\"Show detailed product information\"\"\"\n        products = self.data_manager.get_products()\n        product = next((p for p in products if p['id'] == product_id), None)\n        \n        if not product:\n            message = \"üö´ **Product not found**\\n\\nThis product may have been removed.\"\n            keyboard = [[InlineKeyboardButton(\"‚¨ÖÔ∏è Back to Catalog\", callback_data=\"catalog\")]]\n        else:\n            stock = product.get('stock', 0)\n            stock_status = \"‚úÖ In Stock\" if stock > 0 else \"‚ùå Out of Stock\"\n            \n            message = f\"\"\"\nüõçÔ∏è **{product['name']}**\n\nüìù **Description:**\n{product['description']}\n\nüí∞ **Price:** ${product['price']:.2f}\nüì¶ **Stock:** {stock_status} ({stock} available)\nüè∑Ô∏è **Category:** {product.get('category', 'Uncategorized')}\n            \"\"\"\n            \n            keyboard = []\n            if stock > 0:\n                keyboard.append([InlineKeyboardButton(\"‚ûï Add to Cart\", callback_data=f\"add_to_cart_{product_id}\")])\n            keyboard.append([InlineKeyboardButton(\"‚¨ÖÔ∏è Back to Category\", callback_data=f\"category_{product.get('category', 'Uncategorized')}\")])\n            keyboard.append([InlineKeyboardButton(\"üõí View Cart\", callback_data=\"cart\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await update.callback_query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def add_to_cart(self, update: Update, context: ContextTypes.DEFAULT_TYPE, product_id):\n        \"\"\"Add product to user's cart\"\"\"\n        user_id = update.effective_user.id\n        session = self.get_user_session(user_id)\n        \n        products = self.data_manager.get_products()\n        product = next((p for p in products if p['id'] == product_id), None)\n        \n        if not product:\n            await update.callback_query.answer(\"‚ùå Product not found!\", show_alert=True)\n            return\n        \n        if product.get('stock', 0) <= 0:\n            await update.callback_query.answer(\"‚ùå Product out of stock!\", show_alert=True)\n            return\n        \n        # Check if already in cart\n        if product_id in session['cart']:\n            session['cart'][product_id]['quantity'] += 1\n        else:\n            session['cart'][product_id] = {\n                'quantity': 1,\n                'product': product\n            }\n        \n        await update.callback_query.answer(f\"‚úÖ {product['name']} added to cart!\", show_alert=False)\n        \n        # Show updated product details with cart info\n        await self.show_product_details(update, context, product_id)\n    \n    async def show_cart(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show user's shopping cart\"\"\"\n        user_id = update.effective_user.id\n        session = self.get_user_session(user_id)\n        cart = session['cart']\n        \n        if not cart:\n            message = \"üõí **Your Cart is Empty**\\n\\nBrowse our catalog to add some products!\"\n            keyboard = [[InlineKeyboardButton(\"üè™ Browse Catalog\", callback_data=\"catalog\")]]\n        else:\n            message = \"üõí **Your Shopping Cart**\\n\\n\"\n            total = 0\n            keyboard = []\n            \n            for product_id, item in cart.items():\n                product = item['product']\n                quantity = item['quantity']\n                subtotal = product['price'] * quantity\n                total += subtotal\n                \n                message += f\"‚Ä¢ **{product['name']}**\\n\"\n                message += f\"  Quantity: {quantity} √ó ${product['price']:.2f} = ${subtotal:.2f}\\n\\n\"\n                \n                keyboard.append([\n                    InlineKeyboardButton(f\"‚ûñ {product['name']}\", callback_data=f\"remove_from_cart_{product_id}\"),\n                    InlineKeyboardButton(\"‚ûï\", callback_data=f\"add_to_cart_{product_id}\")\n                ])\n            \n            message += f\"üí∞ **Total: ${total:.2f}**\"\n            keyboard.append([InlineKeyboardButton(\"üöÆ Clear Cart\", callback_data=\"clear_cart\")])\n            keyboard.append([InlineKeyboardButton(\"üí≥ Checkout\", callback_data=\"checkout\")])\n            keyboard.append([InlineKeyboardButton(\"üè™ Continue Shopping\", callback_data=\"catalog\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        if update.callback_query:\n            await update.callback_query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def remove_from_cart(self, update: Update, context: ContextTypes.DEFAULT_TYPE, product_id):\n        \"\"\"Remove item from cart\"\"\"\n        user_id = update.effective_user.id\n        session = self.get_user_session(user_id)\n        \n        if product_id in session['cart']:\n            session['cart'][product_id]['quantity'] -= 1\n            if session['cart'][product_id]['quantity'] <= 0:\n                del session['cart'][product_id]\n        \n        await update.callback_query.answer(\"üóëÔ∏è Item removed from cart\")\n        await self.show_cart(update, context)\n    \n    async def clear_cart(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Clear user's cart\"\"\"\n        user_id = update.effective_user.id\n        session = self.get_user_session(user_id)\n        session['cart'] = {}\n        \n        await update.callback_query.answer(\"üóëÔ∏è Cart cleared!\")\n        await self.show_cart(update, context)\n    \n    async def start_checkout(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Start checkout process\"\"\"\n        user_id = update.effective_user.id\n        session = self.get_user_session(user_id)\n        \n        if not session['cart']:\n            await update.callback_query.answer(\"‚ùå Your cart is empty!\", show_alert=True)\n            return\n        \n        message = \"\"\"\nüìã **Checkout Process**\n\nPlease provide your shipping information in the following format:\n\n**Full Name:**\n**Phone Number:**\n**Address:**\n**City, State, ZIP:**\n**Special Instructions (optional):**\n\nPlease send all information in a single message.\n        \"\"\"\n        \n        keyboard = [[InlineKeyboardButton(\"‚ùå Cancel Checkout\", callback_data=\"cart\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.callback_query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return CHECKOUT\n    \n    async def process_checkout_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Process checkout information and create order\"\"\"\n        user_id = update.effective_user.id\n        session = self.get_user_session(user_id)\n        shipping_info = update.message.text\n        \n        # Create order\n        order_data = {\n            'user_id': user_id,\n            'user_name': update.effective_user.first_name,\n            'username': update.effective_user.username,\n            'items': session['cart'],\n            'shipping_info': shipping_info,\n            'status': 'pending'\n        }\n        \n        order = self.data_manager.create_order(order_data)\n        \n        # Clear cart\n        session['cart'] = {}\n        \n        # Calculate total\n        total = sum(item['product']['price'] * item['quantity'] for item in order['items'].values())\n        \n        confirmation_message = f\"\"\"\n‚úÖ **Order Confirmed!**\n\n**Order ID:** #{order['id']}\n**Total:** ${total:.2f}\n**Status:** Pending\n\nYour order has been received and will be processed soon. You'll receive updates about your order status.\n\nThank you for shopping with us! üõçÔ∏è\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üì¶ Track Order\", callback_data=f\"order_{order['id']}\")],\n            [InlineKeyboardButton(\"üè™ Continue Shopping\", callback_data=\"catalog\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(confirmation_message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return ConversationHandler.END\n    \n    async def cancel_checkout(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Cancel checkout process\"\"\"\n        await update.message.reply_text(\"‚ùå Checkout cancelled.\")\n        await self.show_cart(update, context)\n        return ConversationHandler.END\n    \n    async def show_user_orders(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show user's order history\"\"\"\n        user_id = update.effective_user.id\n        orders = self.data_manager.get_user_orders(user_id)\n        \n        if not orders:\n            message = \"üì¶ **No Orders Found**\\n\\nYou haven't placed any orders yet.\"\n            keyboard = [[InlineKeyboardButton(\"üè™ Start Shopping\", callback_data=\"catalog\")]]\n        else:\n            message = \"üì¶ **Your Orders**\\n\\n\"\n            keyboard = []\n            \n            for order in orders[-5:]:  # Show last 5 orders\n                total = sum(item['product']['price'] * item['quantity'] for item in order['items'].values())\n                status_emoji = {\n                    'pending': '‚è≥',\n                    'confirmed': '‚úÖ',\n                    'shipped': 'üöö',\n                    'delivered': 'üì¶',\n                    'cancelled': '‚ùå'\n                }.get(order['status'], '‚ùì')\n                \n                message += f\"{status_emoji} **Order #{order['id']}**\\n\"\n                message += f\"Total: ${total:.2f} | Status: {order['status'].title()}\\n\"\n                message += f\"Date: {order['created_at']}\\n\\n\"\n                \n                keyboard.append([InlineKeyboardButton(f\"Order #{order['id']}\", callback_data=f\"order_{order['id']}\")])\n            \n            keyboard.append([InlineKeyboardButton(\"üè™ Continue Shopping\", callback_data=\"catalog\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        if update.callback_query:\n            await update.callback_query.edit_message_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(message, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def button_callback(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle inline keyboard button presses\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        data = query.data\n        \n        if data == \"catalog\":\n            await self.show_categories(update, context)\n        elif data == \"cart\":\n            await self.show_cart(update, context)\n        elif data == \"orders\":\n            await self.show_user_orders(update, context)\n        elif data == \"help\":\n            await self.help_command(update, context)\n        elif data.startswith(\"category_\"):\n            category = data.replace(\"category_\", \"\")\n            await self.show_products_in_category(update, context, category)\n        elif data.startswith(\"product_\"):\n            product_id = int(data.replace(\"product_\", \"\"))\n            await self.show_product_details(update, context, product_id)\n        elif data.startswith(\"add_to_cart_\"):\n            product_id = int(data.replace(\"add_to_cart_\", \"\"))\n            await self.add_to_cart(update, context, product_id)\n        elif data.startswith(\"remove_from_cart_\"):\n            product_id = int(data.replace(\"remove_from_cart_\", \"\"))\n            await self.remove_from_cart(update, context, product_id)\n        elif data == \"clear_cart\":\n            await self.clear_cart(update, context)\n\ndef main():\n    \"\"\"Main function to run the bot\"\"\"\n    bot_token = os.environ.get(\"BOT_TOKEN\")\n    if not bot_token:\n        print(\"‚ùå BOT_TOKEN environment variable not set!\")\n        print(\"Please add your bot token as a secret in Replit\")\n        return\n    \n    data_manager = DataManager()\n    bot = TelegramStoreBotPolling(bot_token, data_manager)\n    \n    print(\"ü§ñ Starting Telegram Store Bot in polling mode...\")\n    print(\"‚úÖ Bot is now active and will respond to messages!\")\n    print(\"üí¨ Send /start to your bot on Telegram to begin shopping\")\n    print(\"üõë Press Ctrl+C to stop the bot\")\n    \n    try:\n        # Run the bot until the user presses Ctrl-C\n        bot.application.run_polling(allowed_updates=Update.ALL_TYPES)\n    except KeyboardInterrupt:\n        print(\"\\nüõë Bot stopped by user\")\n    except Exception as e:\n        print(f\"‚ùå Error running bot: {e}\")\n\nif __name__ == '__main__':\n    main()","size_bytes":20731},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"asyncio>=4.0.0\",\n    \"email-validator>=2.3.0\",\n    \"flask>=3.1.2\",\n    \"flask-sqlalchemy>=3.1.1\",\n    \"gunicorn>=23.0.0\",\n    \"psycopg2-binary>=2.9.10\",\n    \"python-telegram-bot>=22.3\",\n    \"requests>=2.32.5\",\n    \"sqlalchemy>=2.0.43\",\n    \"telegram>=0.0.1\",\n    \"werkzeug>=3.1.3\",\n]\n","size_bytes":431},"replit.md":{"content":"# Overview\n\nThis is a Telegram Store Bot application built with Flask and python-telegram-bot. The system provides an e-commerce platform where users can browse products, add items to cart, and place orders through a Telegram bot interface. It includes a web-based admin panel for managing products and orders, with data persistence handled through JSON files.\n\n# User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n# System Architecture\n\n## Backend Architecture\nThe application follows a modular Flask architecture with clear separation of concerns:\n\n- **Flask Web Application**: Serves as the admin interface and API layer, handling HTTP requests and rendering templates\n- **Telegram Bot Integration**: Uses python-telegram-bot library to handle Telegram API interactions, bot commands, and conversation flows\n- **Data Management Layer**: Custom DataManager class handles all data operations with JSON file persistence\n- **Model Layer**: Object-oriented models (Product, Order, User) provide data structure and validation\n\n## Frontend Architecture\n- **Server-Side Rendering**: Flask templates using Jinja2 for dynamic content generation\n- **Bootstrap Dark Theme**: Modern responsive UI with dark theme specifically designed for admin interfaces\n- **Client-Side JavaScript**: Handles form submissions, AJAX requests, and dynamic UI updates\n- **Font Awesome Icons**: Consistent iconography throughout the interface\n\n## Data Storage Solution\nThe application uses a file-based JSON storage system instead of a traditional database:\n\n- **Products Storage**: Products data stored in `data/products.json` with default sample data\n- **Orders Storage**: Order information persisted in `data/orders.json`\n- **Users Storage**: User data maintained in `data/users.json`\n- **Session Management**: In-memory user sessions for bot interactions with cart and conversation state\n\nThis approach was chosen for simplicity and ease of deployment, avoiding database setup complexity while maintaining data persistence.\n\n## Bot Architecture\n- **Conversation Handler**: Implements state-based conversation flows for checkout process\n- **Session Management**: Per-user session tracking for cart contents and navigation state\n- **Command System**: Structured command handlers for different bot functionalities\n- **Callback Query System**: Inline keyboard interactions for seamless user experience\n\n## Security Considerations\n- **Environment Variables**: Sensitive data like bot tokens stored as environment variables\n- **Session Secrets**: Flask session management with configurable secret keys\n- **Proxy Support**: ProxyFix middleware for proper header handling in deployment environments\n\n# External Dependencies\n\n## Core Framework Dependencies\n- **Flask**: Web framework for admin interface and API endpoints\n- **python-telegram-bot**: Official Telegram Bot API wrapper for bot functionality\n- **Werkzeug**: WSGI utilities including ProxyFix for deployment\n\n## Frontend Dependencies\n- **Bootstrap (CDN)**: UI framework with custom dark theme from Replit CDN\n- **Font Awesome (CDN)**: Icon library for consistent interface elements\n- **JavaScript**: Vanilla JavaScript for client-side interactions\n\n## External Services\n- **Telegram Bot API**: Primary integration for bot functionality requiring BOT_TOKEN\n- **No Database**: System operates without external database dependencies\n- **No Payment Processing**: Basic order management without integrated payment systems\n\n## Environment Configuration\n- **BOT_TOKEN**: Required environment variable for Telegram bot authentication\n- **SESSION_SECRET**: Optional environment variable for Flask session security (defaults to development key)\n\nThe architecture prioritizes simplicity and rapid deployment while maintaining clean separation between the web interface and bot functionality. The JSON-based storage solution eliminates database setup requirements but may need migration to a proper database solution for production scaling.","size_bytes":3982},"support_commands.py":{"content":"\"\"\"\nCustomer support commands and handlers for Telegram bot\n\"\"\"\nimport re\nfrom datetime import datetime\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler, MessageHandler, filters, CallbackQueryHandler, CommandHandler\nfrom telegram.constants import ParseMode\nfrom support_system import CustomerSupportSystem, SupportTicketStatus, SupportTicketPriority, SupportNotifications\nfrom advanced_data_manager import AdvancedDataManager\n\n# Conversation states\nTICKET_SUBJECT, TICKET_MESSAGE, TICKET_PRIORITY, SUPPORT_QUERY = range(4)\n\nclass SupportCommands:\n    def __init__(self, bot_token):\n        self.bot_token = bot_token\n        self.support_system = CustomerSupportSystem()\n        self.data_manager = AdvancedDataManager()\n        self.support_notifications = SupportNotifications()\n    \n    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Main help command\"\"\"\n        help_text = \"\"\"\n‚ùì **Need Help?** \n\nI'm here to assist you! Here's what I can help with:\n\n**Quick Help:**\n‚Ä¢ üõçÔ∏è **Shopping** - Browse products and place orders\n‚Ä¢ üí≥ **Payments** - Payment methods and verification\n‚Ä¢ üöö **Delivery** - Shipping info and tracking\n‚Ä¢ üì¶ **Orders** - Order status and history\n‚Ä¢ üé´ **Support** - Get help or report issues\n\n**How to Get Help:**\n‚Ä¢ Browse FAQs by category\n‚Ä¢ Ask me any question\n‚Ä¢ Create a support ticket\n‚Ä¢ Contact our team directly\n\nWhat would you like help with?\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìö Browse FAQs\", callback_data=\"browse_faqs\")],\n            [InlineKeyboardButton(\"‚ùì Ask a Question\", callback_data=\"ask_question\")],\n            [InlineKeyboardButton(\"üé´ Create Support Ticket\", callback_data=\"create_ticket\")],\n            [InlineKeyboardButton(\"üìû Contact Info\", callback_data=\"contact_info\")],\n            [InlineKeyboardButton(\"üîô Back to Main Menu\", callback_data=\"main_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(help_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def support_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Support ticket management command\"\"\"\n        user_telegram_id = str(update.effective_user.id)\n        user_tickets = self.support_system.get_user_tickets(user_telegram_id)\n        \n        if not user_tickets:\n            text = \"\"\"\nüé´ **Your Support Tickets**\n\nYou don't have any support tickets yet.\n\n**Need Help?**\n‚Ä¢ Browse our FAQ for instant answers\n‚Ä¢ Ask me a question directly  \n‚Ä¢ Create a support ticket for complex issues\n\nHow can I help you today?\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üìö Browse FAQs\", callback_data=\"browse_faqs\")],\n                [InlineKeyboardButton(\"‚ùì Ask Question\", callback_data=\"ask_question\")],\n                [InlineKeyboardButton(\"üé´ Create Ticket\", callback_data=\"create_ticket\")]\n            ]\n        else:\n            text = f\"üé´ **Your Support Tickets ({len(user_tickets)})**\\n\\n\"\n            keyboard = []\n            \n            for ticket in user_tickets[-10:]:  # Show last 10 tickets\n                status_emoji = {\n                    'open': 'üîì',\n                    'in_progress': '‚öôÔ∏è',\n                    'resolved': '‚úÖ',\n                    'closed': 'üîí'\n                }.get(ticket['status'], '‚ùì')\n                \n                priority_emoji = {\n                    'low': 'üü¢',\n                    'medium': 'üü°', \n                    'high': 'üü†',\n                    'urgent': 'üî¥'\n                }.get(ticket['priority'], '‚ö™')\n                \n                text += f\"{status_emoji} **{ticket['ticket_number']}** {priority_emoji}\\n\"\n                text += f\"   {ticket['subject'][:40]}{'...' if len(ticket['subject']) > 40 else ''}\\n\"\n                text += f\"   Status: {ticket['status'].title()} | {ticket['created_at'][:10]}\\n\\n\"\n                \n                keyboard.append([InlineKeyboardButton(\n                    f\"üìÑ {ticket['ticket_number']}\",\n                    callback_data=f\"view_ticket_{ticket['id']}\"\n                )])\n            \n            keyboard.append([InlineKeyboardButton(\"üÜï Create New Ticket\", callback_data=\"create_ticket\")])\n        \n        keyboard.append([InlineKeyboardButton(\"‚ùì Help & FAQs\", callback_data=\"browse_faqs\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def browse_faqs(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show FAQ categories\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        categories = self.support_system.get_faq_categories()\n        \n        text = \"\"\"\nüìö **Frequently Asked Questions**\n\nBrowse by category to find quick answers to common questions:\n        \"\"\"\n        \n        keyboard = []\n        for category in categories:\n            keyboard.append([InlineKeyboardButton(\n                f\"{category['icon']} {category['name']} ({category['question_count']})\",\n                callback_data=f\"faq_category_{category['id']}\"\n            )])\n        \n        keyboard.append([InlineKeyboardButton(\"üîç Search FAQs\", callback_data=\"search_faqs\")])\n        keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"help_menu\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_faq_category(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show FAQs in a specific category\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        category_id = query.data.replace(\"faq_category_\", \"\")\n        category_data = self.support_system.get_category_faqs(category_id)\n        \n        if not category_data:\n            await query.edit_message_text(\"‚ùå Category not found.\")\n            return\n        \n        text = f\"üìö **{category_data['category']}**\\n\\n\"\n        keyboard = []\n        \n        for i, faq in enumerate(category_data['questions']):\n            text += f\"**{i+1}.** {faq['q']}\\n\"\n            keyboard.append([InlineKeyboardButton(\n                f\"üí° {faq['q'][:30]}...\",\n                callback_data=f\"show_faq_{category_id}_{i}\"\n            )])\n        \n        keyboard.append([InlineKeyboardButton(\"üîô Back to Categories\", callback_data=\"browse_faqs\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_faq_answer(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show specific FAQ answer\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        # Parse callback data: show_faq_{category_id}_{faq_index}\n        parts = query.data.split('_')\n        category_id = parts[2]\n        faq_index = int(parts[3])\n        \n        category_data = self.support_system.get_category_faqs(category_id)\n        if not category_data or faq_index >= len(category_data['questions']):\n            await query.edit_message_text(\"‚ùå FAQ not found.\")\n            return\n        \n        faq = category_data['questions'][faq_index]\n        \n        text = f\"üí° **{faq['q']}**\\n\\n{faq['a']}\\n\\n\"\n        text += \"**Was this helpful?**\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üëç Yes\", callback_data=f\"faq_helpful_{category_id}_{faq_index}\"),\n                InlineKeyboardButton(\"üëé No\", callback_data=f\"faq_not_helpful_{category_id}_{faq_index}\")\n            ],\n            [InlineKeyboardButton(\"üé´ Still Need Help\", callback_data=\"create_ticket\")],\n            [InlineKeyboardButton(\"üîô Back to Category\", callback_data=f\"faq_category_{category_id}\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def ask_question(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle direct questions from users\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        text = \"\"\"\n‚ùì **Ask Me Anything!**\n\nType your question below and I'll try to help you instantly:\n\n**Examples:**\n‚Ä¢ \"How do I track my order?\"\n‚Ä¢ \"What payment methods do you accept?\"\n‚Ä¢ \"How long does delivery take?\"\n‚Ä¢ \"Can I change my order?\"\n\n**Tips:**\n‚Ä¢ Be specific about your question\n‚Ä¢ Include order numbers if relevant\n‚Ä¢ Ask one question at a time\n\nWhat's your question?\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìö Browse FAQs Instead\", callback_data=\"browse_faqs\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"help_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return SUPPORT_QUERY\n    \n    async def handle_user_question(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle user's question and provide automated response\"\"\"\n        user_message = update.message.text.strip()\n        user_telegram_id = str(update.effective_user.id)\n        \n        if len(user_message) < 5:\n            await update.message.reply_text(\n                \"‚ùå Please ask a more detailed question (at least 5 characters).\\n\"\n                \"Try again:\"\n            )\n            return SUPPORT_QUERY\n        \n        # Try to auto-respond\n        auto_response = self.support_system.auto_respond_to_query(user_message, user_telegram_id)\n        \n        if auto_response and auto_response['confidence'] == 'high':\n            # High confidence auto-response\n            response_text = f\"\"\"\nü§ñ **I can help with that!**\n\n{auto_response['response']}\n\n**Was this helpful?**\n            \"\"\"\n            \n            keyboard = [\n                [\n                    InlineKeyboardButton(\"üëç Yes, thank you!\", callback_data=\"auto_response_helpful\"),\n                    InlineKeyboardButton(\"üëé Not quite\", callback_data=\"auto_response_not_helpful\")\n                ],\n                [InlineKeyboardButton(\"üé´ Create Support Ticket\", callback_data=\"create_ticket\")],\n                [InlineKeyboardButton(\"‚ùì Ask Another Question\", callback_data=\"ask_question\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await update.message.reply_text(response_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            return ConversationHandler.END\n            \n        elif auto_response and auto_response['confidence'] == 'medium':\n            # Medium confidence - show suggestion\n            response_text = f\"\"\"\nüí≠ **I think this might help:**\n\n{auto_response['response']}\n\n**Is this what you were looking for?**\n            \"\"\"\n            \n            keyboard = [\n                [\n                    InlineKeyboardButton(\"‚úÖ Yes, that helps!\", callback_data=\"auto_response_helpful\"),\n                    InlineKeyboardButton(\"‚ùå No, I need more help\", callback_data=\"need_more_help\")\n                ],\n                [InlineKeyboardButton(\"üé´ Create Support Ticket\", callback_data=\"create_ticket\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await update.message.reply_text(response_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            return ConversationHandler.END\n        \n        else:\n            # No good auto-response found\n            # Search FAQs and show suggestions\n            faq_suggestions = self.support_system.suggest_faqs_for_query(user_message)\n            \n            response_text = \"\"\"\nü§î **I'm not sure about that specific question.**\n\nLet me suggest some related topics that might help:\n            \"\"\"\n            \n            keyboard = []\n            if faq_suggestions:\n                for i, suggestion in enumerate(faq_suggestions):\n                    keyboard.append([InlineKeyboardButton(\n                        f\"üí° {suggestion[:40]}...\",\n                        callback_data=f\"search_faq_{i}\"\n                    )])\n                \n                # Store suggestions in context for callback handling\n                context.user_data['faq_suggestions'] = faq_suggestions\n                context.user_data['user_query'] = user_message\n            \n            keyboard.extend([\n                [InlineKeyboardButton(\"üé´ Create Support Ticket\", callback_data=\"create_ticket\")],\n                [InlineKeyboardButton(\"üìû Contact Human Support\", callback_data=\"contact_info\")],\n                [InlineKeyboardButton(\"‚ùì Try Different Question\", callback_data=\"ask_question\")]\n            ])\n            \n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await update.message.reply_text(response_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            return ConversationHandler.END\n    \n    async def create_support_ticket(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Start support ticket creation\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        text = \"\"\"\nüé´ **Create Support Ticket**\n\nI'll help you create a support ticket for our team to assist you personally.\n\n**Step 1: Subject**\nPlease enter a brief subject/title for your issue:\n\n**Examples:**\n‚Ä¢ \"Payment not confirmed after 24 hours\"\n‚Ä¢ \"Wrong item received in order #12345\"  \n‚Ä¢ \"Cannot access my account\"\n‚Ä¢ \"Delivery address change request\"\n\nWhat's the subject of your ticket?\n        \"\"\"\n        \n        keyboard = [[InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"help_menu\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return TICKET_SUBJECT\n    \n    async def get_ticket_subject(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get ticket subject from user\"\"\"\n        subject = update.message.text.strip()\n        \n        if len(subject) < 5 or len(subject) > 100:\n            await update.message.reply_text(\n                \"‚ùå Subject must be 5-100 characters long. Please try again:\\n\\n\"\n                \"**Examples:**\\n\"\n                \"‚Ä¢ Payment not confirmed\\n\"\n                \"‚Ä¢ Wrong item received\\n\"\n                \"‚Ä¢ Delivery issue\"\n            )\n            return TICKET_SUBJECT\n        \n        context.user_data['ticket_subject'] = subject\n        \n        text = f\"\"\"\n‚úÖ **Subject saved:** {subject}\n\n**Step 2: Detailed Message**\nPlease describe your issue in detail. Include any relevant information:\n\n**Helpful Details:**\n‚Ä¢ Order numbers (if applicable)\n‚Ä¢ Payment reference numbers  \n‚Ä¢ Error messages you received\n‚Ä¢ What you expected vs what happened\n‚Ä¢ Steps you've already tried\n\nThe more details you provide, the faster we can help!\n        \"\"\"\n        \n        keyboard = [[InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"help_menu\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return TICKET_MESSAGE\n    \n    async def get_ticket_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get detailed ticket message\"\"\"\n        message = update.message.text.strip()\n        \n        if len(message) < 20:\n            await update.message.reply_text(\n                \"‚ùå Please provide more details (at least 20 characters).\\n\"\n                \"The more information you provide, the better we can help you!\"\n            )\n            return TICKET_MESSAGE\n        \n        if len(message) > 1000:\n            await update.message.reply_text(\n                \"‚ùå Message is too long (max 1000 characters).\\n\"\n                \"Please summarize your issue:\"\n            )\n            return TICKET_MESSAGE\n        \n        context.user_data['ticket_message'] = message\n        \n        # Show priority selection\n        text = f\"\"\"\n‚úÖ **Message saved!**\n\n**Step 3: Priority Level**\nHow urgent is your issue?\n\n**Priority Levels:**\n‚Ä¢ üü¢ **Low** - General questions, non-urgent\n‚Ä¢ üü° **Medium** - Order issues, account problems  \n‚Ä¢ üü† **High** - Payment issues, wrong orders\n‚Ä¢ üî¥ **Urgent** - Account security, urgent delivery issues\n\n**Your Issue:**\n{context.user_data['ticket_subject']}\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üü¢ Low\", callback_data=\"priority_low\"),\n                InlineKeyboardButton(\"üü° Medium\", callback_data=\"priority_medium\")\n            ],\n            [\n                InlineKeyboardButton(\"üü† High\", callback_data=\"priority_high\"),\n                InlineKeyboardButton(\"üî¥ Urgent\", callback_data=\"priority_urgent\")\n            ],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"help_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return TICKET_PRIORITY\n    \n    async def set_ticket_priority(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Set ticket priority and create ticket\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        priority_map = {\n            \"priority_low\": SupportTicketPriority.LOW,\n            \"priority_medium\": SupportTicketPriority.MEDIUM,\n            \"priority_high\": SupportTicketPriority.HIGH,\n            \"priority_urgent\": SupportTicketPriority.URGENT\n        }\n        \n        priority = priority_map.get(query.data, SupportTicketPriority.MEDIUM)\n        user_telegram_id = str(update.effective_user.id)\n        \n        # Create the support ticket\n        result = self.support_system.create_support_ticket(\n            user_telegram_id=user_telegram_id,\n            subject=context.user_data['ticket_subject'],\n            message=context.user_data['ticket_message'],\n            priority=priority\n        )\n        \n        if result['success']:\n            ticket = result['ticket']\n            \n            success_text = f\"\"\"\nüéâ **Support Ticket Created!**\n\n**Ticket Number:** #{ticket['ticket_number']}\n**Subject:** {ticket['subject']}\n**Priority:** {priority.title()}\n**Status:** Open\n\nüìß **What happens next:**\n‚Ä¢ Our team will review your ticket\n‚Ä¢ You'll receive a response within 24 hours\n‚Ä¢ Updates will be sent to this chat\n‚Ä¢ Use /support to view ticket status\n\n**Response Time:**\n‚Ä¢ üî¥ Urgent: Within 4 hours\n‚Ä¢ üü† High: Within 8 hours  \n‚Ä¢ üü° Medium: Within 24 hours\n‚Ä¢ üü¢ Low: Within 48 hours\n\nThank you for contacting us! We'll help resolve this quickly. ü§ù\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üìÑ View My Tickets\", callback_data=\"view_my_tickets\")],\n                [InlineKeyboardButton(\"‚ùì More Help\", callback_data=\"help_menu\")],\n                [InlineKeyboardButton(\"üè† Main Menu\", callback_data=\"main_menu\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(success_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            \n            # Send notifications\n            await self.support_notifications.notify_ticket_created(user_telegram_id, ticket)\n            await self.support_notifications.notify_admin_new_ticket(ticket)\n            \n        else:\n            await query.edit_message_text(f\"‚ùå **Error creating ticket:**\\n\\n{result['message']}\")\n        \n        # Clear context\n        context.user_data.clear()\n        return ConversationHandler.END\n    \n    async def show_contact_info(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show contact information\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        text = \"\"\"\nüìû **Contact Information**\n\n**Customer Support:**\n‚Ä¢ üìß Email: support@yourstore.com\n‚Ä¢ üì± Phone: +63 (2) 123-4567\n‚Ä¢ üí¨ Live Chat: Available in this bot 24/7\n\n**Business Hours:**\n‚Ä¢ Monday - Friday: 9:00 AM - 6:00 PM\n‚Ä¢ Saturday: 9:00 AM - 5:00 PM  \n‚Ä¢ Sunday: Closed\n\n**Response Times:**\n‚Ä¢ Bot responses: Instant ü§ñ\n‚Ä¢ Live chat: Within 30 minutes ‚ö°\n‚Ä¢ Email/tickets: Within 24 hours üìß\n‚Ä¢ Phone: Immediate during business hours ‚òéÔ∏è\n\n**Emergency Contact:**\nFor urgent order issues outside business hours, create a high-priority support ticket and we'll respond ASAP!\n\n**Social Media:**\n‚Ä¢ Facebook: @YourStore\n‚Ä¢ Instagram: @yourstore_official\n\nWe're here to help make your shopping experience amazing! üåü\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üé´ Create Support Ticket\", callback_data=\"create_ticket\")],\n            [InlineKeyboardButton(\"üìö Browse FAQs\", callback_data=\"browse_faqs\")],\n            [InlineKeyboardButton(\"üîô Back to Help\", callback_data=\"help_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    def _is_admin(self, user_id):\n        \"\"\"Check if user is admin\"\"\"\n        admin_ids = [123456789]  # Replace with actual admin IDs\n        return user_id in admin_ids\n    \n    async def cancel_support_action(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Cancel support action\"\"\"\n        if update.callback_query:\n            await update.callback_query.edit_message_text(\"‚ùå Action cancelled.\")\n        else:\n            await update.message.reply_text(\"‚ùå Action cancelled.\")\n        \n        context.user_data.clear()\n        return ConversationHandler.END\n\nclass AdminSupportCommands:\n    \"\"\"Admin commands for managing support system\"\"\"\n    \n    def __init__(self):\n        self.support_system = CustomerSupportSystem()\n        self.data_manager = AdvancedDataManager()\n    \n    async def admin_support_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show support management menu for admins\"\"\"\n        user_id = update.effective_user.id\n        \n        # Check admin permissions  \n        if not self._is_admin(user_id):\n            await update.message.reply_text(\"‚ùå Access denied. Admin privileges required.\")\n            return\n        \n        # Get support analytics\n        analytics = self.support_system.get_support_analytics()\n        pending_tickets = self.support_system.get_pending_tickets()\n        \n        menu_text = f\"\"\"\nüé´ **Support Management**\n\n**Current Status:**\n‚Ä¢ Open Tickets: {len(pending_tickets)}\n‚Ä¢ Total Tickets: {analytics['total_tickets']}\n‚Ä¢ Resolution Rate: {analytics['resolution_rate']:.1f}%\n‚Ä¢ Avg Response Time: {analytics['avg_response_time']}\n\n**Recent Activity:**\n‚Ä¢ New Tickets (7 days): {analytics['recent_tickets']}\n\n**Quick Actions:**\n‚Ä¢ Review pending tickets\n‚Ä¢ Manage FAQ database\n‚Ä¢ View support analytics\n‚Ä¢ Update quick responses\n\nChoose an option below:\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(f\"üîì Open Tickets ({len(pending_tickets)})\", callback_data=\"admin_open_tickets\")],\n            [InlineKeyboardButton(\"üìä Support Analytics\", callback_data=\"admin_support_analytics\")],\n            [InlineKeyboardButton(\"üìö Manage FAQs\", callback_data=\"admin_manage_faqs\")],\n            [InlineKeyboardButton(\"‚öôÔ∏è Support Settings\", callback_data=\"admin_support_settings\")],\n            [InlineKeyboardButton(\"üîô Back to Admin\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(menu_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    def _is_admin(self, user_id):\n        \"\"\"Check if user is admin\"\"\"\n        admin_ids = [123456789]  # Replace with actual admin IDs\n        return user_id in admin_ids\n\ndef get_support_conversation_handler(bot_token):\n    \"\"\"Get conversation handler for support system\"\"\"\n    support_commands = SupportCommands(bot_token)\n    \n    return ConversationHandler(\n        entry_points=[\n            CallbackQueryHandler(support_commands.create_support_ticket, pattern=\"^create_ticket$\"),\n            CallbackQueryHandler(support_commands.ask_question, pattern=\"^ask_question$\")\n        ],\n        states={\n            TICKET_SUBJECT: [MessageHandler(filters.TEXT & ~filters.COMMAND, support_commands.get_ticket_subject)],\n            TICKET_MESSAGE: [MessageHandler(filters.TEXT & ~filters.COMMAND, support_commands.get_ticket_message)],\n            TICKET_PRIORITY: [CallbackQueryHandler(support_commands.set_ticket_priority, pattern=\"^priority_\")],\n            SUPPORT_QUERY: [MessageHandler(filters.TEXT & ~filters.COMMAND, support_commands.handle_user_question)]\n        },\n        fallbacks=[\n            CallbackQueryHandler(support_commands.cancel_support_action, pattern=\"^help_menu$\"),\n            CommandHandler('cancel', support_commands.cancel_support_action)\n        ],\n        per_message=False\n    )","size_bytes":25626},"support_system.py":{"content":"\"\"\"\nCustomer Support System\nHandles FAQs, help commands, support tickets, and automated assistance\n\"\"\"\nimport re\nimport uuid\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Tuple\nfrom advanced_data_manager import AdvancedDataManager\n\nclass SupportTicketStatus:\n    OPEN = \"open\"\n    IN_PROGRESS = \"in_progress\"\n    RESOLVED = \"resolved\"\n    CLOSED = \"closed\"\n\nclass SupportTicketPriority:\n    LOW = \"low\"\n    MEDIUM = \"medium\"\n    HIGH = \"high\"\n    URGENT = \"urgent\"\n\nclass CustomerSupportSystem:\n    def __init__(self):\n        self.data_manager = AdvancedDataManager()\n        self.faqs = self._load_default_faqs()\n        self.quick_responses = self._load_quick_responses()\n    \n    def _load_default_faqs(self) -> Dict:\n        \"\"\"Load default FAQ categories and questions\"\"\"\n        return {\n            \"ordering\": {\n                \"category\": \"üì¶ Orders & Shopping\",\n                \"icon\": \"üì¶\",\n                \"questions\": [\n                    {\n                        \"q\": \"How do I place an order?\",\n                        \"a\": \"\"\"\n**Placing an order is easy!** üõçÔ∏è\n\n1. Browse our catalog by tapping 'Browse Products'\n2. Tap on items to view details\n3. Click 'Add to Cart' for items you want\n4. Go to your cart and review items\n5. Proceed to checkout\n6. Choose your payment method\n7. Complete payment and wait for confirmation\n\nNeed help with any step? Just ask! üòä\n                        \"\"\",\n                        \"keywords\": [\"order\", \"place order\", \"buy\", \"purchase\", \"how to order\"]\n                    },\n                    {\n                        \"q\": \"Can I modify or cancel my order?\",\n                        \"a\": \"\"\"\n**Order Changes & Cancellations** ‚úèÔ∏è\n\n**Before Payment:**\n‚Ä¢ You can modify or cancel freely\n‚Ä¢ Just go back to your cart and make changes\n\n**After Payment (within 1 hour):**\n‚Ä¢ Contact us immediately for changes\n‚Ä¢ We'll try our best to accommodate\n\n**After Processing:**\n‚Ä¢ Orders being prepared cannot be modified\n‚Ä¢ Cancellation may incur fees\n‚Ä¢ Contact support for assistance\n\n**Need help?** Use our support chat anytime! üí¨\n                        \"\"\",\n                        \"keywords\": [\"modify order\", \"cancel order\", \"change order\", \"edit order\"]\n                    },\n                    {\n                        \"q\": \"How can I track my order?\",\n                        \"a\": \"\"\"\n**Order Tracking** üìç\n\n**To track your order:**\n1. Tap 'My Orders' from the main menu\n2. Find your order and tap 'Track'\n3. View real-time status updates\n\n**Order Status Meanings:**\n‚Ä¢ üîÑ **Processing** - We're preparing your order\n‚Ä¢ üì¶ **Packed** - Ready for pickup by courier\n‚Ä¢ üöö **Shipped** - On the way to you\n‚Ä¢ ‚úÖ **Delivered** - Successfully delivered\n\n**Delivery Time:**\n‚Ä¢ Metro Manila: 1-2 business days\n‚Ä¢ Provincial: 2-5 business days\n\nQuestions? We're here to help! ü§ù\n                        \"\"\",\n                        \"keywords\": [\"track\", \"tracking\", \"where is my order\", \"delivery\", \"shipping\"]\n                    }\n                ]\n            },\n            \"payments\": {\n                \"category\": \"üí≥ Payments & Billing\",\n                \"icon\": \"üí≥\",\n                \"questions\": [\n                    {\n                        \"q\": \"What payment methods do you accept?\",\n                        \"a\": \"\"\"\n**Payment Methods We Accept** üí≥\n\n**Digital Wallets:**\n‚Ä¢ üì± GCash\n‚Ä¢ üí≥ PayMaya\n\n**Bank Transfer:**\n‚Ä¢ üè¶ Direct bank transfer\n‚Ä¢ All major Philippine banks\n\n**Cash Payment:**\n‚Ä¢ üíµ Cash on Delivery (COD)\n‚Ä¢ ‚Ç±50 COD fee applies\n\n**Payment is Safe & Secure:**\n‚Ä¢ All transactions are encrypted\n‚Ä¢ Your financial data is protected\n‚Ä¢ Payment confirmation within 24 hours\n\nReady to pay? Choose what's convenient for you! ‚úÖ\n                        \"\"\",\n                        \"keywords\": [\"payment\", \"pay\", \"gcash\", \"paymaya\", \"bank\", \"cod\", \"cash on delivery\"]\n                    },\n                    {\n                        \"q\": \"How long does payment verification take?\",\n                        \"a\": \"\"\"\n**Payment Verification Times** ‚è∞\n\n**Automatic (Instant):**\n‚Ä¢ Cash on Delivery orders\n‚Ä¢ Some supported payment methods\n\n**Manual Verification:**\n‚Ä¢ GCash/PayMaya: 1-24 hours\n‚Ä¢ Bank Transfer: 1-24 hours\n‚Ä¢ Peak times may take longer\n\n**To Speed Up Verification:**\n‚Ä¢ Upload clear payment receipt\n‚Ä¢ Include correct reference number\n‚Ä¢ Send during business hours (9 AM - 6 PM)\n\n**Payment Confirmed?**\nYou'll get a notification immediately when verified! üéâ\n\n**Questions?** Our support team is always ready to help! üí¨\n                        \"\"\",\n                        \"keywords\": [\"verification\", \"verify payment\", \"how long\", \"payment confirmation\"]\n                    }\n                ]\n            },\n            \"shipping\": {\n                \"category\": \"üöö Shipping & Delivery\",\n                \"icon\": \"üöö\",\n                \"questions\": [\n                    {\n                        \"q\": \"What are your delivery areas and rates?\",\n                        \"a\": \"\"\"\n**Delivery Coverage & Rates** üöö\n\n**Metro Manila:**\n‚Ä¢ Delivery: ‚Ç±80-120\n‚Ä¢ Time: 1-2 business days\n‚Ä¢ Free delivery on orders over ‚Ç±1,500\n\n**Luzon:**\n‚Ä¢ Delivery: ‚Ç±120-200\n‚Ä¢ Time: 2-4 business days\n‚Ä¢ Free delivery on orders over ‚Ç±2,000\n\n**Visayas & Mindanao:**\n‚Ä¢ Delivery: ‚Ç±150-300\n‚Ä¢ Time: 3-5 business days\n‚Ä¢ Free delivery on orders over ‚Ç±2,500\n\n**Special Areas:**\n‚Ä¢ Remote locations may have additional fees\n‚Ä¢ Contact us for specific rates\n\n**Free Delivery Promos Available!** üéâ\nCheck our current promotions for free shipping deals!\n                        \"\"\",\n                        \"keywords\": [\"delivery\", \"shipping\", \"rates\", \"areas\", \"coverage\", \"free delivery\"]\n                    },\n                    {\n                        \"q\": \"What if I'm not available during delivery?\",\n                        \"a\": \"\"\"\n**Missed Delivery? No Problem!** üì¶\n\n**Our Delivery Process:**\n‚Ä¢ Courier will call you before delivery\n‚Ä¢ You can reschedule if not available\n‚Ä¢ Safe drop-off options available\n\n**Rescheduling:**\n‚Ä¢ Free reschedule within 3 days\n‚Ä¢ Just contact the courier directly\n‚Ä¢ Or message us for assistance\n\n**Alternative Recipients:**\n‚Ä¢ You can authorize someone else\n‚Ä¢ Just inform us beforehand\n‚Ä¢ Valid ID required for verification\n\n**Delivery Attempts:**\n‚Ä¢ We try 3 times to deliver\n‚Ä¢ After that, item returns to warehouse\n‚Ä¢ Reshipping fee may apply\n\n**Need to reschedule?** Contact us anytime! üìû\n                        \"\"\",\n                        \"keywords\": [\"missed delivery\", \"reschedule\", \"not available\", \"alternative recipient\"]\n                    }\n                ]\n            },\n            \"account\": {\n                \"category\": \"üë§ Account & Profile\",\n                \"icon\": \"üë§\", \n                \"questions\": [\n                    {\n                        \"q\": \"How do I update my delivery address?\",\n                        \"a\": \"\"\"\n**Update Delivery Address** üìç\n\n**For Future Orders:**\n‚Ä¢ Tap 'Profile' or 'Account Settings'\n‚Ä¢ Select 'Delivery Address'\n‚Ä¢ Add or edit your addresses\n‚Ä¢ Set a default address\n\n**For Current Orders:**\n‚Ä¢ Contact us immediately if not yet shipped\n‚Ä¢ Address changes after shipping not possible\n‚Ä¢ We'll help redirect if possible\n\n**Multiple Addresses:**\n‚Ä¢ Save home, office, and other addresses\n‚Ä¢ Choose different address per order\n‚Ä¢ Label addresses for easy selection\n\n**Address Format:**\nPlease include complete details:\n‚Ä¢ Full name of recipient\n‚Ä¢ Complete address with landmarks\n‚Ä¢ Contact number\n‚Ä¢ Special delivery instructions\n\nNeed help updating? We're here! ü§ù\n                        \"\"\",\n                        \"keywords\": [\"address\", \"delivery address\", \"update address\", \"change address\"]\n                    }\n                ]\n            },\n            \"general\": {\n                \"category\": \"‚ùì General Information\",\n                \"icon\": \"‚ùì\",\n                \"questions\": [\n                    {\n                        \"q\": \"What are your business hours?\",\n                        \"a\": \"\"\"\n**Business Hours** üïê\n\n**Customer Support:**\n‚Ä¢ Monday - Friday: 9:00 AM - 6:00 PM\n‚Ä¢ Saturday: 9:00 AM - 5:00 PM\n‚Ä¢ Sunday: Closed\n\n**Order Processing:**\n‚Ä¢ Monday - Friday: Orders processed daily\n‚Ä¢ Saturday: Limited processing\n‚Ä¢ Sunday: No processing (orders queue for Monday)\n\n**Payment Verification:**\n‚Ä¢ Automated: 24/7\n‚Ä¢ Manual verification: Business hours only\n\n**Bot Available 24/7!** ü§ñ\nThis bot is always here to help you shop, even outside business hours!\n\n**Need Urgent Help?**\nFor urgent concerns outside business hours, send a message and we'll respond first thing in the morning! üåÖ\n                        \"\"\",\n                        \"keywords\": [\"hours\", \"business hours\", \"operating hours\", \"when open\"]\n                    },\n                    {\n                        \"q\": \"Do you offer returns and exchanges?\",\n                        \"a\": \"\"\"\n**Returns & Exchange Policy** üîÑ\n\n**Return Period:**\n‚Ä¢ 7 days from delivery\n‚Ä¢ Items must be unused and in original packaging\n‚Ä¢ Return shipping fee applies\n\n**What Can Be Returned:**\n‚úÖ Defective or damaged items\n‚úÖ Wrong items sent\n‚úÖ Items not as described\n\n**What Cannot Be Returned:**\n‚ùå Used or opened items (unless defective)\n‚ùå Custom/personalized items\n‚ùå Items damaged by customer\n\n**Return Process:**\n1. Contact support within 7 days\n2. Provide photos if claiming defect\n3. Get return authorization number\n4. Ship item back (or we'll arrange pickup)\n5. Refund processed after inspection\n\n**Exchanges:**\n‚Ä¢ Available for size/color variations\n‚Ä¢ Subject to stock availability\n‚Ä¢ Same return period applies\n\n**Questions about returns?** Contact our support team! üí¨\n                        \"\"\",\n                        \"keywords\": [\"return\", \"exchange\", \"refund\", \"defective\", \"wrong item\"]\n                    }\n                ]\n            }\n        }\n    \n    def _load_quick_responses(self) -> Dict:\n        \"\"\"Load quick response templates\"\"\"\n        return {\n            \"greeting\": [\n                \"üëã Hi there! How can I help you today?\",\n                \"Hello! üòä What can I assist you with?\",\n                \"Hey! Thanks for reaching out. What's up?\",\n                \"Hi! I'm here to help. What do you need?\"\n            ],\n            \"order_status\": \"To check your order status, please use the 'My Orders' option from the main menu or provide me your order number.\",\n            \"payment_issue\": \"I understand payment issues can be frustrating. Let me help you resolve this quickly. Can you provide your payment reference number?\",\n            \"delivery_delay\": \"I apologize for any delivery delays. Let me check the status of your order and provide you with an update.\",\n            \"product_inquiry\": \"I'd be happy to help you with product information! Which item are you interested in?\",\n            \"contact_human\": \"I'll connect you with our human support team. They'll get back to you within a few hours during business hours.\",\n            \"thank_you\": [\n                \"Thank you! Is there anything else I can help you with? üòä\",\n                \"You're welcome! Let me know if you need anything else!\",\n                \"Glad I could help! Feel free to ask if you have more questions.\",\n                \"Anytime! I'm here whenever you need assistance! ü§ù\"\n            ]\n        }\n    \n    def search_faq(self, query: str, limit: int = 5) -> List[Dict]:\n        \"\"\"Search FAQ based on user query\"\"\"\n        query_lower = query.lower()\n        results = []\n        \n        for category_id, category_data in self.faqs.items():\n            for faq in category_data[\"questions\"]:\n                # Check if query matches question, answer, or keywords\n                score = 0\n                \n                # Check question title\n                if query_lower in faq[\"q\"].lower():\n                    score += 10\n                \n                # Check keywords\n                for keyword in faq[\"keywords\"]:\n                    if keyword.lower() in query_lower or query_lower in keyword.lower():\n                        score += 5\n                \n                # Check answer content (lower weight)\n                if query_lower in faq[\"a\"].lower():\n                    score += 2\n                \n                if score > 0:\n                    results.append({\n                        \"category\": category_data[\"category\"],\n                        \"category_id\": category_id,\n                        \"question\": faq[\"q\"],\n                        \"answer\": faq[\"a\"],\n                        \"score\": score,\n                        \"keywords\": faq[\"keywords\"]\n                    })\n        \n        # Sort by relevance score and return top results\n        results.sort(key=lambda x: x[\"score\"], reverse=True)\n        return results[:limit]\n    \n    def get_faq_categories(self) -> List[Dict]:\n        \"\"\"Get all FAQ categories\"\"\"\n        categories = []\n        for category_id, category_data in self.faqs.items():\n            categories.append({\n                \"id\": category_id,\n                \"name\": category_data[\"category\"],\n                \"icon\": category_data[\"icon\"],\n                \"question_count\": len(category_data[\"questions\"])\n            })\n        return categories\n    \n    def get_category_faqs(self, category_id: str) -> Optional[Dict]:\n        \"\"\"Get all FAQs in a specific category\"\"\"\n        return self.faqs.get(category_id)\n    \n    def create_support_ticket(self, \n                            user_telegram_id: str,\n                            subject: str,\n                            message: str,\n                            priority: str = SupportTicketPriority.MEDIUM,\n                            category: str = \"general\") -> Dict:\n        \"\"\"Create a new support ticket\"\"\"\n        \n        try:\n            # Generate ticket number\n            ticket_number = f\"TK{datetime.utcnow().strftime('%Y%m%d')}{uuid.uuid4().hex[:6].upper()}\"\n            \n            # Create ticket record\n            ticket = self.data_manager.create_support_ticket(\n                user_telegram_id=user_telegram_id,\n                ticket_number=ticket_number,\n                subject=subject,\n                message=message,\n                priority=priority,\n                category=category\n            )\n            \n            if ticket:\n                return {\n                    'success': True,\n                    'ticket': ticket,\n                    'message': f'Support ticket #{ticket_number} created successfully'\n                }\n            else:\n                return {\n                    'success': False,\n                    'message': 'Failed to create support ticket'\n                }\n                \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error creating support ticket: {str(e)}'\n            }\n    \n    def get_user_tickets(self, user_telegram_id: str) -> List[Dict]:\n        \"\"\"Get all tickets for a user\"\"\"\n        return self.data_manager.get_support_tickets(user_telegram_id=user_telegram_id)\n    \n    def get_pending_tickets(self) -> List[Dict]:\n        \"\"\"Get all pending support tickets for admin\"\"\"\n        return self.data_manager.get_support_tickets(status=SupportTicketStatus.OPEN)\n    \n    def respond_to_ticket(self, ticket_id: int, response: str, admin_user: str) -> Dict:\n        \"\"\"Add admin response to support ticket\"\"\"\n        \n        try:\n            result = self.data_manager.add_ticket_response(\n                ticket_id=ticket_id,\n                response=response,\n                admin_user=admin_user\n            )\n            \n            if result:\n                return {\n                    'success': True,\n                    'message': 'Response added successfully'\n                }\n            else:\n                return {\n                    'success': False,\n                    'message': 'Failed to add response'\n                }\n                \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error adding response: {str(e)}'\n            }\n    \n    def update_ticket_status(self, ticket_id: int, status: str, admin_user: str) -> Dict:\n        \"\"\"Update support ticket status\"\"\"\n        \n        valid_statuses = [\n            SupportTicketStatus.OPEN,\n            SupportTicketStatus.IN_PROGRESS,\n            SupportTicketStatus.RESOLVED,\n            SupportTicketStatus.CLOSED\n        ]\n        \n        if status not in valid_statuses:\n            return {\n                'success': False,\n                'message': f'Invalid status. Must be one of: {\", \".join(valid_statuses)}'\n            }\n        \n        try:\n            result = self.data_manager.update_ticket_status(\n                ticket_id=ticket_id,\n                status=status,\n                updated_by=admin_user\n            )\n            \n            if result:\n                return {\n                    'success': True,\n                    'message': f'Ticket status updated to {status}'\n                }\n            else:\n                return {\n                    'success': False,\n                    'message': 'Failed to update ticket status'\n                }\n                \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error updating status: {str(e)}'\n            }\n    \n    def get_support_analytics(self) -> Dict:\n        \"\"\"Get support system analytics\"\"\"\n        \n        all_tickets = self.data_manager.get_support_tickets()\n        \n        # Calculate stats\n        total_tickets = len(all_tickets)\n        open_tickets = [t for t in all_tickets if t['status'] == SupportTicketStatus.OPEN]\n        resolved_tickets = [t for t in all_tickets if t['status'] == SupportTicketStatus.RESOLVED]\n        \n        # Category breakdown\n        category_stats = {}\n        priority_stats = {}\n        \n        for ticket in all_tickets:\n            category = ticket.get('category', 'general')\n            priority = ticket.get('priority', 'medium')\n            \n            category_stats[category] = category_stats.get(category, 0) + 1\n            priority_stats[priority] = priority_stats.get(priority, 0) + 1\n        \n        # Recent activity (last 7 days)\n        week_ago = datetime.utcnow() - timedelta(days=7)\n        recent_tickets = [\n            t for t in all_tickets\n            if datetime.fromisoformat(t['created_at']) >= week_ago\n        ]\n        \n        # Response time analysis (simplified)\n        avg_response_time = \"< 24 hours\"  # Would calculate from actual data\n        \n        return {\n            'total_tickets': total_tickets,\n            'open_tickets': len(open_tickets),\n            'resolved_tickets': len(resolved_tickets),\n            'resolution_rate': (len(resolved_tickets) / total_tickets * 100) if total_tickets > 0 else 0,\n            'recent_tickets': len(recent_tickets),\n            'category_breakdown': category_stats,\n            'priority_breakdown': priority_stats,\n            'avg_response_time': avg_response_time\n        }\n    \n    def auto_respond_to_query(self, user_message: str, user_telegram_id: str) -> Optional[Dict]:\n        \"\"\"Attempt to automatically respond to common queries\"\"\"\n        \n        message_lower = user_message.lower()\n        \n        # Define patterns and responses\n        auto_responses = {\n            # Greeting patterns\n            r'\\b(hi|hello|hey|good morning|good afternoon|good evening)\\b': {\n                'response_type': 'greeting',\n                'confidence': 'high'\n            },\n            \n            # Order status patterns  \n            r'\\b(order status|track|tracking|where.*order|order.*status)\\b': {\n                'response_type': 'order_status',\n                'confidence': 'high'\n            },\n            \n            # Payment patterns\n            r'\\b(payment|pay|gcash|paymaya|bank transfer|cod|cash on delivery)\\b': {\n                'response_type': 'payment_issue',\n                'confidence': 'medium'\n            },\n            \n            # Delivery patterns\n            r'\\b(delivery|shipping|deliver|when.*arrive|how long)\\b': {\n                'response_type': 'delivery_delay',\n                'confidence': 'medium'\n            },\n            \n            # Product inquiry patterns\n            r'\\b(product|item|available|stock|price|cost|how much)\\b': {\n                'response_type': 'product_inquiry',\n                'confidence': 'medium'\n            },\n            \n            # Human support patterns\n            r'\\b(human|agent|representative|talk to|speak to|contact|help me)\\b': {\n                'response_type': 'contact_human',\n                'confidence': 'high'\n            }\n        }\n        \n        # Check for pattern matches\n        for pattern, response_info in auto_responses.items():\n            if re.search(pattern, message_lower):\n                response_text = self._get_response_text(response_info['response_type'])\n                \n                return {\n                    'auto_response': True,\n                    'response': response_text,\n                    'confidence': response_info['confidence'],\n                    'type': response_info['response_type']\n                }\n        \n        # Try FAQ search if no pattern match\n        faq_results = self.search_faq(user_message, limit=1)\n        if faq_results and faq_results[0]['score'] > 5:\n            return {\n                'auto_response': True,\n                'response': f\"I found this information that might help:\\n\\n**{faq_results[0]['question']}**\\n\\n{faq_results[0]['answer']}\",\n                'confidence': 'medium',\n                'type': 'faq_match',\n                'faq_result': faq_results[0]\n            }\n        \n        return None\n    \n    def _get_response_text(self, response_type: str) -> str:\n        \"\"\"Get response text for auto-response type\"\"\"\n        \n        quick_response = self.quick_responses.get(response_type)\n        \n        if isinstance(quick_response, list):\n            import random\n            return random.choice(quick_response)\n        elif isinstance(quick_response, str):\n            return quick_response\n        else:\n            return \"I'm here to help! How can I assist you today?\"\n    \n    def add_custom_faq(self, category: str, question: str, answer: str, keywords: List[str]) -> Dict:\n        \"\"\"Add custom FAQ (admin function)\"\"\"\n        \n        if category not in self.faqs:\n            return {\n                'success': False,\n                'message': f'Invalid category. Available: {\", \".join(self.faqs.keys())}'\n            }\n        \n        if len(question) < 5 or len(answer) < 10:\n            return {\n                'success': False,\n                'message': 'Question must be at least 5 characters, answer at least 10 characters'\n            }\n        \n        try:\n            # Add to FAQ database (in real implementation, save to database)\n            new_faq = {\n                'q': question,\n                'a': answer,\n                'keywords': keywords\n            }\n            \n            self.faqs[category]['questions'].append(new_faq)\n            \n            return {\n                'success': True,\n                'message': 'FAQ added successfully',\n                'faq': new_faq\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error adding FAQ: {str(e)}'\n            }\n    \n    def suggest_faqs_for_query(self, query: str) -> List[str]:\n        \"\"\"Suggest FAQ questions that might help with the query\"\"\"\n        results = self.search_faq(query, limit=3)\n        return [result['question'] for result in results]\n\nclass SupportNotifications:\n    \"\"\"Handle support-related notifications\"\"\"\n    \n    def __init__(self, broadcast_system=None):\n        self.broadcast_system = broadcast_system\n        self.support_system = CustomerSupportSystem()\n    \n    async def notify_ticket_created(self, user_telegram_id: str, ticket: Dict):\n        \"\"\"Notify user that their support ticket was created\"\"\"\n        try:\n            from telegram import Bot\n            import os\n            bot = Bot(token=os.environ.get('BOT_TOKEN'))\n            \n            message = f\"\"\"\nüé´ **Support Ticket Created**\n\n**Ticket #:** {ticket['ticket_number']}\n**Subject:** {ticket['subject']}\n**Priority:** {ticket['priority'].title()}\n**Status:** Open\n\nüìã **Your Message:**\n{ticket['message'][:200]}{'...' if len(ticket['message']) > 200 else ''}\n\n‚è∞ **Response Time:**\nOur team will respond within 24 hours during business hours.\n\nüîç **Track Your Ticket:**\nUse /support to view all your tickets and responses.\n\nThank you for contacting us! ü§ù\n            \"\"\"\n            \n            await bot.send_message(\n                chat_id=user_telegram_id,\n                text=message,\n                parse_mode='Markdown'\n            )\n            \n            return True\n            \n        except Exception as e:\n            print(f\"Error sending ticket notification: {e}\")\n            return False\n    \n    async def notify_admin_new_ticket(self, ticket: Dict):\n        \"\"\"Notify admin about new support ticket\"\"\"\n        # This would send to admin channel or specific admin users\n        admin_message = f\"\"\"\nüÜò **New Support Ticket**\n\n**Ticket:** {ticket['ticket_number']}\n**User:** {ticket['user_id']}\n**Priority:** {ticket['priority'].upper()}\n**Category:** {ticket['category']}\n\n**Subject:** {ticket['subject']}\n\n**Message:**\n{ticket['message']}\n\n**Created:** {ticket['created_at']}\n\nPlease respond promptly to maintain customer satisfaction.\n        \"\"\"\n        \n        # Implementation would send to admin notification system\n        print(f\"Admin notification: {admin_message}\")\n        return True\n    \n    async def notify_ticket_response(self, user_telegram_id: str, ticket: Dict, response: str):\n        \"\"\"Notify user about response to their ticket\"\"\"\n        try:\n            from telegram import Bot\n            import os\n            bot = Bot(token=os.environ.get('BOT_TOKEN'))\n            \n            message = f\"\"\"\nüí¨ **New Response to Your Ticket**\n\n**Ticket #:** {ticket['ticket_number']}\n**Subject:** {ticket['subject']}\n**Status:** {ticket['status'].title()}\n\n**Our Response:**\n{response}\n\nüé´ **Need More Help?**\nReply to this ticket or create a new one if you need additional assistance.\n\nUse /support to view your ticket history.\n\nThanks for your patience! üòä\n            \"\"\"\n            \n            await bot.send_message(\n                chat_id=user_telegram_id,\n                text=message,\n                parse_mode='Markdown'\n            )\n            \n            return True\n            \n        except Exception as e:\n            print(f\"Error sending response notification: {e}\")\n            return False","size_bytes":27098},"test_bot.py":{"content":"#!/usr/bin/env python3\n\"\"\"\nSimple test script to run the Telegram bot in polling mode for testing\n\"\"\"\nimport os\nimport asyncio\nfrom bot import TelegramStoreBot\nfrom data_manager import DataManager\n\nasync def main():\n    bot_token = os.environ.get(\"BOT_TOKEN\")\n    if not bot_token:\n        print(\"BOT_TOKEN environment variable not set!\")\n        return\n    \n    data_manager = DataManager()\n    bot = TelegramStoreBot(bot_token, data_manager)\n    \n    print(\"Starting bot in polling mode...\")\n    print(\"The bot will now respond to messages on Telegram!\")\n    print(\"Send /start to your bot to test it.\")\n    print(\"Press Ctrl+C to stop the bot.\")\n    \n    # Run in polling mode\n    await bot.application.run_polling()\n\nif __name__ == \"__main__\":\n    asyncio.run(main())","size_bytes":771},"voucher_commands.py":{"content":"\"\"\"\nAdmin voucher management commands for Telegram bot\n\"\"\"\nfrom datetime import datetime, timedelta\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler, MessageHandler, filters, CallbackQueryHandler\nfrom telegram.constants import ParseMode\nfrom voucher_system import VoucherSystem, VoucherTemplates\nfrom advanced_data_manager import AdvancedDataManager\n\n# Conversation states\nVOUCHER_NAME, VOUCHER_TYPE, VOUCHER_VALUE, VOUCHER_CODE, VOUCHER_DETAILS, VOUCHER_EXPIRY = range(6)\n\nclass VoucherCommands:\n    def __init__(self):\n        self.voucher_system = VoucherSystem()\n        self.voucher_templates = VoucherTemplates()\n        self.data_manager = AdvancedDataManager()\n    \n    async def admin_voucher_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show voucher management menu\"\"\"\n        user_id = update.effective_user.id\n        \n        # Check admin permissions\n        if not self._is_admin(user_id):\n            await update.message.reply_text(\"‚ùå Access denied. Admin privileges required.\")\n            return\n        \n        # Get voucher stats\n        active_vouchers = self.voucher_system.get_active_vouchers()\n        all_vouchers = self.voucher_system.get_all_vouchers()\n        \n        menu_text = f\"\"\"\nüé´ **Voucher Management**\n\n**Current Status:**\n‚Ä¢ Active Vouchers: {len(active_vouchers)}\n‚Ä¢ Total Vouchers: {len(all_vouchers)}\n\n**What you can do:**\n‚Ä¢ Create discount codes\n‚Ä¢ Set expiry dates and usage limits\n‚Ä¢ Target specific customer groups\n‚Ä¢ Track voucher usage and savings\n\n**Voucher Types:**\n‚Ä¢ Percentage discounts (e.g., 20% off)\n‚Ä¢ Fixed amount discounts (e.g., $10 off)\n‚Ä¢ Free shipping vouchers\n‚Ä¢ Minimum order requirements\n\nChoose an option below:\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚ûï Create New Voucher\", callback_data=\"create_voucher\")],\n            [InlineKeyboardButton(\"üìã View All Vouchers\", callback_data=\"view_vouchers\")],\n            [InlineKeyboardButton(\"‚ö° Quick Templates\", callback_data=\"voucher_templates\")],\n            [InlineKeyboardButton(\"üìä Voucher Analytics\", callback_data=\"voucher_analytics\")],\n            [InlineKeyboardButton(\"üîô Back to Admin\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(menu_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def start_create_voucher(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Start voucher creation process\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        context.user_data['voucher_data'] = {}\n        \n        text = \"\"\"\n‚ûï **Create New Voucher**\n\nLet's create a discount code for your customers!\n\n**Step 1: Voucher Name**\nEnter a name for this voucher (for your reference):\n\n*Example: \"Summer Sale\", \"Welcome Discount\", \"Flash Deal\"*\n        \"\"\"\n        \n        keyboard = [[InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"voucher_menu\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return VOUCHER_NAME\n    \n    async def get_voucher_name(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get voucher name\"\"\"\n        name = update.message.text.strip()\n        if len(name) < 3 or len(name) > 50:\n            await update.message.reply_text(\"‚ùå Name must be 3-50 characters long. Please try again:\")\n            return VOUCHER_NAME\n        \n        context.user_data['voucher_data']['name'] = name\n        \n        text = \"\"\"\n‚úÖ **Name saved!**\n\n**Step 2: Discount Type**\nWhat type of discount do you want to offer?\n\n**Options:**\n‚Ä¢ **Percentage** - Give % off (e.g., 20% off)\n‚Ä¢ **Fixed Amount** - Give $ off (e.g., $10 off)\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìä Percentage Discount\", callback_data=\"type_percentage\")],\n            [InlineKeyboardButton(\"üí∞ Fixed Amount Discount\", callback_data=\"type_fixed\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"voucher_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return VOUCHER_TYPE\n    \n    async def get_voucher_type(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get voucher discount type\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        if query.data == \"type_percentage\":\n            context.user_data['voucher_data']['discount_type'] = 'percentage'\n            prompt = \"\"\"\n‚úÖ **Percentage discount selected!**\n\n**Step 3: Discount Value**\nEnter the percentage discount (1-100):\n\n*Example: Enter \"20\" for 20% off*\n            \"\"\"\n        elif query.data == \"type_fixed\":\n            context.user_data['voucher_data']['discount_type'] = 'fixed_amount'\n            prompt = \"\"\"\n‚úÖ **Fixed amount discount selected!**\n\n**Step 3: Discount Value**\nEnter the dollar amount discount:\n\n*Example: Enter \"10\" for $10 off or \"25.50\" for $25.50 off*\n            \"\"\"\n        else:\n            return VOUCHER_TYPE\n        \n        keyboard = [[InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"voucher_menu\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(prompt, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return VOUCHER_VALUE\n    \n    async def get_voucher_value(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get voucher discount value\"\"\"\n        try:\n            value = float(update.message.text.strip())\n            discount_type = context.user_data['voucher_data']['discount_type']\n            \n            # Validate value\n            if discount_type == 'percentage':\n                if not 1 <= value <= 100:\n                    await update.message.reply_text(\"‚ùå Percentage must be between 1-100. Please try again:\")\n                    return VOUCHER_VALUE\n            else:  # fixed_amount\n                if value <= 0:\n                    await update.message.reply_text(\"‚ùå Amount must be greater than 0. Please try again:\")\n                    return VOUCHER_VALUE\n                if value > 1000:\n                    await update.message.reply_text(\"‚ùå Amount seems too high. Maximum is $1000. Please try again:\")\n                    return VOUCHER_VALUE\n            \n            context.user_data['voucher_data']['discount_value'] = value\n            \n            # Show confirmation and move to code input\n            if discount_type == 'percentage':\n                discount_text = f\"{value}% OFF\"\n            else:\n                discount_text = f\"${value:.2f} OFF\"\n            \n            text = f\"\"\"\n‚úÖ **Discount set to {discount_text}!**\n\n**Step 4: Voucher Code**\nEnter a custom code or let me generate one:\n\n**Options:**\n‚Ä¢ Type a custom code (3-20 characters, letters/numbers only)\n‚Ä¢ Click \"Auto Generate\" for a random code\n\n*Example codes: SAVE20, WELCOME10, FLASH50*\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üé≤ Auto Generate Code\", callback_data=\"auto_generate_code\")],\n                [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"voucher_menu\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            return VOUCHER_CODE\n            \n        except ValueError:\n            await update.message.reply_text(\"‚ùå Please enter a valid number:\")\n            return VOUCHER_VALUE\n    \n    async def get_voucher_code(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get or generate voucher code\"\"\"\n        if update.message:\n            # Custom code entered\n            code = update.message.text.strip().upper()\n            \n            # Validate code format\n            import re\n            if not re.match(r'^[A-Z0-9]{3,20}$', code):\n                await update.message.reply_text(\n                    \"‚ùå Invalid code format. Use 3-20 characters, letters and numbers only.\\n\"\n                    \"Please try again:\"\n                )\n                return VOUCHER_CODE\n            \n            # Check if code exists\n            if self.voucher_system._code_exists(code):\n                await update.message.reply_text(\n                    f\"‚ùå Code '{code}' already exists. Please choose a different code:\"\n                )\n                return VOUCHER_CODE\n            \n            context.user_data['voucher_data']['code'] = code\n            \n        elif update.callback_query and update.callback_query.data == \"auto_generate_code\":\n            # Auto-generate code\n            await update.callback_query.answer()\n            code = self.voucher_system._generate_voucher_code()\n            context.user_data['voucher_data']['code'] = code\n        \n        return await self.show_voucher_details_form(update, context)\n    \n    async def show_voucher_details_form(self, update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show form for additional voucher details\"\"\"\n        voucher_data = context.user_data['voucher_data']\n        \n        text = f\"\"\"\n‚úÖ **Code set to: {voucher_data['code']}**\n\n**Step 5: Additional Details (Optional)**\n\nSet optional restrictions and details:\n\n**Current Settings:**\n‚Ä¢ Minimum Order: No minimum\n‚Ä¢ Usage Limit: Unlimited\n‚Ä¢ Expiry: Never expires\n‚Ä¢ Description: None\n\nWould you like to add any restrictions?\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üí∞ Set Minimum Order\", callback_data=\"set_minimum_order\")],\n            [InlineKeyboardButton(\"üî¢ Set Usage Limit\", callback_data=\"set_usage_limit\")],\n            [InlineKeyboardButton(\"‚è∞ Set Expiry Date\", callback_data=\"set_expiry\")],\n            [InlineKeyboardButton(\"üìù Add Description\", callback_data=\"set_description\")],\n            [InlineKeyboardButton(\"‚úÖ Create Voucher\", callback_data=\"create_voucher_final\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"voucher_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        if update.callback_query:\n            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        return VOUCHER_DETAILS\n    \n    async def handle_voucher_details(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle voucher detail settings\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        if query.data == \"create_voucher_final\":\n            return await self.create_voucher_final(update, context)\n        elif query.data == \"set_minimum_order\":\n            text = \"\"\"\nüí∞ **Set Minimum Order Amount**\n\nEnter the minimum order amount required to use this voucher:\n\n*Example: Enter \"50\" to require at least $50 order*\n*Enter \"0\" for no minimum*\n            \"\"\"\n            keyboard = [[InlineKeyboardButton(\"üîô Back\", callback_data=\"voucher_details_back\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            context.user_data['setting_field'] = 'minimum_order'\n            return VOUCHER_DETAILS\n            \n        elif query.data == \"set_usage_limit\":\n            text = \"\"\"\nüî¢ **Set Usage Limit**\n\nHow many times can this voucher be used?\n\n*Example: Enter \"100\" to limit to 100 uses*\n*Enter \"0\" for unlimited uses*\n            \"\"\"\n            keyboard = [[InlineKeyboardButton(\"üîô Back\", callback_data=\"voucher_details_back\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            context.user_data['setting_field'] = 'usage_limit'\n            return VOUCHER_DETAILS\n            \n        elif query.data == \"set_expiry\":\n            text = \"\"\"\n‚è∞ **Set Expiry Date**\n\nWhen should this voucher expire?\n\n**Options:**\n‚Ä¢ Enter days from now (e.g., \"30\" for 30 days)\n‚Ä¢ Enter \"0\" to never expire\n            \"\"\"\n            keyboard = [\n                [InlineKeyboardButton(\"üìÖ 7 Days\", callback_data=\"expiry_7\")],\n                [InlineKeyboardButton(\"üìÖ 30 Days\", callback_data=\"expiry_30\")],\n                [InlineKeyboardButton(\"üìÖ 90 Days\", callback_data=\"expiry_90\")],\n                [InlineKeyboardButton(\"‚ôæÔ∏è Never Expire\", callback_data=\"expiry_never\")],\n                [InlineKeyboardButton(\"üîô Back\", callback_data=\"voucher_details_back\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            return VOUCHER_EXPIRY\n            \n        elif query.data == \"set_description\":\n            text = \"\"\"\nüìù **Add Description**\n\nEnter a description for this voucher (will be shown to customers):\n\n*Example: \"Special weekend discount for loyal customers!\"*\n            \"\"\"\n            keyboard = [[InlineKeyboardButton(\"üîô Back\", callback_data=\"voucher_details_back\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            context.user_data['setting_field'] = 'description'\n            return VOUCHER_DETAILS\n        \n        return VOUCHER_DETAILS\n    \n    async def handle_expiry_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle expiry date selection\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        expiry_map = {\n            \"expiry_7\": 7,\n            \"expiry_30\": 30,\n            \"expiry_90\": 90,\n            \"expiry_never\": 0\n        }\n        \n        days = expiry_map.get(query.data, 0)\n        if days > 0:\n            expiry_date = datetime.utcnow() + timedelta(days=days)\n            context.user_data['voucher_data']['valid_until'] = expiry_date\n        else:\n            context.user_data['voucher_data']['valid_until'] = None\n        \n        return await self.show_voucher_details_form(query, context)\n    \n    async def create_voucher_final(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Create the voucher with all settings\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        voucher_data = context.user_data['voucher_data']\n        \n        # Create voucher\n        result = self.voucher_system.create_voucher(\n            name=voucher_data['name'],\n            discount_type=voucher_data['discount_type'],\n            discount_value=voucher_data['discount_value'],\n            code=voucher_data['code'],\n            description=voucher_data.get('description', ''),\n            minimum_order=voucher_data.get('minimum_order', 0),\n            usage_limit=voucher_data.get('usage_limit', 0),\n            valid_until=voucher_data.get('valid_until')\n        )\n        \n        if result['success']:\n            voucher = result['voucher']\n            \n            # Format success message\n            if voucher['discount_type'] == 'percentage':\n                discount_text = f\"{voucher['discount_value']}% OFF\"\n            else:\n                discount_text = f\"${voucher['discount_value']:.2f} OFF\"\n            \n            success_text = f\"\"\"\nüéâ **Voucher Created Successfully!**\n\nüé´ **Code:** `{voucher['code']}`\nüí∞ **Discount:** {discount_text}\nüìù **Name:** {voucher['name']}\nüíµ **Minimum Order:** ${voucher['minimum_order']:.2f}\nüî¢ **Usage Limit:** {voucher['usage_limit'] if voucher['usage_limit'] > 0 else 'Unlimited'}\n‚è∞ **Expires:** {voucher['valid_until'][:10] if voucher['valid_until'] else 'Never'}\n\n‚úÖ Your voucher is now active and ready to use!\n\n**Next Steps:**\n‚Ä¢ Share the code with customers\n‚Ä¢ Send a broadcast announcement\n‚Ä¢ Track usage in analytics\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üì¢ Broadcast This Voucher\", callback_data=f\"broadcast_voucher_{voucher['id']}\")],\n                [InlineKeyboardButton(\"üìã View All Vouchers\", callback_data=\"view_vouchers\")],\n                [InlineKeyboardButton(\"‚ûï Create Another\", callback_data=\"create_voucher\")],\n                [InlineKeyboardButton(\"üîô Back to Menu\", callback_data=\"voucher_menu\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(success_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            \n        else:\n            await query.edit_message_text(f\"‚ùå **Error creating voucher:**\\n\\n{result['message']}\")\n        \n        # Clear user data\n        context.user_data.clear()\n        return ConversationHandler.END\n    \n    async def view_vouchers(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"View all vouchers\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        vouchers = self.voucher_system.get_all_vouchers()\n        \n        if not vouchers:\n            text = \"\"\"\nüì≠ **No vouchers found**\n\nYou haven't created any voucher codes yet.\n\nReady to create your first discount code?\n            \"\"\"\n            keyboard = [\n                [InlineKeyboardButton(\"‚ûï Create First Voucher\", callback_data=\"create_voucher\")],\n                [InlineKeyboardButton(\"üîô Back\", callback_data=\"voucher_menu\")]\n            ]\n        else:\n            text = f\"üìã **All Vouchers ({len(vouchers)})**\\n\\n\"\n            keyboard = []\n            \n            # Sort by creation date (newest first)\n            vouchers.sort(key=lambda x: x['created_at'], reverse=True)\n            \n            for voucher in vouchers[:10]:  # Show first 10\n                # Status emoji\n                if not voucher['is_active']:\n                    status_emoji = \"‚ùå\"\n                elif voucher['valid_until'] and datetime.fromisoformat(voucher['valid_until']) <= datetime.utcnow():\n                    status_emoji = \"‚è∞\"\n                elif voucher['usage_limit'] > 0 and voucher['usage_count'] >= voucher['usage_limit']:\n                    status_emoji = \"üîí\"\n                else:\n                    status_emoji = \"‚úÖ\"\n                \n                # Discount text\n                if voucher['discount_type'] == 'percentage':\n                    discount = f\"{voucher['discount_value']}%\"\n                else:\n                    discount = f\"${voucher['discount_value']:.2f}\"\n                \n                text += f\"{status_emoji} **{voucher['code']}** - {discount} off\\n\"\n                text += f\"   Used: {voucher['usage_count']}\"\n                if voucher['usage_limit'] > 0:\n                    text += f\"/{voucher['usage_limit']}\"\n                text += f\" | Expires: {voucher['valid_until'][:10] if voucher['valid_until'] else 'Never'}\\n\\n\"\n                \n                keyboard.append([InlineKeyboardButton(\n                    f\"üìä {voucher['code']} Details\",\n                    callback_data=f\"voucher_details_{voucher['id']}\"\n                )])\n            \n            if len(vouchers) > 10:\n                text += f\"*... and {len(vouchers) - 10} more vouchers*\"\n            \n            keyboard.append([InlineKeyboardButton(\"‚ûï Create New\", callback_data=\"create_voucher\")])\n        \n        keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"voucher_menu\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_voucher_templates(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show quick voucher templates\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        text = \"\"\"\n‚ö° **Quick Voucher Templates**\n\nCreate common voucher types instantly:\n\n**Popular Templates:**\n‚Ä¢ Weekend Special - Limited time discount\n‚Ä¢ Welcome Discount - New customer offer\n‚Ä¢ Flash Sale - High discount, short time\n‚Ä¢ Free Shipping - Remove delivery cost\n‚Ä¢ Bulk Order - Discount for large orders\n\nChoose a template to create instantly:\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üéâ Weekend Special (20% OFF)\", callback_data=\"template_weekend\")],\n            [InlineKeyboardButton(\"üëã Welcome Discount (10% OFF)\", callback_data=\"template_welcome\")],\n            [InlineKeyboardButton(\"‚ö° Flash Sale (30% OFF)\", callback_data=\"template_flash\")],\n            [InlineKeyboardButton(\"üöö Free Shipping ($10 OFF)\", callback_data=\"template_shipping\")],\n            [InlineKeyboardButton(\"üì¶ Bulk Order (25% OFF)\", callback_data=\"template_bulk\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"voucher_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def create_template_voucher(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Create voucher from template\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        template_map = {\n            \"template_weekend\": self.voucher_templates.create_weekend_special,\n            \"template_welcome\": self.voucher_templates.create_welcome_voucher, \n            \"template_flash\": lambda: self.voucher_system.create_flash_sale_voucher(30, 24, 50),\n            \"template_shipping\": self.voucher_templates.create_free_shipping_voucher,\n            \"template_bulk\": self.voucher_templates.create_bulk_order_discount\n        }\n        \n        template_func = template_map.get(query.data)\n        if not template_func:\n            await query.edit_message_text(\"‚ùå Template not found\")\n            return\n        \n        await query.edit_message_text(\"üîÑ **Creating voucher from template...**\")\n        \n        try:\n            result = template_func()\n            \n            if result['success']:\n                voucher = result['voucher']\n                \n                if voucher['discount_type'] == 'percentage':\n                    discount_text = f\"{voucher['discount_value']}% OFF\"\n                else:\n                    discount_text = f\"${voucher['discount_value']:.2f} OFF\"\n                \n                success_text = f\"\"\"\n‚úÖ **Template Voucher Created!**\n\nüé´ **Code:** `{voucher['code']}`\nüí∞ **Discount:** {discount_text}\nüìù **Name:** {voucher['name']}\nüìã **Description:** {voucher['description']}\n\nYour voucher is ready to use!\n                \"\"\"\n                \n                keyboard = [\n                    [InlineKeyboardButton(\"üì¢ Broadcast This Voucher\", callback_data=f\"broadcast_voucher_{voucher['id']}\")],\n                    [InlineKeyboardButton(\"üìã View All Vouchers\", callback_data=\"view_vouchers\")],\n                    [InlineKeyboardButton(\"‚ö° More Templates\", callback_data=\"voucher_templates\")],\n                    [InlineKeyboardButton(\"üîô Back\", callback_data=\"voucher_menu\")]\n                ]\n                reply_markup = InlineKeyboardMarkup(keyboard)\n                \n                await query.edit_message_text(success_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n                \n            else:\n                await query.edit_message_text(f\"‚ùå **Error creating voucher:**\\n\\n{result['message']}\")\n        \n        except Exception as e:\n            await query.edit_message_text(f\"‚ùå **Error creating template voucher:**\\n\\n{str(e)}\")\n    \n    def _is_admin(self, user_id):\n        \"\"\"Check if user is admin\"\"\"\n        # Implement your admin check logic\n        admin_ids = [123456789]  # Replace with actual admin IDs\n        return user_id in admin_ids\n    \n    async def cancel_voucher_creation(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Cancel voucher creation\"\"\"\n        if update.callback_query:\n            await update.callback_query.edit_message_text(\"‚ùå Voucher creation cancelled.\")\n        else:\n            await update.message.reply_text(\"‚ùå Voucher creation cancelled.\")\n        \n        context.user_data.clear()\n        return ConversationHandler.END\n\ndef get_voucher_conversation_handler():\n    \"\"\"Get conversation handler for voucher creation\"\"\"\n    voucher_commands = VoucherCommands()\n    \n    return ConversationHandler(\n        entry_points=[CallbackQueryHandler(voucher_commands.start_create_voucher, pattern=\"^create_voucher$\")],\n        states={\n            VOUCHER_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, voucher_commands.get_voucher_name)],\n            VOUCHER_TYPE: [CallbackQueryHandler(voucher_commands.get_voucher_type, pattern=\"^type_\")],\n            VOUCHER_VALUE: [MessageHandler(filters.TEXT & ~filters.COMMAND, voucher_commands.get_voucher_value)],\n            VOUCHER_CODE: [\n                MessageHandler(filters.TEXT & ~filters.COMMAND, voucher_commands.get_voucher_code),\n                CallbackQueryHandler(voucher_commands.get_voucher_code, pattern=\"^auto_generate_code$\")\n            ],\n            VOUCHER_DETAILS: [\n                CallbackQueryHandler(voucher_commands.handle_voucher_details, pattern=\"^(create_voucher_final|set_|voucher_details_back)\"),\n                MessageHandler(filters.TEXT & ~filters.COMMAND, voucher_commands.get_voucher_name)  # Handle text input for details\n            ],\n            VOUCHER_EXPIRY: [CallbackQueryHandler(voucher_commands.handle_expiry_selection, pattern=\"^expiry_\")]\n        },\n        fallbacks=[\n            CallbackQueryHandler(voucher_commands.cancel_voucher_creation, pattern=\"^voucher_menu$\"),\n            CommandHandler('cancel', voucher_commands.cancel_voucher_creation)\n        ],\n        per_message=False\n    )","size_bytes":26345},"voucher_system.py":{"content":"\"\"\"\nVoucher and Discount Code System\nHandles creation, validation, and application of discount codes\n\"\"\"\nimport re\nimport secrets\nimport string\nfrom datetime import datetime, timedelta\nfrom advanced_data_manager import AdvancedDataManager\n\nclass VoucherSystem:\n    def __init__(self):\n        self.data_manager = AdvancedDataManager()\n    \n    def create_voucher(self, \n                      name, \n                      discount_type, \n                      discount_value, \n                      code=None, \n                      description=\"\", \n                      minimum_order=0.0, \n                      maximum_discount=0.0,\n                      usage_limit=0, \n                      valid_days=None, \n                      valid_until=None):\n        \"\"\"\n        Create a new voucher/discount code\n        \n        Args:\n            name: Display name for the voucher\n            discount_type: 'percentage' or 'fixed_amount'\n            discount_value: Percentage (0-100) or fixed amount\n            code: Custom code or auto-generated if None\n            description: Description of the offer\n            minimum_order: Minimum order amount to apply discount\n            maximum_discount: Maximum discount amount (for percentage discounts)\n            usage_limit: Max number of uses (0 = unlimited)\n            valid_days: Number of days valid from creation\n            valid_until: Specific expiry date\n        \"\"\"\n        \n        # Generate code if not provided\n        if not code:\n            code = self._generate_voucher_code()\n        else:\n            code = code.upper().strip()\n            \n        # Validate code format\n        if not self._validate_code_format(code):\n            return {\n                'success': False,\n                'message': 'Invalid code format. Use 3-20 characters, letters and numbers only.'\n            }\n        \n        # Check if code already exists\n        if self._code_exists(code):\n            return {\n                'success': False,\n                'message': f'Voucher code \"{code}\" already exists.'\n            }\n        \n        # Validate discount value\n        if discount_type == 'percentage':\n            if not 0 < discount_value <= 100:\n                return {\n                    'success': False,\n                    'message': 'Percentage discount must be between 1-100.'\n                }\n        else:  # fixed_amount\n            if discount_value <= 0:\n                return {\n                    'success': False,\n                    'message': 'Fixed discount amount must be greater than 0.'\n                }\n        \n        # Calculate expiry date\n        valid_until_date = None\n        if valid_until:\n            valid_until_date = valid_until\n        elif valid_days:\n            valid_until_date = datetime.utcnow() + timedelta(days=valid_days)\n        \n        # Create voucher\n        try:\n            voucher = self.data_manager.create_voucher(\n                code=code,\n                name=name,\n                description=description,\n                discount_type=discount_type,\n                discount_value=discount_value,\n                minimum_order=minimum_order,\n                maximum_discount=maximum_discount,\n                usage_limit=usage_limit,\n                valid_until=valid_until_date\n            )\n            \n            return {\n                'success': True,\n                'voucher': voucher,\n                'message': f'Voucher \"{code}\" created successfully!'\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error creating voucher: {str(e)}'\n            }\n    \n    def validate_and_apply_voucher(self, voucher_code, order_total, user_telegram_id=None):\n        \"\"\"\n        Validate voucher code and calculate discount\n        \n        Returns:\n            dict with validation result and discount information\n        \"\"\"\n        \n        if not voucher_code or not voucher_code.strip():\n            return {\n                'valid': False,\n                'message': 'Please enter a voucher code.'\n            }\n        \n        code = voucher_code.upper().strip()\n        \n        # Validate with data manager\n        result = self.data_manager.validate_voucher(code, order_total)\n        \n        if not result['valid']:\n            # Check specific reasons for better user feedback\n            vouchers = self.data_manager.get_vouchers()\n            voucher = next((v for v in vouchers if v['code'] == code), None)\n            \n            if not voucher:\n                return {\n                    'valid': False,\n                    'message': f'Voucher code \"{code}\" not found. Please check and try again.'\n                }\n            elif not voucher['is_active']:\n                return {\n                    'valid': False,\n                    'message': 'This voucher code is no longer active.'\n                }\n            elif voucher['valid_until'] and datetime.fromisoformat(voucher['valid_until']) <= datetime.utcnow():\n                return {\n                    'valid': False,\n                    'message': 'This voucher code has expired.'\n                }\n            elif order_total < voucher['minimum_order']:\n                return {\n                    'valid': False,\n                    'message': f'Minimum order of ${voucher[\"minimum_order\"]:.2f} required for this voucher.'\n                }\n            elif voucher['usage_limit'] > 0 and voucher['usage_count'] >= voucher['usage_limit']:\n                return {\n                    'valid': False,\n                    'message': 'This voucher code has reached its usage limit.'\n                }\n            else:\n                return result\n        \n        # Valid voucher - return discount info\n        voucher = result['voucher']\n        discount_amount = result['discount_amount']\n        \n        # Format discount description\n        if voucher['discount_type'] == 'percentage':\n            discount_text = f\"{voucher['discount_value']}% OFF\"\n        else:\n            discount_text = f\"${voucher['discount_value']:.2f} OFF\"\n        \n        return {\n            'valid': True,\n            'voucher_code': code,\n            'voucher_name': voucher['name'],\n            'discount_amount': discount_amount,\n            'discount_text': discount_text,\n            'final_total': max(0, order_total - discount_amount),\n            'message': f'‚úÖ Voucher applied! You save ${discount_amount:.2f}'\n        }\n    \n    def get_voucher_by_code(self, code):\n        \"\"\"Get voucher details by code\"\"\"\n        vouchers = self.data_manager.get_vouchers()\n        return next((v for v in vouchers if v['code'] == code.upper()), None)\n    \n    def get_active_vouchers(self):\n        \"\"\"Get all active vouchers\"\"\"\n        return self.data_manager.get_vouchers(is_active=True)\n    \n    def get_all_vouchers(self):\n        \"\"\"Get all vouchers\"\"\"\n        return self.data_manager.get_vouchers()\n    \n    def deactivate_voucher(self, voucher_id):\n        \"\"\"Deactivate a voucher\"\"\"\n        try:\n            # Update voucher status (you'd need to add this method to data manager)\n            # For now, we'll mark it as inactive\n            return {\n                'success': True,\n                'message': 'Voucher deactivated successfully.'\n            }\n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error deactivating voucher: {str(e)}'\n            }\n    \n    def get_voucher_usage_stats(self, voucher_id=None):\n        \"\"\"Get voucher usage statistics\"\"\"\n        if voucher_id:\n            vouchers = [v for v in self.data_manager.get_vouchers() if v['id'] == voucher_id]\n        else:\n            vouchers = self.data_manager.get_vouchers()\n        \n        stats = []\n        for voucher in vouchers:\n            # Calculate usage rate\n            usage_rate = 0\n            if voucher['usage_limit'] > 0:\n                usage_rate = (voucher['usage_count'] / voucher['usage_limit']) * 100\n            \n            # Calculate total savings provided\n            if voucher['discount_type'] == 'percentage':\n                # This would require order history analysis for exact calculation\n                estimated_savings = voucher['usage_count'] * voucher['discount_value']\n            else:\n                estimated_savings = voucher['usage_count'] * voucher['discount_value']\n            \n            stats.append({\n                'voucher_id': voucher['id'],\n                'code': voucher['code'],\n                'name': voucher['name'],\n                'usage_count': voucher['usage_count'],\n                'usage_limit': voucher['usage_limit'],\n                'usage_rate': usage_rate,\n                'estimated_savings': estimated_savings,\n                'is_active': voucher['is_active'],\n                'expires': voucher['valid_until']\n            })\n        \n        return stats\n    \n    def create_bulk_vouchers(self, base_name, count, discount_type, discount_value, **kwargs):\n        \"\"\"Create multiple vouchers at once\"\"\"\n        results = []\n        \n        for i in range(count):\n            code = self._generate_voucher_code()\n            name = f\"{base_name} #{i+1}\"\n            \n            result = self.create_voucher(\n                name=name,\n                discount_type=discount_type,\n                discount_value=discount_value,\n                code=code,\n                **kwargs\n            )\n            \n            results.append({\n                'code': code,\n                'success': result['success'],\n                'message': result['message']\n            })\n        \n        successful = sum(1 for r in results if r['success'])\n        \n        return {\n            'total_created': successful,\n            'total_failed': count - successful,\n            'results': results\n        }\n    \n    def create_flash_sale_voucher(self, discount_percentage, hours_valid=24, usage_limit=100):\n        \"\"\"Create a flash sale voucher with time limit\"\"\"\n        code = f\"FLASH{secrets.token_hex(3).upper()}\"\n        valid_until = datetime.utcnow() + timedelta(hours=hours_valid)\n        \n        return self.create_voucher(\n            name=f\"Flash Sale {discount_percentage}% OFF\",\n            discount_type='percentage',\n            discount_value=discount_percentage,\n            code=code,\n            description=f\"Limited time {discount_percentage}% discount - {hours_valid} hours only!\",\n            usage_limit=usage_limit,\n            valid_until=valid_until\n        )\n    \n    def create_welcome_voucher(self, new_customer_discount=10):\n        \"\"\"Create a welcome voucher for new customers\"\"\"\n        code = f\"WELCOME{secrets.token_hex(2).upper()}\"\n        valid_until = datetime.utcnow() + timedelta(days=30)\n        \n        return self.create_voucher(\n            name=\"New Customer Welcome\",\n            discount_type='percentage',\n            discount_value=new_customer_discount,\n            code=code,\n            description=f\"Welcome! Enjoy {new_customer_discount}% off your first order!\",\n            minimum_order=50.0,\n            usage_limit=1,\n            valid_until=valid_until\n        )\n    \n    def create_loyalty_voucher(self, customer_telegram_id, discount_value=15):\n        \"\"\"Create a loyalty voucher for returning customers\"\"\"\n        code = f\"LOYAL{secrets.token_hex(3).upper()}\"\n        valid_until = datetime.utcnow() + timedelta(days=14)\n        \n        return self.create_voucher(\n            name=\"Loyalty Reward\",\n            discount_type='percentage', \n            discount_value=discount_value,\n            code=code,\n            description=f\"Thank you for being a loyal customer! {discount_value}% off your order!\",\n            usage_limit=1,\n            valid_until=valid_until\n        )\n    \n    def _generate_voucher_code(self, length=8):\n        \"\"\"Generate a random voucher code\"\"\"\n        # Use a mix of letters and numbers, avoiding confusing characters\n        chars = string.ascii_uppercase + string.digits\n        chars = chars.replace('0', '').replace('O', '').replace('I', '').replace('1')\n        \n        return ''.join(secrets.choice(chars) for _ in range(length))\n    \n    def _validate_code_format(self, code):\n        \"\"\"Validate voucher code format\"\"\"\n        # Allow 3-20 characters, letters and numbers only\n        return bool(re.match(r'^[A-Z0-9]{3,20}$', code))\n    \n    def _code_exists(self, code):\n        \"\"\"Check if voucher code already exists\"\"\"\n        existing = self.data_manager.get_vouchers()\n        return any(v['code'] == code.upper() for v in existing)\n\nclass VoucherNotifications:\n    \"\"\"Handle voucher-related notifications\"\"\"\n    \n    def __init__(self, broadcast_system):\n        self.broadcast_system = broadcast_system\n        self.voucher_system = VoucherSystem()\n    \n    async def notify_flash_sale(self, voucher_code, discount_percentage, hours_remaining):\n        \"\"\"Send flash sale notification\"\"\"\n        title = f\"‚ö° FLASH SALE: {discount_percentage}% OFF!\"\n        message = f\"\"\"\nüî• **LIMITED TIME OFFER!** üî•\n\nüí• Get **{discount_percentage}% OFF** your entire order!\n\nüé´ **Code:** `{voucher_code}`\n‚è∞ **Time Left:** {hours_remaining} hours only!\nüõçÔ∏è **Valid on:** All products\n\n‚ö° **Act fast** - This offer expires soon!\n\nUse /start to shop now and save big! üöÄ\n        \"\"\"\n        \n        return await self.broadcast_system.send_promo_announcement(\n            title=title,\n            message=message,\n            voucher_code=voucher_code\n        )\n    \n    async def notify_new_voucher(self, voucher_code, discount_text, description):\n        \"\"\"Send notification about new voucher\"\"\"\n        title = f\"üé´ New Voucher: {discount_text}\"\n        message = f\"\"\"\nüéâ **NEW DISCOUNT CODE AVAILABLE!** üéâ\n\nüé´ **Code:** `{voucher_code}`\nüí∞ **Discount:** {discount_text}\nüìù **Details:** {description}\n\nüõçÔ∏è Ready to save? Use /start to shop!\n\n*Tap the code above to copy it!* üìã\n        \"\"\"\n        \n        return await self.broadcast_system.send_promo_announcement(\n            title=title,\n            message=message,\n            voucher_code=voucher_code\n        )\n    \n    async def notify_voucher_expiring(self, voucher_code, discount_text, days_left):\n        \"\"\"Send notification about expiring voucher\"\"\"\n        title = f\"‚è∞ Voucher Expiring: {voucher_code}\"\n        message = f\"\"\"\n‚ö†Ô∏è **VOUCHER EXPIRING SOON!** ‚ö†Ô∏è\n\nüé´ **Code:** `{voucher_code}`\nüí∞ **Discount:** {discount_text}\n‚è∞ **Expires in:** {days_left} day{'s' if days_left != 1 else ''}\n\nüèÉ‚Äç‚ôÇÔ∏è **Don't miss out!** Use it before it expires!\n\nUse /start to shop now! üõçÔ∏è\n        \"\"\"\n        \n        return await self.broadcast_system.send_promo_announcement(\n            title=title,\n            message=message,\n            voucher_code=voucher_code\n        )\n\n# Quick voucher templates\nclass VoucherTemplates:\n    \"\"\"Pre-made voucher templates for common scenarios\"\"\"\n    \n    def __init__(self):\n        self.voucher_system = VoucherSystem()\n    \n    def create_weekend_special(self, discount=20):\n        \"\"\"Weekend special voucher\"\"\"\n        return self.voucher_system.create_voucher(\n            name=\"Weekend Special\",\n            discount_type='percentage',\n            discount_value=discount,\n            description=f\"Weekend Special: {discount}% off all orders!\",\n            valid_days=3,  # Valid for 3 days\n            usage_limit=200\n        )\n    \n    def create_free_shipping_voucher(self, minimum_order=75):\n        \"\"\"Free shipping voucher\"\"\"\n        return self.voucher_system.create_voucher(\n            name=\"Free Shipping\",\n            discount_type='fixed_amount',\n            discount_value=10.00,  # Assume $10 shipping cost\n            description=f\"Free shipping on orders over ${minimum_order}!\",\n            minimum_order=minimum_order,\n            valid_days=30,\n            usage_limit=500\n        )\n    \n    def create_bulk_order_discount(self, minimum_order=200, discount=25):\n        \"\"\"Bulk order discount\"\"\"\n        return self.voucher_system.create_voucher(\n            name=\"Bulk Order Discount\",\n            discount_type='percentage',\n            discount_value=discount,\n            description=f\"Save {discount}% on orders over ${minimum_order}!\",\n            minimum_order=minimum_order,\n            valid_days=14\n        )\n    \n    def create_clearance_sale(self, discount=40):\n        \"\"\"Clearance sale voucher\"\"\"\n        return self.voucher_system.create_voucher(\n            name=\"Clearance Sale\",\n            discount_type='percentage',\n            discount_value=discount,\n            description=f\"Clearance Sale: {discount}% off selected items!\",\n            valid_days=7,\n            usage_limit=100\n        )\n    \n    def create_birthday_special(self, discount=15):\n        \"\"\"Birthday special voucher\"\"\"\n        return self.voucher_system.create_voucher(\n            name=\"Birthday Special\",\n            discount_type='percentage',\n            discount_value=discount,\n            description=f\"Happy Birthday! Enjoy {discount}% off as our gift to you!\",\n            valid_days=7,\n            usage_limit=1\n        )","size_bytes":17238},"welcome_commands.py":{"content":"\"\"\"\nAdmin commands for managing welcome messages\n\"\"\"\nimport json\nfrom datetime import datetime, timedelta\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler, MessageHandler, filters, CallbackQueryHandler\nfrom telegram.constants import ParseMode\nfrom welcome_system import WelcomeMessageSystem, WelcomeMessageVariables\nfrom advanced_data_manager import AdvancedDataManager\n\n# Conversation states\nWELCOME_TYPE, WELCOME_TEMPLATE, WELCOME_MESSAGE, WELCOME_BUTTONS, WELCOME_CONFIRM = range(5)\n\nclass WelcomeCommands:\n    def __init__(self):\n        self.welcome_system = WelcomeMessageSystem()\n        self.data_manager = AdvancedDataManager()\n    \n    async def admin_welcome_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show welcome message management menu\"\"\"\n        user_id = update.effective_user.id\n        \n        # Check admin permissions\n        if not self._is_admin(user_id):\n            await update.message.reply_text(\"‚ùå Access denied. Admin privileges required.\")\n            return\n        \n        # Get analytics\n        analytics = self.welcome_system.get_welcome_analytics()\n        \n        menu_text = f\"\"\"\nüëã **Welcome Message Management**\n\n**User Statistics:**\n‚Ä¢ Total Users: {analytics['total_users']}\n‚Ä¢ New Users: {analytics['new_users']}\n‚Ä¢ Returning Users: {analytics['returning_users']}\n‚Ä¢ VIP Users: {analytics['vip_users']}\n‚Ä¢ Conversion Rate: {analytics['conversion_rate']:.1f}%\n\n**Customize Experience:**\n‚Ä¢ Personalize first impressions\n‚Ä¢ Set different messages for user types\n‚Ä¢ Use dynamic variables\n‚Ä¢ Track effectiveness\n\nChoose what to customize:\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚ú® Customize Welcome Messages\", callback_data=\"customize_welcome\")],\n            [InlineKeyboardButton(\"üé® Choose Templates\", callback_data=\"welcome_templates\")],\n            [InlineKeyboardButton(\"üß™ Test Messages\", callback_data=\"test_welcome\")],\n            [InlineKeyboardButton(\"üìä View Analytics\", callback_data=\"welcome_analytics\")],\n            [InlineKeyboardButton(\"üîô Back to Admin\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(menu_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_customize_welcome(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show welcome customization options\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        text = \"\"\"\n‚ú® **Customize Welcome Messages**\n\nYou can create different welcome experiences for different types of customers:\n\n**User Types:**\n‚Ä¢ üÜï **New Users** - First-time visitors\n‚Ä¢ üîÑ **Returning Users** - Customers who've shopped before  \n‚Ä¢ üëë **VIP Users** - High-value customers\n\n**Features:**\n‚Ä¢ Use personalization variables\n‚Ä¢ Custom buttons and actions\n‚Ä¢ Dynamic content based on user data\n‚Ä¢ Professional templates or create from scratch\n\nWhich user type would you like to customize?\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üÜï New Users\", callback_data=\"customize_new_user\")],\n            [InlineKeyboardButton(\"üîÑ Returning Users\", callback_data=\"customize_returning\")],\n            [InlineKeyboardButton(\"üëë VIP Users\", callback_data=\"customize_vip\")],\n            [InlineKeyboardButton(\"üìù View Variables\", callback_data=\"show_variables\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_welcome_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def start_welcome_customization(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Start welcome message customization process\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        # Extract user type from callback data\n        user_type_map = {\n            \"customize_new_user\": \"new_user\",\n            \"customize_returning\": \"returning\",\n            \"customize_vip\": \"vip\"\n        }\n        \n        user_type = user_type_map.get(query.data)\n        if not user_type:\n            await query.edit_message_text(\"‚ùå Invalid user type selected.\")\n            return\n        \n        context.user_data['welcome_user_type'] = user_type\n        \n        # Show template options\n        text = f\"\"\"\nüé® **Customize {user_type.replace('_', ' ').title()} Welcome**\n\nYou can either:\n‚Ä¢ Choose from pre-made templates\n‚Ä¢ Create a completely custom message\n\n**Available Templates:**\n        \"\"\"\n        \n        templates = self.welcome_system.get_available_templates()\n        keyboard = []\n        \n        for template in templates:\n            keyboard.append([InlineKeyboardButton(\n                f\"üìã {template['name']}\", \n                callback_data=f\"template_{template['id']}\"\n            )])\n        \n        keyboard.append([InlineKeyboardButton(\"‚úèÔ∏è Create Custom Message\", callback_data=\"create_custom\")])\n        keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"customize_welcome\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return WELCOME_TEMPLATE\n    \n    async def handle_template_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle template selection\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        if query.data == \"create_custom\":\n            return await self.start_custom_message(query, context)\n        \n        if query.data.startswith(\"template_\"):\n            template_id = query.data.replace(\"template_\", \"\")\n            user_type = context.user_data['welcome_user_type']\n            \n            # Apply template\n            result = self.welcome_system.apply_template(user_type, template_id)\n            \n            if result['success']:\n                template = result['template']\n                \n                success_text = f\"\"\"\n‚úÖ **Template Applied Successfully!**\n\n**Template:** {template['name']}\n**User Type:** {user_type.replace('_', ' ').title()}\n\n**Preview:**\n{template['message'][:200]}...\n\n**Buttons:** {len(template.get('buttons', []))} buttons configured\n\nThe template has been applied and is now active for {user_type.replace('_', ' ')} users!\n                \"\"\"\n                \n                keyboard = [\n                    [InlineKeyboardButton(\"üß™ Test Message\", callback_data=f\"test_{user_type}\")],\n                    [InlineKeyboardButton(\"‚úèÔ∏è Edit Further\", callback_data=\"create_custom\")],\n                    [InlineKeyboardButton(\"üè† Back to Menu\", callback_data=\"admin_welcome_menu\")]\n                ]\n                reply_markup = InlineKeyboardMarkup(keyboard)\n                \n                await query.edit_message_text(success_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n                return ConversationHandler.END\n                \n            else:\n                await query.edit_message_text(f\"‚ùå **Error applying template:**\\n\\n{result['message']}\")\n                return ConversationHandler.END\n        \n        return WELCOME_TEMPLATE\n    \n    async def start_custom_message(self, query, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Start custom message creation\"\"\"\n        user_type = context.user_data['welcome_user_type']\n        \n        text = f\"\"\"\n‚úèÔ∏è **Create Custom {user_type.replace('_', ' ').title()} Welcome**\n\nWrite your custom welcome message below.\n\n**Tips:**\n‚Ä¢ Use personalization variables (type /variables to see available ones)\n‚Ä¢ Keep it engaging and clear\n‚Ä¢ Mention your store's unique value\n‚Ä¢ Guide users to take action\n\n**Examples of variables:**\n‚Ä¢ `{{user_name}}` - User's name\n‚Ä¢ `{{store_name}}` - Your store name\n‚Ä¢ `{{order_count}}` - Number of orders\n\nEnter your welcome message:\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìù Show All Variables\", callback_data=\"show_variables\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"admin_welcome_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return WELCOME_MESSAGE\n    \n    async def get_custom_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get custom welcome message from user\"\"\"\n        message = update.message.text.strip()\n        \n        # Validate message\n        if len(message) < 20:\n            await update.message.reply_text(\n                \"‚ùå Message too short. Please write at least 20 characters.\\n\"\n                \"Try again:\"\n            )\n            return WELCOME_MESSAGE\n        \n        if len(message) > 1000:\n            await update.message.reply_text(\n                \"‚ùå Message too long. Please keep it under 1000 characters.\\n\"\n                \"Try again:\"\n            )\n            return WELCOME_MESSAGE\n        \n        # Validate variables\n        validation = WelcomeMessageVariables.validate_message(message)\n        if not validation['valid']:\n            await update.message.reply_text(\n                f\"‚ùå **Invalid variables found:**\\n\\n{validation['message']}\\n\\n\"\n                f\"Use the button below to see available variables, then try again:\"\n            )\n            return WELCOME_MESSAGE\n        \n        context.user_data['welcome_message'] = message\n        \n        # Show button configuration\n        text = f\"\"\"\n‚úÖ **Message Saved!**\n\n**Preview:**\n{message[:200]}{'...' if len(message) > 200 else ''}\n\n**Variables used:** {len(validation.get('used_variables', []))}\n\n**Now let's configure buttons:**\n\nYou can add up to 8 buttons for navigation. Each button needs:\n‚Ä¢ Button text (what users see)\n‚Ä¢ Action (what happens when clicked)\n\n**Common actions:** catalog, cart, orders, help, support, deals\n\nWould you like to add custom buttons or use default ones?\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üéØ Add Custom Buttons\", callback_data=\"add_custom_buttons\")],\n            [InlineKeyboardButton(\"‚ö° Use Default Buttons\", callback_data=\"use_default_buttons\")],\n            [InlineKeyboardButton(\"üö´ No Buttons\", callback_data=\"no_buttons\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return WELCOME_BUTTONS\n    \n    async def handle_button_selection(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle button configuration choice\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        if query.data == \"no_buttons\":\n            context.user_data['welcome_buttons'] = []\n            return await self.show_welcome_confirmation(query, context)\n        \n        elif query.data == \"use_default_buttons\":\n            default_buttons = [\n                {\"text\": \"üè™ Browse Products\", \"action\": \"catalog\"},\n                {\"text\": \"üõí View Cart\", \"action\": \"cart\"},\n                {\"text\": \"üì¶ My Orders\", \"action\": \"orders\"},\n                {\"text\": \"‚ùì Help & Support\", \"action\": \"help\"}\n            ]\n            context.user_data['welcome_buttons'] = default_buttons\n            return await self.show_welcome_confirmation(query, context)\n        \n        elif query.data == \"add_custom_buttons\":\n            text = \"\"\"\nüéØ **Add Custom Buttons**\n\nEnter buttons in this format (one per line):\n```\nButton Text | action_name\nAnother Button | another_action\n```\n\n**Examples:**\n```\nüî• Hot Deals | deals  \nüéÅ Special Offers | offers\nüìû Contact Us | support\nüÜï New Arrivals | new_products\n```\n\n**Maximum 8 buttons allowed.**\n            \"\"\"\n            \n            keyboard = [[InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"admin_welcome_menu\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            return WELCOME_BUTTONS\n        \n        return WELCOME_BUTTONS\n    \n    async def get_custom_buttons(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Parse custom buttons from user input\"\"\"\n        button_text = update.message.text.strip()\n        \n        if not button_text:\n            context.user_data['welcome_buttons'] = []\n            return await self.show_welcome_confirmation_message(update, context)\n        \n        # Parse buttons\n        buttons = []\n        lines = button_text.split('\\n')\n        \n        for line in lines:\n            line = line.strip()\n            if '|' in line:\n                parts = line.split('|', 1)\n                if len(parts) == 2:\n                    text = parts[0].strip()\n                    action = parts[1].strip()\n                    \n                    if text and action:\n                        buttons.append({\n                            \"text\": text,\n                            \"action\": action\n                        })\n        \n        if len(buttons) > 8:\n            await update.message.reply_text(\n                \"‚ùå Too many buttons! Maximum 8 allowed.\\n\"\n                \"Please reduce the number of buttons and try again:\"\n            )\n            return WELCOME_BUTTONS\n        \n        if not buttons:\n            await update.message.reply_text(\n                \"‚ùå No valid buttons found. Please use the format:\\n\"\n                \"`Button Text | action_name`\\n\\n\"\n                \"Try again or type 'none' for no buttons:\"\n            )\n            return WELCOME_BUTTONS\n        \n        context.user_data['welcome_buttons'] = buttons\n        return await self.show_welcome_confirmation_message(update, context)\n    \n    async def show_welcome_confirmation(self, query, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show welcome message confirmation (from callback)\"\"\"\n        user_type = context.user_data['welcome_user_type']\n        message = context.user_data['welcome_message']\n        buttons = context.user_data.get('welcome_buttons', [])\n        \n        preview_text = f\"\"\"\nüìã **Confirm Custom Welcome Message**\n\n**User Type:** {user_type.replace('_', ' ').title()}\n**Message Length:** {len(message)} characters\n**Buttons:** {len(buttons)}\n\n**Message Preview:**\n{message[:300]}{'...' if len(message) > 300 else ''}\n\n**Buttons:**\n\"\"\"\n        \n        for i, button in enumerate(buttons, 1):\n            preview_text += f\"{i}. {button['text']} ‚Üí {button['action']}\\n\"\n        \n        if not buttons:\n            preview_text += \"*No buttons configured*\\n\"\n        \n        preview_text += \"\\n‚úÖ Ready to save this welcome message?\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚úÖ Save Message\", callback_data=\"save_welcome_message\")],\n            [InlineKeyboardButton(\"üß™ Test First\", callback_data=\"test_custom_message\")],\n            [InlineKeyboardButton(\"‚úèÔ∏è Edit Message\", callback_data=\"edit_welcome_message\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"admin_welcome_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(preview_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return WELCOME_CONFIRM\n    \n    async def show_welcome_confirmation_message(self, update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show welcome message confirmation (from message)\"\"\"\n        user_type = context.user_data['welcome_user_type']\n        message = context.user_data['welcome_message']\n        buttons = context.user_data.get('welcome_buttons', [])\n        \n        preview_text = f\"\"\"\nüìã **Confirm Custom Welcome Message**\n\n**User Type:** {user_type.replace('_', ' ').title()}\n**Message Length:** {len(message)} characters\n**Buttons:** {len(buttons)}\n\n**Message Preview:**\n{message[:300]}{'...' if len(message) > 300 else ''}\n\n**Buttons:**\n\"\"\"\n        \n        for i, button in enumerate(buttons, 1):\n            preview_text += f\"{i}. {button['text']} ‚Üí {button['action']}\\n\"\n        \n        if not buttons:\n            preview_text += \"*No buttons configured*\\n\"\n        \n        preview_text += \"\\n‚úÖ Ready to save this welcome message?\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚úÖ Save Message\", callback_data=\"save_welcome_message\")],\n            [InlineKeyboardButton(\"üß™ Test First\", callback_data=\"test_custom_message\")],\n            [InlineKeyboardButton(\"‚úèÔ∏è Edit Message\", callback_data=\"edit_welcome_message\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"admin_welcome_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(preview_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return WELCOME_CONFIRM\n    \n    async def save_welcome_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Save the custom welcome message\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        user_type = context.user_data['welcome_user_type']\n        message = context.user_data['welcome_message']\n        buttons = context.user_data.get('welcome_buttons', [])\n        \n        # Save custom welcome message\n        result = self.welcome_system.create_custom_welcome(user_type, message, buttons)\n        \n        if result['success']:\n            success_text = f\"\"\"\nüéâ **Welcome Message Saved!**\n\nYour custom welcome message for **{user_type.replace('_', ' ').title()}** users is now active!\n\n**What's Next:**\n‚Ä¢ Test the message to see how it looks\n‚Ä¢ View analytics to track effectiveness  \n‚Ä¢ Customize other user types\n‚Ä¢ Update anytime from this menu\n\nReady to test your new welcome message?\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üß™ Test Message\", callback_data=f\"test_{user_type}\")],\n                [InlineKeyboardButton(\"üìä View Analytics\", callback_data=\"welcome_analytics\")],\n                [InlineKeyboardButton(\"‚ú® Customize More\", callback_data=\"customize_welcome\")],\n                [InlineKeyboardButton(\"üè† Back to Menu\", callback_data=\"admin_welcome_menu\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(success_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            \n        else:\n            await query.edit_message_text(f\"‚ùå **Error saving message:**\\n\\n{result['message']}\")\n        \n        # Clear user data\n        context.user_data.clear()\n        return ConversationHandler.END\n    \n    async def test_welcome_message(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Test welcome message for a user type\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        # Extract user type from callback data\n        if query.data.startswith(\"test_\"):\n            user_type = query.data.replace(\"test_\", \"\")\n        else:\n            await query.edit_message_text(\"‚ùå Invalid test request.\")\n            return\n        \n        # Test the message\n        result = self.welcome_system.test_welcome_message(user_type, \"Test User\")\n        \n        if result['success']:\n            preview = result['preview']\n            \n            test_text = f\"\"\"\nüß™ **Welcome Message Test**\n\n**User Type:** {user_type.replace('_', ' ').title()}\n**Template:** {preview['template_name']}\n\n**How it would look:**\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n{preview['message']}\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n**Buttons ({len(preview['buttons'])}):**\n\"\"\"\n            \n            for i, button in enumerate(preview['buttons'], 1):\n                test_text += f\"{i}. {button['text']}\\n\"\n            \n            test_text += \"\\n**Test completed!** This is how the message appears to users.\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"‚úèÔ∏è Edit Message\", callback_data=f\"customize_{user_type}\")],\n                [InlineKeyboardButton(\"üé® Try Different Template\", callback_data=\"welcome_templates\")],\n                [InlineKeyboardButton(\"‚úÖ Looks Good!\", callback_data=\"admin_welcome_menu\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(test_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            \n        else:\n            await query.edit_message_text(f\"‚ùå **Test failed:**\\n\\n{result['message']}\")\n    \n    async def show_variables(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show available personalization variables\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        help_text = WelcomeMessageVariables.get_help_text()\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"customize_welcome\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(help_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_welcome_analytics(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show welcome message analytics\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        analytics = self.welcome_system.get_welcome_analytics()\n        \n        analytics_text = f\"\"\"\nüìä **Welcome Message Analytics**\n\n**User Base Overview:**\n‚Ä¢ Total Users: {analytics['total_users']:,}\n‚Ä¢ Conversion Rate: {analytics['conversion_rate']:.1f}%\n‚Ä¢ New Users (Last 7 days): {analytics['recent_new_users']}\n\n**User Distribution:**\n‚Ä¢ üÜï New Users: {analytics['new_users']} ({analytics['new_users']/analytics['total_users']*100:.1f}% of total)\n‚Ä¢ üîÑ Returning: {analytics['returning_users']} ({analytics['returning_users']/analytics['total_users']*100:.1f}% of total)\n‚Ä¢ üëë VIP Users: {analytics['vip_users']} ({analytics['vip_users']/analytics['total_users']*100:.1f}% of total)\n\n**Insights:**\n‚Ä¢ {analytics['conversion_rate']:.0f} out of 100 new users make a purchase\n‚Ä¢ You have {analytics['vip_users']} high-value customers\n‚Ä¢ Recent growth: {analytics['recent_new_users']} new users this week\n\n**Recommendations:**\n‚Ä¢ Focus on converting {analytics['new_users']} new users\n‚Ä¢ Reward your {analytics['vip_users']} VIP customers\n‚Ä¢ Re-engage {analytics['returning_users']} returning users\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚ú® Optimize Messages\", callback_data=\"customize_welcome\")],\n            [InlineKeyboardButton(\"üß™ Test Different Approaches\", callback_data=\"test_welcome\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_welcome_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(analytics_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    def _is_admin(self, user_id):\n        \"\"\"Check if user is admin\"\"\"\n        admin_ids = [123456789]  # Replace with actual admin IDs\n        return user_id in admin_ids\n    \n    async def cancel_welcome_customization(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Cancel welcome customization\"\"\"\n        if update.callback_query:\n            await update.callback_query.edit_message_text(\"‚ùå Welcome message customization cancelled.\")\n        else:\n            await update.message.reply_text(\"‚ùå Welcome message customization cancelled.\")\n        \n        context.user_data.clear()\n        return ConversationHandler.END\n\ndef get_welcome_conversation_handler():\n    \"\"\"Get conversation handler for welcome message customization\"\"\"\n    welcome_commands = WelcomeCommands()\n    \n    return ConversationHandler(\n        entry_points=[\n            CallbackQueryHandler(welcome_commands.start_welcome_customization, pattern=\"^customize_(new_user|returning|vip)$\")\n        ],\n        states={\n            WELCOME_TEMPLATE: [\n                CallbackQueryHandler(welcome_commands.handle_template_selection, pattern=\"^(template_|create_custom)\"),\n            ],\n            WELCOME_MESSAGE: [\n                MessageHandler(filters.TEXT & ~filters.COMMAND, welcome_commands.get_custom_message)\n            ],\n            WELCOME_BUTTONS: [\n                CallbackQueryHandler(welcome_commands.handle_button_selection, pattern=\"^(add_custom_buttons|use_default_buttons|no_buttons)$\"),\n                MessageHandler(filters.TEXT & ~filters.COMMAND, welcome_commands.get_custom_buttons)\n            ],\n            WELCOME_CONFIRM: [\n                CallbackQueryHandler(welcome_commands.save_welcome_message, pattern=\"^save_welcome_message$\"),\n                CallbackQueryHandler(welcome_commands.test_welcome_message, pattern=\"^test_custom_message$\")\n            ]\n        },\n        fallbacks=[\n            CallbackQueryHandler(welcome_commands.cancel_welcome_customization, pattern=\"^admin_welcome_menu$\"),\n            CommandHandler('cancel', welcome_commands.cancel_welcome_customization)\n        ],\n        per_message=False\n    )","size_bytes":25557},"welcome_system.py":{"content":"\"\"\"\nCustomizable Welcome Message System\nAllows admins to customize bot start messages and user experience\n\"\"\"\nimport json\nimport re\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional\nfrom advanced_data_manager import AdvancedDataManager\n\nclass WelcomeMessageSystem:\n    def __init__(self):\n        self.data_manager = AdvancedDataManager()\n        self.default_templates = self._load_default_templates()\n    \n    def _load_default_templates(self) -> Dict:\n        \"\"\"Load default welcome message templates\"\"\"\n        return {\n            \"professional\": {\n                \"name\": \"Professional Store\",\n                \"message\": \"\"\"\nüõçÔ∏è **Welcome to {store_name}, {user_name}!**\n\nYour one-stop shop for quality products at great prices.\n\n**What we offer:**\n‚Ä¢ Wide selection of products\n‚Ä¢ Fast and reliable shipping\n‚Ä¢ Secure payment options\n‚Ä¢ Excellent customer service\n\nReady to start shopping?\n                \"\"\",\n                \"buttons\": [\n                    {\"text\": \"üè™ Browse Catalog\", \"action\": \"catalog\"},\n                    {\"text\": \"üõí View Cart\", \"action\": \"cart\"},\n                    {\"text\": \"üì¶ My Orders\", \"action\": \"orders\"},\n                    {\"text\": \"‚ùì Help & Support\", \"action\": \"help\"}\n                ]\n            },\n            \"friendly\": {\n                \"name\": \"Friendly Shop\",\n                \"message\": \"\"\"\nüëã **Hi there, {user_name}!**\n\nWelcome to {store_name} - we're so excited you're here! üéâ\n\nWe've got amazing products waiting for you, and our team is here to make your shopping experience absolutely fantastic!\n\n**Why you'll love shopping with us:**\n‚Ä¢ ‚ú® Handpicked quality products\n‚Ä¢ üöÄ Lightning-fast delivery  \n‚Ä¢ üíù Special offers just for you\n‚Ä¢ ü§ù Personal customer care\n\nLet's find something perfect for you! üí´\n                \"\"\",\n                \"buttons\": [\n                    {\"text\": \"üåü Featured Products\", \"action\": \"featured\"},\n                    {\"text\": \"üéØ Shop by Category\", \"action\": \"catalog\"},\n                    {\"text\": \"üõí My Cart\", \"action\": \"cart\"},\n                    {\"text\": \"üí¨ Chat with Us\", \"action\": \"support\"}\n                ]\n            },\n            \"minimal\": {\n                \"name\": \"Clean & Simple\",\n                \"message\": \"\"\"\n**{store_name}**\n\nWelcome, {user_name}.\n\nBrowse our products and place your orders seamlessly.\n                \"\"\",\n                \"buttons\": [\n                    {\"text\": \"Shop\", \"action\": \"catalog\"},\n                    {\"text\": \"Cart\", \"action\": \"cart\"},\n                    {\"text\": \"Orders\", \"action\": \"orders\"}\n                ]\n            },\n            \"promotional\": {\n                \"name\": \"Sales-Focused\",\n                \"message\": \"\"\"\nüî• **WELCOME {user_name}!** üî•\n\n**{store_name}** - Your Premium Shopping Destination!\n\nüéä **SPECIAL OFFERS JUST FOR YOU:**\n‚Ä¢ üè∑Ô∏è Up to 50% OFF selected items\n‚Ä¢ üöö FREE shipping on orders over $50\n‚Ä¢ üéÅ Exclusive member discounts\n\n**Limited time offers - Shop now!** ‚è∞\n\nDon't miss out on these incredible deals! üí®\n                \"\"\",\n                \"buttons\": [\n                    {\"text\": \"üî• Hot Deals\", \"action\": \"deals\"},\n                    {\"text\": \"üõçÔ∏è Shop All\", \"action\": \"catalog\"},\n                    {\"text\": \"üéÅ Special Offers\", \"action\": \"offers\"},\n                    {\"text\": \"‚ö° Flash Sales\", \"action\": \"flash_sales\"}\n                ]\n            }\n        }\n    \n    def get_welcome_message(self, user_telegram_id: str, user_name: str = \"there\") -> Dict:\n        \"\"\"Get personalized welcome message for a user\"\"\"\n        \n        # Get user info for personalization\n        user_info = self.data_manager.get_or_create_user(\n            telegram_id=user_telegram_id,\n            first_name=user_name\n        )\n        \n        # Check if user has custom welcome settings\n        is_returning = user_info.get('order_count', 0) > 0\n        is_vip = user_info.get('total_spent', 0) > 1000\n        \n        # Get appropriate welcome message\n        if is_vip:\n            welcome_config = self._get_vip_welcome()\n        elif is_returning:\n            welcome_config = self._get_returning_welcome()\n        else:\n            welcome_config = self._get_new_user_welcome()\n        \n        # Apply personalization\n        personalized_message = self._personalize_message(\n            welcome_config['message'],\n            user_info,\n            user_name\n        )\n        \n        return {\n            'message': personalized_message,\n            'buttons': welcome_config.get('buttons', []),\n            'template_name': welcome_config.get('name', 'Custom'),\n            'user_type': self._get_user_type(user_info)\n        }\n    \n    def _get_new_user_welcome(self) -> Dict:\n        \"\"\"Get welcome message for new users\"\"\"\n        template_name = self.data_manager.get_setting('new_user_template', 'professional')\n        custom_message = self.data_manager.get_setting('custom_new_user_message', '')\n        \n        if custom_message:\n            return self._parse_custom_message(custom_message)\n        \n        return self.default_templates.get(template_name, self.default_templates['professional'])\n    \n    def _get_returning_welcome(self) -> Dict:\n        \"\"\"Get welcome message for returning users\"\"\"\n        template_name = self.data_manager.get_setting('returning_user_template', 'friendly')\n        custom_message = self.data_manager.get_setting('custom_returning_message', '')\n        \n        if custom_message:\n            return self._parse_custom_message(custom_message)\n        \n        # Modify friendly template for returning users\n        template = self.default_templates.get(template_name, self.default_templates['friendly'])\n        template = template.copy()\n        template['message'] = template['message'].replace(\n            \"Welcome to {store_name}\",\n            \"Welcome back to {store_name}\"\n        )\n        \n        return template\n    \n    def _get_vip_welcome(self) -> Dict:\n        \"\"\"Get welcome message for VIP users\"\"\"\n        custom_message = self.data_manager.get_setting('custom_vip_message', '')\n        \n        if custom_message:\n            return self._parse_custom_message(custom_message)\n        \n        return {\n            \"name\": \"VIP Customer\",\n            \"message\": \"\"\"\nüëë **Welcome back, {user_name}!** üëë\n\nAs one of our **VIP customers**, you get exclusive access to:\n\nüåü **VIP Benefits:**\n‚Ä¢ üéÅ Exclusive member-only discounts\n‚Ä¢ üöö FREE priority shipping\n‚Ä¢ üìû Direct VIP customer support\n‚Ä¢ üîî First access to new products\n\nTotal orders: {order_count} | Lifetime value: ${total_spent:.2f}\n\nThank you for being such a valued customer! ‚ú®\n            \"\"\",\n            \"buttons\": [\n                {\"text\": \"üëë VIP Deals\", \"action\": \"vip_deals\"},\n                {\"text\": \"üÜï New Arrivals\", \"action\": \"new_arrivals\"},\n                {\"text\": \"üõí Quick Reorder\", \"action\": \"reorder\"},\n                {\"text\": \"üìû VIP Support\", \"action\": \"vip_support\"}\n            ]\n        }\n    \n    def _personalize_message(self, message: str, user_info: Dict, user_name: str) -> str:\n        \"\"\"Apply personalization to message\"\"\"\n        \n        # Get store settings\n        store_name = self.data_manager.get_setting('store_name', 'Our Store')\n        \n        # Replace placeholders\n        replacements = {\n            '{user_name}': user_name or user_info.get('first_name', 'there'),\n            '{store_name}': store_name,\n            '{order_count}': str(user_info.get('order_count', 0)),\n            '{total_spent}': f\"{user_info.get('total_spent', 0):.2f}\",\n            '{user_type}': self._get_user_type(user_info)\n        }\n        \n        personalized = message\n        for placeholder, value in replacements.items():\n            personalized = personalized.replace(placeholder, value)\n        \n        # Add dynamic content based on time\n        current_hour = datetime.now().hour\n        if 5 <= current_hour < 12:\n            time_greeting = \"Good morning\"\n        elif 12 <= current_hour < 17:\n            time_greeting = \"Good afternoon\"\n        else:\n            time_greeting = \"Good evening\"\n        \n        # Add time-based greeting if not present\n        if \"Good morning\" not in personalized and \"Good afternoon\" not in personalized and \"Good evening\" not in personalized:\n            personalized = f\"{time_greeting}! \" + personalized\n        \n        return personalized.strip()\n    \n    def _get_user_type(self, user_info: Dict) -> str:\n        \"\"\"Determine user type based on history\"\"\"\n        total_spent = user_info.get('total_spent', 0)\n        order_count = user_info.get('order_count', 0)\n        \n        if total_spent > 1000:\n            return \"VIP\"\n        elif order_count > 0:\n            return \"Returning\"\n        else:\n            return \"New\"\n    \n    def _parse_custom_message(self, custom_message: str) -> Dict:\n        \"\"\"Parse custom message format\"\"\"\n        try:\n            # Assume custom message is JSON format with message and buttons\n            parsed = json.loads(custom_message)\n            return parsed\n        except:\n            # Fallback to text-only message\n            return {\n                \"name\": \"Custom\",\n                \"message\": custom_message,\n                \"buttons\": [\n                    {\"text\": \"üè™ Browse Products\", \"action\": \"catalog\"},\n                    {\"text\": \"üõí View Cart\", \"action\": \"cart\"},\n                    {\"text\": \"‚ùì Help\", \"action\": \"help\"}\n                ]\n            }\n    \n    def create_custom_welcome(self, user_type: str, message: str, buttons: List[Dict]) -> Dict:\n        \"\"\"Create custom welcome message\"\"\"\n        \n        # Validate user type\n        valid_types = ['new_user', 'returning', 'vip']\n        if user_type not in valid_types:\n            return {\n                'success': False,\n                'message': f'Invalid user type. Must be one of: {\", \".join(valid_types)}'\n            }\n        \n        # Validate message\n        if not message or len(message.strip()) < 10:\n            return {\n                'success': False,\n                'message': 'Message must be at least 10 characters long'\n            }\n        \n        # Validate buttons\n        if len(buttons) > 8:\n            return {\n                'success': False,\n                'message': 'Maximum 8 buttons allowed'\n            }\n        \n        for button in buttons:\n            if not button.get('text') or not button.get('action'):\n                return {\n                    'success': False,\n                    'message': 'Each button must have text and action'\n                }\n        \n        # Create custom welcome config\n        custom_config = {\n            'name': f'Custom {user_type.title()}',\n            'message': message.strip(),\n            'buttons': buttons,\n            'created_at': datetime.utcnow().isoformat()\n        }\n        \n        try:\n            # Save to settings\n            setting_key = f'custom_{user_type}_message'\n            self.data_manager.set_setting(\n                setting_key,\n                json.dumps(custom_config),\n                f'Custom welcome message for {user_type} users'\n            )\n            \n            return {\n                'success': True,\n                'message': f'Custom welcome message for {user_type} users saved successfully',\n                'config': custom_config\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error saving custom message: {str(e)}'\n            }\n    \n    def get_available_templates(self) -> List[Dict]:\n        \"\"\"Get all available welcome templates\"\"\"\n        templates = []\n        \n        for template_id, template_data in self.default_templates.items():\n            templates.append({\n                'id': template_id,\n                'name': template_data['name'],\n                'preview': template_data['message'][:100] + '...',\n                'button_count': len(template_data.get('buttons', []))\n            })\n        \n        return templates\n    \n    def apply_template(self, user_type: str, template_id: str) -> Dict:\n        \"\"\"Apply a template to a user type\"\"\"\n        \n        if template_id not in self.default_templates:\n            return {\n                'success': False,\n                'message': f'Template \"{template_id}\" not found'\n            }\n        \n        if user_type not in ['new_user', 'returning', 'vip']:\n            return {\n                'success': False,\n                'message': 'Invalid user type'\n            }\n        \n        try:\n            setting_key = f'{user_type}_template'\n            self.data_manager.set_setting(\n                setting_key,\n                template_id,\n                f'Welcome template for {user_type} users'\n            )\n            \n            return {\n                'success': True,\n                'message': f'Template \"{self.default_templates[template_id][\"name\"]}\" applied to {user_type} users',\n                'template': self.default_templates[template_id]\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error applying template: {str(e)}'\n            }\n    \n    def get_welcome_analytics(self) -> Dict:\n        \"\"\"Get analytics about welcome message effectiveness\"\"\"\n        \n        # Get user stats\n        all_users = self.data_manager.get_users()\n        new_users = [u for u in all_users if u.get('order_count', 0) == 0]\n        returning_users = [u for u in all_users if 0 < u.get('order_count', 0) < 5]\n        vip_users = [u for u in all_users if u.get('total_spent', 0) > 1000]\n        \n        # Calculate conversion rates\n        total_users = len(all_users)\n        converted_users = [u for u in all_users if u.get('order_count', 0) > 0]\n        conversion_rate = (len(converted_users) / total_users * 100) if total_users > 0 else 0\n        \n        # Recent activity (last 7 days)\n        week_ago = datetime.utcnow() - timedelta(days=7)\n        recent_users = [\n            u for u in all_users \n            if datetime.fromisoformat(u.get('created_at', '1970-01-01')) >= week_ago\n        ]\n        \n        return {\n            'total_users': total_users,\n            'new_users': len(new_users),\n            'returning_users': len(returning_users),\n            'vip_users': len(vip_users),\n            'conversion_rate': conversion_rate,\n            'recent_new_users': len(recent_users),\n            'user_distribution': {\n                'new': len(new_users),\n                'returning': len(returning_users),\n                'vip': len(vip_users)\n            }\n        }\n    \n    def test_welcome_message(self, user_type: str, test_user_name: str = \"Test User\") -> Dict:\n        \"\"\"Test welcome message for a user type\"\"\"\n        \n        # Create mock user data\n        mock_user_data = {\n            'telegram_id': '123456789',\n            'first_name': test_user_name,\n            'order_count': 0,\n            'total_spent': 0\n        }\n        \n        if user_type == 'returning':\n            mock_user_data['order_count'] = 3\n            mock_user_data['total_spent'] = 250.0\n        elif user_type == 'vip':\n            mock_user_data['order_count'] = 15\n            mock_user_data['total_spent'] = 1500.0\n        \n        # Get appropriate welcome\n        if user_type == 'new':\n            config = self._get_new_user_welcome()\n        elif user_type == 'returning':\n            config = self._get_returning_welcome()\n        elif user_type == 'vip':\n            config = self._get_vip_welcome()\n        else:\n            return {'success': False, 'message': 'Invalid user type'}\n        \n        # Apply personalization\n        personalized_message = self._personalize_message(\n            config['message'],\n            mock_user_data,\n            test_user_name\n        )\n        \n        return {\n            'success': True,\n            'preview': {\n                'message': personalized_message,\n                'buttons': config.get('buttons', []),\n                'template_name': config.get('name', 'Custom'),\n                'user_type': user_type\n            }\n        }\n    \n    def schedule_welcome_update(self, message: str, schedule_time: datetime, user_types: List[str] = None) -> Dict:\n        \"\"\"Schedule a welcome message update\"\"\"\n        \n        if user_types is None:\n            user_types = ['new_user', 'returning', 'vip']\n        \n        # Validate schedule time\n        if schedule_time <= datetime.utcnow():\n            return {\n                'success': False,\n                'message': 'Schedule time must be in the future'\n            }\n        \n        try:\n            # Create scheduled update record\n            schedule_data = {\n                'message': message,\n                'user_types': user_types,\n                'schedule_time': schedule_time.isoformat(),\n                'status': 'scheduled',\n                'created_at': datetime.utcnow().isoformat()\n            }\n            \n            # Save to settings (in real implementation, you'd use a proper scheduler)\n            schedule_key = f'scheduled_welcome_{int(datetime.utcnow().timestamp())}'\n            self.data_manager.set_setting(\n                schedule_key,\n                json.dumps(schedule_data),\n                'Scheduled welcome message update'\n            )\n            \n            return {\n                'success': True,\n                'message': f'Welcome message update scheduled for {schedule_time.strftime(\"%Y-%m-%d %H:%M\")}',\n                'schedule_id': schedule_key\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error scheduling update: {str(e)}'\n            }\n\nclass WelcomeMessageVariables:\n    \"\"\"Available variables for welcome message personalization\"\"\"\n    \n    VARIABLES = {\n        '{user_name}': 'User\\'s first name',\n        '{store_name}': 'Store name from settings',\n        '{order_count}': 'Number of orders placed by user',\n        '{total_spent}': 'Total amount spent by user',\n        '{user_type}': 'User type (New/Returning/VIP)',\n        '{current_date}': 'Current date',\n        '{current_time}': 'Current time',\n        '{day_greeting}': 'Time-based greeting (Good morning/afternoon/evening)'\n    }\n    \n    @classmethod\n    def get_help_text(cls) -> str:\n        \"\"\"Get help text for variables\"\"\"\n        help_text = \"üìù **Available Variables:**\\n\\n\"\n        \n        for variable, description in cls.VARIABLES.items():\n            help_text += f\"`{variable}` - {description}\\n\"\n        \n        help_text += \"\\nüí° **Example:**\\n\"\n        help_text += \"`Hello {user_name}! Welcome to {store_name}.`\"\n        \n        return help_text\n    \n    @classmethod\n    def validate_message(cls, message: str) -> Dict:\n        \"\"\"Validate message for proper variable usage\"\"\"\n        \n        # Find all variables in message\n        import re\n        found_variables = re.findall(r'\\{[^}]+\\}', message)\n        invalid_variables = []\n        \n        for var in found_variables:\n            if var not in cls.VARIABLES:\n                invalid_variables.append(var)\n        \n        if invalid_variables:\n            return {\n                'valid': False,\n                'message': f'Invalid variables found: {\", \".join(invalid_variables)}',\n                'invalid_variables': invalid_variables\n            }\n        \n        return {\n            'valid': True,\n            'message': 'All variables are valid',\n            'used_variables': found_variables\n        }","size_bytes":19756},"static/js/admin.js":{"content":"// Admin Panel JavaScript Functions\n\nfunction refreshData() {\n    location.reload();\n}\n\nfunction addProduct() {\n    const form = document.getElementById('addProductForm');\n    const formData = new FormData(form);\n    \n    const productData = {\n        name: document.getElementById('productName').value,\n        description: document.getElementById('productDescription').value,\n        price: parseFloat(document.getElementById('productPrice').value),\n        category: document.getElementById('productCategory').value,\n        image_url: document.getElementById('productImageUrl').value,\n        stock: parseInt(document.getElementById('productStock').value)\n    };\n    \n    // Validate required fields\n    if (!productData.name || !productData.description || !productData.price || !productData.category) {\n        alert('Please fill in all required fields');\n        return;\n    }\n    \n    fetch('/api/products', {\n        method: 'POST',\n        headers: {\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(productData)\n    })\n    .then(response => response.json())\n    .then(data => {\n        if (data.error) {\n            alert('Error adding product: ' + data.error);\n        } else {\n            // Close modal and refresh page\n            bootstrap.Modal.getInstance(document.getElementById('addProductModal')).hide();\n            location.reload();\n        }\n    })\n    .catch(error => {\n        console.error('Error:', error);\n        alert('Error adding product');\n    });\n}\n\nfunction editProduct(productId) {\n    // Find product data from the table\n    const row = document.querySelector(`tr[data-product-id=\"${productId}\"]`);\n    if (!row) {\n        alert('Product not found');\n        return;\n    }\n    \n    // Get current product data\n    fetch('/api/products')\n    .then(response => response.json())\n    .then(products => {\n        const product = products.find(p => p.id === productId);\n        if (!product) {\n            alert('Product not found');\n            return;\n        }\n        \n        // Populate edit form\n        document.getElementById('editProductId').value = product.id;\n        document.getElementById('editProductName').value = product.name;\n        document.getElementById('editProductDescription').value = product.description;\n        document.getElementById('editProductPrice').value = product.price;\n        document.getElementById('editProductCategory').value = product.category;\n        document.getElementById('editProductImageUrl').value = product.image_url || '';\n        document.getElementById('editProductStock').value = product.stock;\n        \n        // Show modal\n        new bootstrap.Modal(document.getElementById('editProductModal')).show();\n    })\n    .catch(error => {\n        console.error('Error:', error);\n        alert('Error loading product data');\n    });\n}\n\nfunction updateProduct() {\n    const productId = document.getElementById('editProductId').value;\n    \n    const productData = {\n        name: document.getElementById('editProductName').value,\n        description: document.getElementById('editProductDescription').value,\n        price: parseFloat(document.getElementById('editProductPrice').value),\n        category: document.getElementById('editProductCategory').value,\n        image_url: document.getElementById('editProductImageUrl').value,\n        stock: parseInt(document.getElementById('editProductStock').value)\n    };\n    \n    // Validate required fields\n    if (!productData.name || !productData.description || !productData.price || !productData.category) {\n        alert('Please fill in all required fields');\n        return;\n    }\n    \n    fetch(`/api/products/${productId}`, {\n        method: 'PUT',\n        headers: {\n            'Content-Type': 'application/json',\n        },\n        body: JSON.stringify(productData)\n    })\n    .then(response => response.json())\n    .then(data => {\n        if (data.error) {\n            alert('Error updating product: ' + data.error);\n        } else {\n            // Close modal and refresh page\n            bootstrap.Modal.getInstance(document.getElementById('editProductModal')).hide();\n            location.reload();\n        }\n    })\n    .catch(error => {\n        console.error('Error:', error);\n        alert('Error updating product');\n    });\n}\n\nfunction deleteProduct(productId) {\n    if (!confirm('Are you sure you want to delete this product? This action cannot be undone.')) {\n        return;\n    }\n    \n    fetch(`/api/products/${productId}`, {\n        method: 'DELETE',\n    })\n    .then(response => response.json())\n    .then(data => {\n        if (data.error) {\n            alert('Error deleting product: ' + data.error);\n        } else {\n            // Remove row from table and refresh\n            location.reload();\n        }\n    })\n    .catch(error => {\n        console.error('Error:', error);\n        alert('Error deleting product');\n    });\n}\n\n// Initialize form validation\ndocument.addEventListener('DOMContentLoaded', function() {\n    // Add form validation for number inputs\n    const numberInputs = document.querySelectorAll('input[type=\"number\"]');\n    numberInputs.forEach(input => {\n        input.addEventListener('input', function() {\n            if (this.value < 0) {\n                this.value = 0;\n            }\n        });\n    });\n    \n    // Clear form when add modal is closed\n    const addModal = document.getElementById('addProductModal');\n    if (addModal) {\n        addModal.addEventListener('hidden.bs.modal', function() {\n            document.getElementById('addProductForm').reset();\n        });\n    }\n});\n","size_bytes":5601},"SETUP_GUIDE.md":{"content":"# Premium Store Bot Configuration Guide\n\n## üöÄ Quick Setup Steps\n\n### 1. Get Your Telegram ID\nSend `/start` to @userinfobot on Telegram to get your ID, then:\n\n```bash\npython admin_config.py\n```\nChoose option 1 to create initial config, then edit `config/admin_settings.json`:\n```json\n{\n  \"admin_users\": [\"YOUR_TELEGRAM_ID_HERE\"]\n}\n```\n\n### 2. Configure Payment Methods\nEdit `config/payment_methods.json` with your payment details:\n\n```json\n{\n  \"gcash\": {\n    \"name\": \"GCash\",\n    \"number\": \"09123456789\", \n    \"qr_code_url\": \"https://your-qr-image.com/gcash.png\"\n  }\n}\n```\n\n### 3. Add Your Products\nEdit `config/sample_products.json` or run:\n```bash\npython admin_config.py\n```\nChoose option 4 to add products.\n\n### 4. Upload QR Code Images\n- Upload your payment QR codes to an image hosting service\n- Update the `qr_code_url` in payment methods\n\n## üìù Bot Commands\n\n**User Commands:**\n- `/start` - Welcome message\n- `/balance` - Check balance\n- `/deposit` - Add balance\n- `/products` - Browse store\n\n**Admin Commands (add to bot later):**\n- `/admin` - Admin panel\n- `/stats` - View statistics\n- `/broadcast` - Send message to all users\n\n## üîß Advanced Configuration\n\n### Custom Categories\nAdd new categories in `config/categories.json`:\n```json\n{\n  \"id\": \"education\",\n  \"name\": \"üìö Education\", \n  \"emoji\": \"üìö\",\n  \"description\": \"Online courses and certifications\"\n}\n```\n\n### Product Variants\nEach product can have multiple variants (durations, types):\n```json\n{\n  \"variants\": [\n    {\n      \"id\": 1,\n      \"name\": \"1 Month\",\n      \"price\": 150.0,\n      \"stock\": 25\n    },\n    {\n      \"id\": 2,\n      \"name\": \"3 Months\", \n      \"price\": 400.0,\n      \"stock\": 15\n    }\n  ]\n}\n```\n\n### Auto-Reply Messages\nCustomize messages in `config/admin_settings.json`:\n```json\n{\n  \"welcome_message\": \"Your custom welcome message\",\n  \"support_username\": \"@YourSupport\",\n  \"min_deposit\": 20.0,\n  \"max_deposit\": 10000.0\n}\n```\n\n## üéØ Next Steps\n\n1. **Test the bot**: Send messages and check responses\n2. **Add products**: Use the admin config tool\n3. **Upload payment QRs**: Host your QR code images\n4. **Set admin ID**: Add your Telegram ID to admin list\n5. **Customize messages**: Edit welcome and support messages\n\nYour bot is now ready to serve customers! üéâ","size_bytes":2256},"account_storage_system.py":{"content":"\"\"\"\nAccount Storage System for Premium Store Bot\nStores actual account credentials for delivery to customers\n\"\"\"\nimport json\nimport os\nfrom datetime import datetime\n\ndef ensure_accounts_file():\n    \"\"\"Create accounts.json if it doesn't exist\"\"\"\n    if not os.path.exists('data/accounts.json'):\n        if not os.path.exists('data'):\n            os.makedirs('data')\n        with open('data/accounts.json', 'w') as f:\n            json.dump({}, f)\n\ndef add_account(product_id, account_details, added_by):\n    \"\"\"Add account credentials for a product\"\"\"\n    ensure_accounts_file()\n    \n    try:\n        with open('data/accounts.json', 'r') as f:\n            accounts = json.load(f)\n    except:\n        accounts = {}\n    \n    if product_id not in accounts:\n        accounts[product_id] = []\n    \n    account = {\n        'id': len(accounts[product_id]) + 1,\n        'details': account_details,\n        'status': 'available',\n        'added_by': added_by,\n        'added_at': datetime.utcnow().isoformat(),\n        'sold_at': None,\n        'sold_to': None\n    }\n    \n    accounts[product_id].append(account)\n    \n    with open('data/accounts.json', 'w') as f:\n        json.dump(accounts, f, indent=2)\n    \n    return True\n\ndef get_available_accounts(product_id):\n    \"\"\"Get available accounts for a product\"\"\"\n    ensure_accounts_file()\n    \n    try:\n        with open('data/accounts.json', 'r') as f:\n            accounts = json.load(f)\n        \n        product_accounts = accounts.get(product_id, [])\n        available = [acc for acc in product_accounts if acc['status'] == 'available']\n        return available\n    except:\n        return []\n\ndef sell_account(product_id, user_id):\n    \"\"\"Mark an account as sold and return the details\"\"\"\n    ensure_accounts_file()\n    \n    try:\n        with open('data/accounts.json', 'r') as f:\n            accounts = json.load(f)\n        \n        product_accounts = accounts.get(product_id, [])\n        \n        for account in product_accounts:\n            if account['status'] == 'available':\n                account['status'] = 'sold'\n                account['sold_at'] = datetime.utcnow().isoformat()\n                account['sold_to'] = user_id\n                \n                with open('data/accounts.json', 'w') as f:\n                    json.dump(accounts, f, indent=2)\n                \n                return account['details']\n        \n        return None\n    except:\n        return None\n\ndef get_stock_count(product_id):\n    \"\"\"Get available stock count for a product\"\"\"\n    available = get_available_accounts(product_id)\n    return len(available)","size_bytes":2590},"admin_config.py":{"content":"\"\"\"\nAdmin Configuration System\nConfigure your Premium Store Bot settings\n\"\"\"\nimport json\nimport os\nfrom simple_data_manager import SimpleDataManager\n\nclass BotConfig:\n    def __init__(self):\n        self.data_manager = SimpleDataManager()\n        self.setup_initial_config()\n    \n    def setup_initial_config(self):\n        \"\"\"Set up initial bot configuration\"\"\"\n        \n        # Admin settings\n        admin_settings = {\n            \"admin_users\": [\n                \"YOUR_TELEGRAM_ID_HERE\"  # Replace with your Telegram ID\n            ],\n            \"store_name\": \"Premium Store\",\n            \"welcome_message\": \"üëã Welcome to Premium Store!\\n\\nYour one-stop shop for premium accounts and services.\",\n            \"support_username\": \"@YourSupportBot\",\n            \"min_deposit\": 20.0,\n            \"max_deposit\": 10000.0\n        }\n        \n        # Payment methods with QR codes\n        payment_methods = {\n            \"gcash\": {\n                \"name\": \"GCash\",\n                \"number\": \"09123456789\",\n                \"qr_code_url\": \"https://your-domain.com/gcash-qr.png\",\n                \"instructions\": \"Send payment to GCash number above and upload screenshot\"\n            },\n            \"paymaya\": {\n                \"name\": \"PayMaya\", \n                \"number\": \"09987654321\",\n                \"qr_code_url\": \"https://your-domain.com/paymaya-qr.png\",\n                \"instructions\": \"Send payment to PayMaya number above and upload screenshot\"\n            },\n            \"bank\": {\n                \"name\": \"Bank Transfer\",\n                \"account_name\": \"Your Name\",\n                \"account_number\": \"1234567890\",\n                \"bank_name\": \"BPI\",\n                \"instructions\": \"Transfer to bank account above and upload receipt\"\n            }\n        }\n        \n        # Product categories\n        categories = [\n            {\n                \"id\": \"streaming\",\n                \"name\": \"üì∫ Streaming Services\",\n                \"emoji\": \"üì∫\",\n                \"description\": \"Netflix, Spotify, Disney+, etc.\"\n            },\n            {\n                \"id\": \"gaming\", \n                \"name\": \"üéÆ Gaming Accounts\",\n                \"emoji\": \"üéÆ\",\n                \"description\": \"Steam, Epic Games, console accounts\"\n            },\n            {\n                \"id\": \"productivity\",\n                \"name\": \"üíº Productivity Tools\",\n                \"emoji\": \"üíº\", \n                \"description\": \"Microsoft Office, Adobe, Canva Pro\"\n            },\n            {\n                \"id\": \"vpn\",\n                \"name\": \"üîí VPN Services\",\n                \"emoji\": \"üîí\",\n                \"description\": \"Nord VPN, Express VPN, etc.\"\n            }\n        ]\n        \n        # Sample products\n        products = {\n            \"netflix_1m\": {\n                \"id\": \"netflix_1m\",\n                \"name\": \"Netflix Premium\",\n                \"category_id\": \"streaming\",\n                \"description\": \"1 Month Netflix Premium Account\",\n                \"variants\": [\n                    {\n                        \"id\": 1,\n                        \"name\": \"1 Month\",\n                        \"price\": 150.0,\n                        \"stock\": 25,\n                        \"features\": [\"4K Quality\", \"4 Screens\", \"Downloads\"]\n                    },\n                    {\n                        \"id\": 2, \n                        \"name\": \"3 Months\",\n                        \"price\": 400.0,\n                        \"stock\": 15,\n                        \"features\": [\"4K Quality\", \"4 Screens\", \"Downloads\", \"3 Month Warranty\"]\n                    }\n                ],\n                \"emoji\": \"üì∫\",\n                \"auto_delivery\": True\n            },\n            \"spotify_1m\": {\n                \"id\": \"spotify_1m\", \n                \"name\": \"Spotify Premium\",\n                \"category_id\": \"streaming\",\n                \"description\": \"1 Month Spotify Premium\",\n                \"variants\": [\n                    {\n                        \"id\": 1,\n                        \"name\": \"Individual\",\n                        \"price\": 120.0,\n                        \"stock\": 30,\n                        \"features\": [\"No Ads\", \"Download Music\", \"High Quality\"]\n                    },\n                    {\n                        \"id\": 2,\n                        \"name\": \"Family\",\n                        \"price\": 180.0,\n                        \"stock\": 10, \n                        \"features\": [\"6 Accounts\", \"No Ads\", \"Download Music\"]\n                    }\n                ],\n                \"emoji\": \"üéµ\",\n                \"auto_delivery\": True\n            }\n        }\n        \n        # Save configurations\n        config_dir = \"config\"\n        if not os.path.exists(config_dir):\n            os.makedirs(config_dir)\n        \n        configs = {\n            \"admin_settings.json\": admin_settings,\n            \"payment_methods.json\": payment_methods, \n            \"categories.json\": categories,\n            \"sample_products.json\": products\n        }\n        \n        for filename, config_data in configs.items():\n            filepath = os.path.join(config_dir, filename)\n            with open(filepath, 'w') as f:\n                json.dump(config_data, f, indent=2)\n        \n        print(\"‚úÖ Initial configuration files created in 'config/' directory\")\n        print(\"\\nüìù Next steps:\")\n        print(\"1. Edit config/admin_settings.json - Add your Telegram ID\")\n        print(\"2. Edit config/payment_methods.json - Add your payment details\")\n        print(\"3. Edit config/sample_products.json - Add your products\")\n        print(\"4. Upload your QR code images\")\n\n    def add_admin_user(self, telegram_id):\n        \"\"\"Add admin user\"\"\"\n        config_file = \"config/admin_settings.json\"\n        \n        if os.path.exists(config_file):\n            with open(config_file, 'r') as f:\n                settings = json.load(f)\n            \n            if telegram_id not in settings[\"admin_users\"]:\n                settings[\"admin_users\"].append(str(telegram_id))\n                \n                with open(config_file, 'w') as f:\n                    json.dump(settings, f, indent=2)\n                \n                print(f\"‚úÖ Added admin user: {telegram_id}\")\n            else:\n                print(f\"‚ÑπÔ∏è User {telegram_id} is already an admin\")\n        else:\n            print(\"‚ùå Admin settings file not found\")\n\n    def update_payment_method(self, method_id, details):\n        \"\"\"Update payment method details\"\"\"\n        config_file = \"config/payment_methods.json\"\n        \n        if os.path.exists(config_file):\n            with open(config_file, 'r') as f:\n                methods = json.load(f)\n            \n            if method_id in methods:\n                methods[method_id].update(details)\n                \n                with open(config_file, 'w') as f:\n                    json.dump(methods, f, indent=2)\n                \n                print(f\"‚úÖ Updated payment method: {method_id}\")\n            else:\n                print(f\"‚ùå Payment method {method_id} not found\")\n        else:\n            print(\"‚ùå Payment methods file not found\")\n\n    def add_product(self, product_data):\n        \"\"\"Add new product\"\"\"\n        config_file = \"config/sample_products.json\"\n        \n        if os.path.exists(config_file):\n            with open(config_file, 'r') as f:\n                products = json.load(f)\n            \n            products[product_data[\"id\"]] = product_data\n            \n            with open(config_file, 'w') as f:\n                json.dump(products, f, indent=2)\n            \n            print(f\"‚úÖ Added product: {product_data['name']}\")\n        else:\n            print(\"‚ùå Products file not found\")\n\nif __name__ == \"__main__\":\n    config = BotConfig()\n    \n    print(\"\\nü§ñ Premium Store Bot Configuration\")\n    print(\"=\" * 50)\n    \n    choice = input(\"\\nWhat would you like to do?\\n1. Setup initial config\\n2. Add admin user\\n3. Update payment method\\n4. Add product\\n\\nChoice (1-4): \")\n    \n    if choice == \"1\":\n        config.setup_initial_config()\n    \n    elif choice == \"2\":\n        telegram_id = input(\"Enter Telegram ID: \")\n        config.add_admin_user(telegram_id)\n    \n    elif choice == \"3\":\n        method_id = input(\"Payment method (gcash/paymaya/bank): \")\n        print(\"Enter new details (press Enter to skip):\")\n        name = input(\"Name: \") or None\n        number = input(\"Number/Account: \") or None\n        qr_url = input(\"QR Code URL: \") or None\n        \n        details = {k: v for k, v in {\n            \"name\": name, \"number\": number, \"qr_code_url\": qr_url\n        }.items() if v}\n        \n        config.update_payment_method(method_id, details)\n    \n    elif choice == \"4\":\n        print(\"Add new product:\")\n        product_id = input(\"Product ID: \")\n        name = input(\"Product name: \")\n        category = input(\"Category (streaming/gaming/productivity/vpn): \")\n        price = float(input(\"Price: \"))\n        stock = int(input(\"Stock: \"))\n        \n        product_data = {\n            \"id\": product_id,\n            \"name\": name,\n            \"category_id\": category,\n            \"description\": f\"{name} - Premium account\",\n            \"variants\": [\n                {\n                    \"id\": 1,\n                    \"name\": \"Standard\",\n                    \"price\": price,\n                    \"stock\": stock,\n                    \"features\": [\"Premium Access\"]\n                }\n            ],\n            \"emoji\": \"‚≠ê\",\n            \"auto_delivery\": True\n        }\n        \n        config.add_product(product_data)","size_bytes":9488},"admin_panel.py":{"content":"\"\"\"\nComprehensive Admin Panel System\nCentral hub for managing all store operations and features\n\"\"\"\nfrom datetime import datetime, timedelta\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, CommandHandler, CallbackQueryHandler\nfrom telegram.constants import ParseMode\n\n# Import all admin systems\nfrom financial_system import FinancialSystem\nfrom broadcast_system import BroadcastSystem\nfrom voucher_system import VoucherSystem\nfrom payment_system import PaymentSystem\nfrom welcome_system import WelcomeMessageSystem\nfrom support_system import CustomerSupportSystem\nfrom advanced_data_manager import AdvancedDataManager\n\nclass AdminPanel:\n    def __init__(self):\n        # Initialize all systems\n        self.financial_system = FinancialSystem()\n        self.broadcast_system = BroadcastSystem()\n        self.voucher_system = VoucherSystem()\n        self.payment_system = PaymentSystem()\n        self.welcome_system = WelcomeMessageSystem()\n        self.support_system = CustomerSupportSystem()\n        self.data_manager = AdvancedDataManager()\n        \n        # Admin user IDs - in production, this would be in settings/database\n        self.admin_user_ids = self._load_admin_users()\n    \n    def _load_admin_users(self) -> list:\n        \"\"\"Load admin user IDs from settings\"\"\"\n        # In production, load from database or config file\n        return [123456789]  # Replace with actual admin IDs\n    \n    def is_admin(self, user_id: int) -> bool:\n        \"\"\"Check if user has admin privileges\"\"\"\n        return user_id in self.admin_user_ids\n    \n    async def admin_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Main admin command - shows comprehensive dashboard\"\"\"\n        user_id = update.effective_user.id\n        \n        if not self.is_admin(user_id):\n            await update.message.reply_text(\n                \"‚ùå **Access Denied**\\n\\n\"\n                \"You don't have admin privileges for this store.\\n\"\n                \"Contact the store owner for access.\",\n                parse_mode=ParseMode.MARKDOWN\n            )\n            return\n        \n        await self.show_admin_dashboard(update, context)\n    \n    async def show_admin_dashboard(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Display comprehensive admin dashboard\"\"\"\n        \n        # Gather key metrics from all systems\n        dashboard_data = await self._gather_dashboard_metrics()\n        \n        admin_text = f\"\"\"\nüõ†Ô∏è **Store Admin Dashboard**\n\n**üìä Business Overview (Last 30 Days):**\n‚Ä¢ Revenue: ‚Ç±{dashboard_data['revenue']:,.2f} ({dashboard_data['revenue_growth']:+.1f}%)\n‚Ä¢ Orders: {dashboard_data['orders']:,} ({dashboard_data['order_growth']:+.1f}%)\n‚Ä¢ Active Customers: {dashboard_data['active_customers']:,}\n‚Ä¢ Avg Order Value: ‚Ç±{dashboard_data['avg_order_value']:.2f}\n\n**‚ö° System Status:**\n‚Ä¢ Pending Payments: {dashboard_data['pending_payments']}\n‚Ä¢ Support Tickets: {dashboard_data['open_tickets']}\n‚Ä¢ Active Vouchers: {dashboard_data['active_vouchers']}\n‚Ä¢ Total Users: {dashboard_data['total_users']:,}\n\n**üéØ Quick Stats:**\n‚Ä¢ Conversion Rate: {dashboard_data['conversion_rate']:.1f}%\n‚Ä¢ Customer Satisfaction: {dashboard_data['satisfaction_rate']:.1f}%\n‚Ä¢ System Health: {'üü¢ Excellent' if dashboard_data['system_health'] > 0.9 else 'üü° Good' if dashboard_data['system_health'] > 0.7 else 'üî¥ Needs Attention'}\n\n**üöÄ Today's Performance:**\n‚Ä¢ Revenue: ‚Ç±{dashboard_data['today_revenue']:,.2f}\n‚Ä¢ Orders: {dashboard_data['today_orders']}\n‚Ä¢ New Customers: {dashboard_data['today_customers']}\n\nSelect a management area:\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üí∞ Financial Dashboard\", callback_data=\"admin_financial_menu\"),\n                InlineKeyboardButton(\"üì¢ Broadcast Center\", callback_data=\"admin_broadcast_menu\")\n            ],\n            [\n                InlineKeyboardButton(\"üé´ Voucher Management\", callback_data=\"admin_voucher_menu\"),\n                InlineKeyboardButton(\"üí≥ Payment Center\", callback_data=\"admin_payment_menu\")\n            ],\n            [\n                InlineKeyboardButton(\"üëã Welcome Messages\", callback_data=\"admin_welcome_menu\"),\n                InlineKeyboardButton(\"üé´ Customer Support\", callback_data=\"admin_support_menu\")\n            ],\n            [\n                InlineKeyboardButton(\"üìä Store Analytics\", callback_data=\"admin_store_analytics\"),\n                InlineKeyboardButton(\"‚öôÔ∏è System Settings\", callback_data=\"admin_settings\")\n            ],\n            [\n                InlineKeyboardButton(\"üìà Growth Insights\", callback_data=\"admin_growth_insights\"),\n                InlineKeyboardButton(\"üîÑ System Health\", callback_data=\"admin_system_health\")\n            ],\n            [\n                InlineKeyboardButton(\"üìã Daily Report\", callback_data=\"admin_daily_report\"),\n                InlineKeyboardButton(\"üéØ Quick Actions\", callback_data=\"admin_quick_actions\")\n            ]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        if update.callback_query:\n            await update.callback_query.edit_message_text(admin_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(admin_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def _gather_dashboard_metrics(self) -> dict:\n        \"\"\"Gather key metrics from all systems\"\"\"\n        \n        # Financial metrics\n        financial_overview = self.financial_system.get_dashboard_overview(days=30)\n        today_overview = self.financial_system.get_dashboard_overview(days=1)\n        \n        # System metrics\n        pending_payments = len(self.payment_system.get_pending_payments())\n        open_tickets = len(self.support_system.get_pending_tickets())\n        active_vouchers = len(self.voucher_system.get_active_vouchers())\n        \n        # User analytics\n        welcome_analytics = self.welcome_system.get_welcome_analytics()\n        support_analytics = self.support_system.get_support_analytics()\n        \n        # Calculate system health score\n        system_health = self._calculate_system_health({\n            'pending_payments': pending_payments,\n            'open_tickets': open_tickets,\n            'resolution_rate': support_analytics.get('resolution_rate', 0)\n        })\n        \n        return {\n            'revenue': financial_overview['recent_revenue'],\n            'revenue_growth': financial_overview['revenue_growth'],\n            'orders': financial_overview['recent_orders'],\n            'order_growth': 0,  # Calculate from comparison\n            'active_customers': financial_overview['active_customers'],\n            'avg_order_value': financial_overview['avg_order_value'],\n            'pending_payments': pending_payments,\n            'open_tickets': open_tickets,\n            'active_vouchers': active_vouchers,\n            'total_users': welcome_analytics['total_users'],\n            'conversion_rate': welcome_analytics['conversion_rate'],\n            'satisfaction_rate': support_analytics.get('resolution_rate', 0),\n            'system_health': system_health,\n            'today_revenue': today_overview['recent_revenue'],\n            'today_orders': today_overview['recent_orders'],\n            'today_customers': today_overview['active_customers']\n        }\n    \n    def _calculate_system_health(self, metrics: dict) -> float:\n        \"\"\"Calculate overall system health score (0-1)\"\"\"\n        score = 1.0\n        \n        # Deduct for pending issues\n        if metrics['pending_payments'] > 10:\n            score -= 0.2\n        elif metrics['pending_payments'] > 5:\n            score -= 0.1\n        \n        if metrics['open_tickets'] > 20:\n            score -= 0.2\n        elif metrics['open_tickets'] > 10:\n            score -= 0.1\n        \n        # Factor in resolution rate\n        if metrics['resolution_rate'] < 70:\n            score -= 0.3\n        elif metrics['resolution_rate'] < 85:\n            score -= 0.1\n        \n        return max(0.0, score)\n    \n    async def show_store_analytics(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show comprehensive store analytics\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        # Gather analytics from all systems\n        financial = self.financial_system.get_dashboard_overview()\n        payment_analytics = self.payment_system.get_payment_analytics()\n        customer_analytics = self.financial_system.get_customer_spending_analytics()\n        voucher_stats = self.voucher_system.get_voucher_usage_stats()\n        \n        text = f\"\"\"\nüìä **Comprehensive Store Analytics**\n\n**üìà Revenue Analysis:**\n‚Ä¢ Total Revenue: ‚Ç±{financial['total_revenue']:,.2f}\n‚Ä¢ Monthly Growth: {financial['revenue_growth']:+.1f}%\n‚Ä¢ Average Order Value: ‚Ç±{financial['avg_order_value']:.2f}\n‚Ä¢ Pending Revenue: ‚Ç±{financial['pending_revenue']:,.2f}\n\n**üë• Customer Insights:**\n‚Ä¢ Total Customers: {customer_analytics['total_customers']:,}\n‚Ä¢ VIP Customers: {customer_analytics['vip_customers']} (‚Ç±1,000+)\n‚Ä¢ New Customers: {customer_analytics['new_customers']}\n‚Ä¢ Avg Customer Value: ‚Ç±{customer_analytics['avg_customer_value']:,.2f}\n\n**üí≥ Payment Performance:**\n‚Ä¢ Total Transactions: {payment_analytics['total_payments']:,}\n‚Ä¢ Success Rate: {payment_analytics['completion_rate']:.1f}%\n‚Ä¢ Popular Method: {payment_analytics['most_popular'][0].title() if payment_analytics.get('most_popular') else 'N/A'}\n\n**üé´ Voucher Impact:**\n‚Ä¢ Active Vouchers: {len([v for v in voucher_stats if v.get('is_active', True)])}\n‚Ä¢ Total Usage: {sum(v.get('usage_count', 0) for v in voucher_stats)}\n‚Ä¢ Customer Savings: Significant impact on retention\n\n**üí° Key Insights:**\n‚Ä¢ {'Revenue is growing steadily' if financial['revenue_growth'] > 5 else 'Revenue needs attention' if financial['revenue_growth'] < 0 else 'Revenue is stable'}\n‚Ä¢ Customer base is {'expanding rapidly' if customer_analytics['new_customers'] > 50 else 'growing steadily'}\n‚Ä¢ Payment system is {'performing well' if payment_analytics['completion_rate'] > 90 else 'needs optimization'}\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üìà Revenue Details\", callback_data=\"revenue_analytics\"),\n                InlineKeyboardButton(\"üë• Customer Analysis\", callback_data=\"customer_analytics\")\n            ],\n            [\n                InlineKeyboardButton(\"üí≥ Payment Analysis\", callback_data=\"payment_analytics\"),\n                InlineKeyboardButton(\"üé´ Voucher Analysis\", callback_data=\"voucher_analytics\")\n            ],\n            [\n                InlineKeyboardButton(\"üìä Export Data\", callback_data=\"export_analytics\"),\n                InlineKeyboardButton(\"üìã Generate Report\", callback_data=\"generate_analytics_report\")\n            ],\n            [InlineKeyboardButton(\"üîô Back to Dashboard\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_growth_insights(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show growth insights and recommendations\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        trends = self.financial_system.get_financial_trends()\n        customer_analytics = self.financial_system.get_customer_spending_analytics()\n        \n        text = f\"\"\"\nüìà **Growth Insights & Recommendations**\n\n**üöÄ Current Trends:**\n‚Ä¢ Revenue Trend: {trends['revenue_trend'].title()} {'üìà' if trends['revenue_trend'] == 'growing' else 'üìä' if trends['revenue_trend'] == 'stable' else 'üìâ'}\n‚Ä¢ Weekly Avg: ‚Ç±{trends['avg_weekly_revenue']:,.2f}\n‚Ä¢ Peak Performance: ‚Ç±{trends['peak_week']['revenue']:,.2f}\n\n**üéØ Growth Opportunities:**\n\n**1. Customer Acquisition:**\n‚Ä¢ Current: {customer_analytics['new_customers']} new customers\n‚Ä¢ Opportunity: Increase by 25% through referral program\n‚Ä¢ Action: Implement customer referral rewards\n\n**2. Customer Retention:**\n‚Ä¢ VIP Customers: {customer_analytics['vip_customers']} (high value)\n‚Ä¢ Action: Launch VIP loyalty program with exclusive perks\n\n**3. Revenue Optimization:**\n‚Ä¢ Current AOV: ‚Ç±{self.financial_system.get_dashboard_overview()['avg_order_value']:.2f}\n‚Ä¢ Target: Increase by 20% through upselling\n‚Ä¢ Action: Bundle products and cross-sell recommendations\n\n**üé™ AI-Generated Insights:**\n\"\"\"\n        \n        for insight in trends['insights'][:3]:\n            text += f\"‚Ä¢ {insight}\\n\"\n        \n        text += f\"\"\"\n\n**üìä Performance Targets:**\n‚Ä¢ Monthly Revenue: ‚Ç±{trends['avg_weekly_revenue'] * 4.3:,.0f} (current) ‚Üí ‚Ç±{trends['avg_weekly_revenue'] * 4.3 * 1.2:,.0f} (target: +20%)\n‚Ä¢ Customer Base: {customer_analytics['total_customers']} ‚Üí {int(customer_analytics['total_customers'] * 1.25)} (target: +25%)\n‚Ä¢ Conversion: {self.welcome_system.get_welcome_analytics()['conversion_rate']:.1f}% ‚Üí {self.welcome_system.get_welcome_analytics()['conversion_rate'] * 1.15:.1f}% (target: +15%)\n\n**üî• Recommended Actions:**\n1. Launch weekend flash sales with limited vouchers\n2. Create VIP customer exclusive products/early access\n3. Implement abandoned cart recovery system\n4. Optimize welcome messages for higher conversion\n5. Expand payment options to reduce friction\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üéØ Set Growth Targets\", callback_data=\"set_growth_targets\"),\n                InlineKeyboardButton(\"üí° Action Plan\", callback_data=\"growth_action_plan\")\n            ],\n            [\n                InlineKeyboardButton(\"üìä Track Progress\", callback_data=\"track_growth_progress\"),\n                InlineKeyboardButton(\"üìà Forecast Revenue\", callback_data=\"revenue_forecast\")\n            ],\n            [InlineKeyboardButton(\"üîô Back to Dashboard\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_system_health(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show system health and status\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        # Gather system health metrics\n        dashboard_data = await self._gather_dashboard_metrics()\n        \n        # System component health\n        components = {\n            'Payment System': {\n                'status': 'healthy' if dashboard_data['pending_payments'] < 10 else 'warning',\n                'metric': f\"{dashboard_data['pending_payments']} pending\",\n                'action': 'Review pending payments' if dashboard_data['pending_payments'] > 5 else 'All good'\n            },\n            'Support System': {\n                'status': 'healthy' if dashboard_data['open_tickets'] < 15 else 'warning',\n                'metric': f\"{dashboard_data['open_tickets']} open tickets\",\n                'action': 'Review tickets' if dashboard_data['open_tickets'] > 10 else 'All good'\n            },\n            'Broadcast System': {\n                'status': 'healthy',\n                'metric': 'Operational',\n                'action': 'All good'\n            },\n            'Voucher System': {\n                'status': 'healthy',\n                'metric': f\"{dashboard_data['active_vouchers']} active\",\n                'action': 'All good'\n            },\n            'Financial System': {\n                'status': 'healthy' if dashboard_data['revenue_growth'] >= 0 else 'warning',\n                'metric': f\"{dashboard_data['revenue_growth']:+.1f}% growth\",\n                'action': 'Monitor trends' if dashboard_data['revenue_growth'] < 0 else 'All good'\n            }\n        }\n        \n        text = f\"\"\"\nüîÑ **System Health Monitor**\n\n**Overall Health: {dashboard_data['system_health'] * 100:.0f}%** {'üü¢' if dashboard_data['system_health'] > 0.9 else 'üü°' if dashboard_data['system_health'] > 0.7 else 'üî¥'}\n\n**System Components:**\n\"\"\"\n        \n        for component, data in components.items():\n            status_emoji = 'üü¢' if data['status'] == 'healthy' else 'üü°'\n            text += f\"\\n{status_emoji} **{component}**\\n\"\n            text += f\"   Status: {data['metric']}\\n\"\n            text += f\"   Action: {data['action']}\\n\"\n        \n        text += f\"\"\"\n\n**Performance Metrics:**\n‚Ä¢ Database: Operational ‚úÖ\n‚Ä¢ Bot Response Time: <1 second ‚ö°\n‚Ä¢ Payment Processing: Automated ‚úÖ\n‚Ä¢ Customer Support: {dashboard_data['satisfaction_rate']:.1f}% satisfaction ‚úÖ\n\n**Recent Activity:**\n‚Ä¢ Orders processed: {dashboard_data['today_orders']} today\n‚Ä¢ Payments verified: {dashboard_data['today_revenue']:,.0f} processed\n‚Ä¢ Support responses: Automated + manual\n‚Ä¢ System uptime: 99.9%+ ‚úÖ\n\n**Maintenance Status:**\n‚Ä¢ Last backup: Today ‚úÖ\n‚Ä¢ System updates: Current ‚úÖ\n‚Ä¢ Security: All systems secure ‚úÖ\n‚Ä¢ Monitoring: Active 24/7 ‚úÖ\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üîß System Maintenance\", callback_data=\"system_maintenance\"),\n                InlineKeyboardButton(\"üìä Performance Logs\", callback_data=\"system_logs\")\n            ],\n            [\n                InlineKeyboardButton(\"‚öôÔ∏è System Settings\", callback_data=\"admin_settings\"),\n                InlineKeyboardButton(\"üõ°Ô∏è Security Status\", callback_data=\"security_status\")\n            ],\n            [InlineKeyboardButton(\"üîô Back to Dashboard\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_daily_report(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show comprehensive daily report\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        from financial_system import FinancialReporting\n        financial_reporting = FinancialReporting()\n        \n        daily_report = financial_reporting.generate_daily_report()\n        \n        # Add additional metrics\n        dashboard_data = await self._gather_dashboard_metrics()\n        \n        enhanced_report = f\"\"\"{daily_report}\n\n**üìä Additional Metrics:**\n‚Ä¢ Customer Engagement: {dashboard_data['today_customers']} new interactions\n‚Ä¢ System Performance: {dashboard_data['system_health'] * 100:.0f}% health score\n‚Ä¢ Pending Actions: {dashboard_data['pending_payments']} payments, {dashboard_data['open_tickets']} tickets\n\n**üéØ Focus Areas for Tomorrow:**\n‚Ä¢ {'Payment verification' if dashboard_data['pending_payments'] > 0 else 'All payments current'}\n‚Ä¢ {'Customer support' if dashboard_data['open_tickets'] > 0 else 'Support queue clear'}\n‚Ä¢ Revenue growth opportunities\n‚Ä¢ Customer retention initiatives\n\n**üìà Weekly Outlook:**\n‚Ä¢ On track for weekly targets\n‚Ä¢ Customer acquisition trending positive\n‚Ä¢ System health excellent\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üìä Weekly Report\", callback_data=\"generate_weekly_report\"),\n                InlineKeyboardButton(\"üìà Monthly Report\", callback_data=\"generate_monthly_report\")\n            ],\n            [\n                InlineKeyboardButton(\"üì§ Email Report\", callback_data=\"email_daily_report\"),\n                InlineKeyboardButton(\"üìã Export Data\", callback_data=\"export_daily_data\")\n            ],\n            [InlineKeyboardButton(\"üîô Back to Dashboard\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(enhanced_report, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_quick_actions(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show quick action menu\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        dashboard_data = await self._gather_dashboard_metrics()\n        \n        text = f\"\"\"\n‚ö° **Quick Actions Center**\n\n**üö® Priority Actions:**\n{f'‚Ä¢ {dashboard_data[\"pending_payments\"]} payments need verification' if dashboard_data['pending_payments'] > 0 else '‚úÖ All payments current'}\n{f'‚Ä¢ {dashboard_data[\"open_tickets\"]} support tickets need response' if dashboard_data['open_tickets'] > 0 else '‚úÖ Support queue clear'}\n\n**üéØ Common Actions:**\n‚Ä¢ Send promotional broadcast\n‚Ä¢ Create flash sale voucher\n‚Ä¢ Verify pending payments\n‚Ä¢ Respond to support tickets\n‚Ä¢ Update welcome messages\n‚Ä¢ View today's sales\n\n**üìä Quick Insights:**\n‚Ä¢ Today's revenue: ‚Ç±{dashboard_data['today_revenue']:,.2f}\n‚Ä¢ System health: {dashboard_data['system_health'] * 100:.0f}%\n‚Ä¢ Active customers: {dashboard_data['active_customers']:,}\n\nSelect a quick action:\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üì¢ Send Promo Blast\", callback_data=\"quick_promo\"),\n                InlineKeyboardButton(\"‚ö° Create Flash Sale\", callback_data=\"create_flash_sale\")\n            ],\n            [\n                InlineKeyboardButton(\"üí≥ Verify Payments\", callback_data=\"admin_pending_payments\"),\n                InlineKeyboardButton(\"üé´ Review Tickets\", callback_data=\"admin_open_tickets\")\n            ],\n            [\n                InlineKeyboardButton(\"üìä Today's Summary\", callback_data=\"admin_daily_report\"),\n                InlineKeyboardButton(\"üéØ Set Daily Goal\", callback_data=\"set_daily_goal\")\n            ],\n            [\n                InlineKeyboardButton(\"üëã Update Welcome\", callback_data=\"admin_welcome_menu\"),\n                InlineKeyboardButton(\"üé´ New Voucher\", callback_data=\"create_voucher\")\n            ],\n            [InlineKeyboardButton(\"üîô Back to Dashboard\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_admin_settings(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show admin settings and configuration\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        text = \"\"\"\n‚öôÔ∏è **System Settings**\n\n**üè™ Store Configuration:**\n‚Ä¢ Store name and branding\n‚Ä¢ Business hours and contact info\n‚Ä¢ Shipping rates and policies\n‚Ä¢ Payment method settings\n\n**üë• User Management:**\n‚Ä¢ Admin user permissions\n‚Ä¢ Customer service settings\n‚Ä¢ User data management\n‚Ä¢ Privacy settings\n\n**üîß System Features:**\n‚Ä¢ Notification preferences\n‚Ä¢ Automation settings\n‚Ä¢ Report scheduling\n‚Ä¢ Backup configuration\n\n**üõ°Ô∏è Security:**\n‚Ä¢ Access controls\n‚Ä¢ API key management\n‚Ä¢ Data encryption\n‚Ä¢ Audit logs\n\n**üìä Analytics:**\n‚Ä¢ Tracking preferences\n‚Ä¢ Report settings\n‚Ä¢ Data retention policies\n‚Ä¢ Export configurations\n\nChoose a settings category:\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üè™ Store Settings\", callback_data=\"store_settings\"),\n                InlineKeyboardButton(\"üë• User Management\", callback_data=\"user_management\")\n            ],\n            [\n                InlineKeyboardButton(\"üîß System Features\", callback_data=\"system_features\"),\n                InlineKeyboardButton(\"üõ°Ô∏è Security Settings\", callback_data=\"security_settings\")\n            ],\n            [\n                InlineKeyboardButton(\"üìä Analytics Config\", callback_data=\"analytics_config\"),\n                InlineKeyboardButton(\"üí≥ Payment Config\", callback_data=\"payment_config\")\n            ],\n            [\n                InlineKeyboardButton(\"üì§ Backup & Export\", callback_data=\"backup_export\"),\n                InlineKeyboardButton(\"üîî Notifications\", callback_data=\"notification_settings\")\n            ],\n            [InlineKeyboardButton(\"üîô Back to Dashboard\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n\n# Callback query handlers for main admin panel\ndef get_admin_panel_handlers():\n    \"\"\"Get admin panel callback handlers\"\"\"\n    admin_panel = AdminPanel()\n    \n    return [\n        CommandHandler('admin', admin_panel.admin_command),\n        CallbackQueryHandler(admin_panel.show_admin_dashboard, pattern='^admin_menu$'),\n        CallbackQueryHandler(admin_panel.show_store_analytics, pattern='^admin_store_analytics$'),\n        CallbackQueryHandler(admin_panel.show_growth_insights, pattern='^admin_growth_insights$'),\n        CallbackQueryHandler(admin_panel.show_system_health, pattern='^admin_system_health$'),\n        CallbackQueryHandler(admin_panel.show_daily_report, pattern='^admin_daily_report$'),\n        CallbackQueryHandler(admin_panel.show_quick_actions, pattern='^admin_quick_actions$'),\n        CallbackQueryHandler(admin_panel.show_admin_settings, pattern='^admin_settings$')\n    ]","size_bytes":25288},"admin_product_management.py":{"content":"\"\"\"\nAdmin Product Management Commands\nHandle product creation, stock management, and inventory control\n\"\"\"\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler, MessageHandler, filters, CallbackQueryHandler, CommandHandler\nfrom telegram.constants import ParseMode\nfrom product_catalog_system import ProductCatalogSystem, StockManagement\nfrom advanced_data_manager import AdvancedDataManager\n\n# Conversation states\nADD_PRODUCT_NAME, ADD_PRODUCT_DESCRIPTION, ADD_PRODUCT_CATEGORY, ADD_VARIANT_NAME, ADD_VARIANT_PRICE, ADD_VARIANT_STOCK, UPDATE_STOCK_AMOUNT = range(7)\n\nclass AdminProductManagement:\n    def __init__(self):\n        self.catalog_system = ProductCatalogSystem()\n        self.stock_management = StockManagement()\n        self.data_manager = AdvancedDataManager()\n    \n    async def admin_product_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Main product management menu\"\"\"\n        user_id = update.effective_user.id\n        \n        if not self._is_admin(user_id):\n            await update.message.reply_text(\"‚ùå Access denied. Admin privileges required.\")\n            return\n        \n        # Get catalog statistics\n        stats = self.catalog_system.get_catalog_stats()\n        low_stock = self.catalog_system.get_low_stock_alerts(threshold=10)\n        \n        text = f\"\"\"\nüì¶ **Product Management**\n\n**Inventory Overview:**\n‚Ä¢ Total Products: {stats['total_products']}\n‚Ä¢ Active Products: {stats['active_products']}\n‚Ä¢ Total Variants: {stats['total_variants']}\n‚Ä¢ In Stock: {stats['in_stock_variants']}\n‚Ä¢ Out of Stock: {stats['out_of_stock_variants']}\n\n**Alerts:**\n‚Ä¢ Low Stock Items: {len(low_stock)}\n‚Ä¢ Inventory Value: ‚Ç±{stats['total_inventory_value']:,.2f}\n\n**Quick Actions:**\n‚Ä¢ Add new products and variants\n‚Ä¢ Update stock levels\n‚Ä¢ Manage product categories\n‚Ä¢ View sales analytics\n\nChoose an option:\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"‚ûï Add Product\", callback_data=\"add_product\"),\n                InlineKeyboardButton(\"üì¶ Manage Stock\", callback_data=\"manage_stock\")\n            ],\n            [\n                InlineKeyboardButton(\"üìä Product Analytics\", callback_data=\"product_analytics\"),\n                InlineKeyboardButton(\"‚ö†Ô∏è Low Stock Alerts\", callback_data=\"low_stock_alerts\")\n            ],\n            [\n                InlineKeyboardButton(\"üè∑Ô∏è Manage Categories\", callback_data=\"manage_categories\"),\n                InlineKeyboardButton(\"üìã All Products\", callback_data=\"admin_all_products\")\n            ],\n            [InlineKeyboardButton(\"üîô Back to Admin\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_add_product_menu(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show add product menu\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        text = \"\"\"\n‚ûï **Add New Product**\n\nCreate a new product with variants:\n\n**Steps:**\n1. Choose product category\n2. Enter product name\n3. Add description\n4. Create variants with pricing\n5. Set initial stock\n\n**Product Types:**\n‚Ä¢ Single variant (one price, one option)\n‚Ä¢ Multiple variants (different durations, features)\n‚Ä¢ Service tiers (basic, premium, pro)\n\nChoose a category for your new product:\n        \"\"\"\n        \n        categories = self.catalog_system.get_categories()\n        keyboard = []\n        \n        for category in categories:\n            keyboard.append([InlineKeyboardButton(\n                f\"{category['emoji']} {category['name']}\",\n                callback_data=f\"newprod_cat_{category['id']}\"\n            )])\n        \n        keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_product_menu\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def start_add_product(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Start product creation process\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        category_id = query.data.replace(\"newprod_cat_\", \"\")\n        category = self.catalog_system.get_category(category_id)\n        \n        if not category:\n            await query.edit_message_text(\"‚ùå Invalid category selected.\")\n            return ConversationHandler.END\n        \n        context.user_data['new_product'] = {'category_id': category_id}\n        \n        text = f\"\"\"\n‚ûï **Add Product - Step 1/4**\n\n**Category:** {category['emoji']} {category['name']}\n\n**Enter Product Name:**\n\nExamples for {category['name']}:\n‚Ä¢ \"NETFLIX PREMIUM ACCOUNTS\"\n‚Ä¢ \"30D AUTO PLUG SERVICE\"\n‚Ä¢ \"SPOTIFY FAMILY PLAN\"\n\nType the product name:\n        \"\"\"\n        \n        keyboard = [[InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"admin_product_menu\")]]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return ADD_PRODUCT_NAME\n    \n    async def get_product_name(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get product name\"\"\"\n        product_name = update.message.text.strip()\n        \n        if len(product_name) < 5:\n            await update.message.reply_text(\"‚ùå Product name must be at least 5 characters. Try again:\")\n            return ADD_PRODUCT_NAME\n        \n        if len(product_name) > 100:\n            await update.message.reply_text(\"‚ùå Product name too long (max 100 characters). Try again:\")\n            return ADD_PRODUCT_NAME\n        \n        context.user_data['new_product']['name'] = product_name\n        \n        text = f\"\"\"\n‚ûï **Add Product - Step 2/4**\n\n**Product Name:** {product_name}\n\n**Enter Product Description:**\n\nWrite a clear description that explains what this product offers:\n\n**Examples:**\n‚Ä¢ \"Premium Netflix accounts with 4K streaming, 4 simultaneous screens, and download feature.\"\n‚Ä¢ \"24/7 automated plug service with instant delivery and lifetime support.\"\n‚Ä¢ \"Professional Spotify Family plan for up to 6 users with ad-free music.\"\n\nType the product description:\n        \"\"\"\n        \n        await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)\n        return ADD_PRODUCT_DESCRIPTION\n    \n    async def get_product_description(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get product description\"\"\"\n        description = update.message.text.strip()\n        \n        if len(description) < 20:\n            await update.message.reply_text(\"‚ùå Description must be at least 20 characters. Try again:\")\n            return ADD_PRODUCT_DESCRIPTION\n        \n        context.user_data['new_product']['description'] = description\n        \n        text = f\"\"\"\n‚úÖ **Product Information Complete**\n\n**Name:** {context.user_data['new_product']['name']}\n**Description:** {description[:100]}{'...' if len(description) > 100 else ''}\n\n**Now let's add variants:**\n\nVariants are different options for your product (e.g., 1 month, 3 months, lifetime).\n\n**Enter first variant name:**\n\n**Examples:**\n‚Ä¢ \"1 Month Premium\"\n‚Ä¢ \"01D NONSTOP PLUG\"\n‚Ä¢ \"Basic Plan\"\n‚Ä¢ \"Lifetime License\"\n\nType the variant name:\n        \"\"\"\n        \n        context.user_data['new_product']['variants'] = []\n        \n        await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)\n        return ADD_VARIANT_NAME\n    \n    async def get_variant_name(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get variant name\"\"\"\n        variant_name = update.message.text.strip()\n        \n        if len(variant_name) < 3:\n            await update.message.reply_text(\"‚ùå Variant name must be at least 3 characters. Try again:\")\n            return ADD_VARIANT_NAME\n        \n        context.user_data['current_variant'] = {'name': variant_name}\n        \n        text = f\"\"\"\nüí∞ **Variant: {variant_name}**\n\n**Enter the price for this variant:**\n\n**Price Guidelines:**\n‚Ä¢ Enter numbers only (e.g., 150)\n‚Ä¢ Minimum: ‚Ç±1\n‚Ä¢ Maximum: ‚Ç±50,000\n‚Ä¢ No decimal places\n\nType the price in pesos:\n        \"\"\"\n        \n        await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)\n        return ADD_VARIANT_PRICE\n    \n    async def get_variant_price(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get variant price\"\"\"\n        try:\n            price = float(update.message.text.strip())\n            \n            if price < 1:\n                await update.message.reply_text(\"‚ùå Price must be at least ‚Ç±1. Try again:\")\n                return ADD_VARIANT_PRICE\n            \n            if price > 50000:\n                await update.message.reply_text(\"‚ùå Price too high (max ‚Ç±50,000). Try again:\")\n                return ADD_VARIANT_PRICE\n            \n        except ValueError:\n            await update.message.reply_text(\"‚ùå Please enter a valid number. Try again:\")\n            return ADD_VARIANT_PRICE\n        \n        context.user_data['current_variant']['price'] = price\n        \n        text = f\"\"\"\nüì¶ **Stock Level**\n\n**Variant:** {context.user_data['current_variant']['name']}\n**Price:** ‚Ç±{price:.2f}\n\n**Enter initial stock quantity:**\n\n**Stock Guidelines:**\n‚Ä¢ Enter whole numbers only\n‚Ä¢ 0 = Out of stock\n‚Ä¢ Maximum: 10,000 units\n\nHow many units do you have in stock?\n        \"\"\"\n        \n        await update.message.reply_text(text, parse_mode=ParseMode.MARKDOWN)\n        return ADD_VARIANT_STOCK\n    \n    async def get_variant_stock(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Get variant stock and create product\"\"\"\n        try:\n            stock = int(update.message.text.strip())\n            \n            if stock < 0:\n                await update.message.reply_text(\"‚ùå Stock cannot be negative. Try again:\")\n                return ADD_VARIANT_STOCK\n            \n            if stock > 10000:\n                await update.message.reply_text(\"‚ùå Stock too high (max 10,000). Try again:\")\n                return ADD_VARIANT_STOCK\n            \n        except ValueError:\n            await update.message.reply_text(\"‚ùå Please enter a whole number. Try again:\")\n            return ADD_VARIANT_STOCK\n        \n        # Complete variant\n        variant = context.user_data['current_variant']\n        variant['stock'] = stock\n        variant['features'] = ['High quality', 'Instant delivery', 'Customer support']\n        variant['duration'] = 'As specified'\n        \n        # Add to product\n        context.user_data['new_product']['variants'].append(variant)\n        \n        # Create the product\n        result = self._create_new_product(context.user_data['new_product'])\n        \n        if result['success']:\n            text = f\"\"\"\nüéâ **Product Created Successfully!**\n\n‚úÖ **{result['product']['name']}** has been added to your store.\n\n**Product Details:**\n‚Ä¢ Category: {result['category']['name']}\n‚Ä¢ Variants: {len(result['product']['variants'])}\n‚Ä¢ Initial Stock: {stock} units\n\n**First Variant:**\n‚Ä¢ Name: {variant['name']}\n‚Ä¢ Price: ‚Ç±{variant['price']:.2f}\n‚Ä¢ Stock: {stock}\n\n**Next Steps:**\n‚Ä¢ Add more variants if needed\n‚Ä¢ Update product images\n‚Ä¢ Set up promotional campaigns\n‚Ä¢ Monitor sales performance\n\nYour product is now live and ready for customers! üõçÔ∏è\n            \"\"\"\n            \n            keyboard = [\n                [\n                    InlineKeyboardButton(\"‚ûï Add Another Product\", callback_data=\"add_product\"),\n                    InlineKeyboardButton(\"üì¶ Manage Stock\", callback_data=\"manage_stock\")\n                ],\n                [\n                    InlineKeyboardButton(\"üìä Product Analytics\", callback_data=\"product_analytics\"),\n                    InlineKeyboardButton(\"üè† Admin Menu\", callback_data=\"admin_menu\")\n                ]\n            ]\n        else:\n            text = f\"‚ùå **Failed to create product:**\\n\\n{result['message']}\"\n            keyboard = [\n                [InlineKeyboardButton(\"üîÑ Try Again\", callback_data=\"add_product\")],\n                [InlineKeyboardButton(\"üè† Admin Menu\", callback_data=\"admin_menu\")]\n            ]\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        context.user_data.clear()\n        return ConversationHandler.END\n    \n    async def show_manage_stock(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show stock management interface\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        # Get all products with stock info\n        categories = self.catalog_system.get_categories()\n        low_stock = self.catalog_system.get_low_stock_alerts(threshold=10)\n        \n        text = f\"\"\"\nüì¶ **Stock Management**\n\n**Stock Overview:**\n‚Ä¢ Low Stock Items: {len(low_stock)}\n‚Ä¢ Categories: {len(categories)}\n\n**Quick Actions:**\n‚Ä¢ Update stock levels for existing products\n‚Ä¢ View products running low on stock\n‚Ä¢ Bulk stock updates\n\nChoose how to manage stock:\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"‚ö†Ô∏è Low Stock Items\", callback_data=\"view_low_stock\"),\n                InlineKeyboardButton(\"üìã All Products\", callback_data=\"stock_all_products\")\n            ],\n            [\n                InlineKeyboardButton(\"üè∑Ô∏è By Category\", callback_data=\"stock_by_category\"),\n                InlineKeyboardButton(\"üîç Search Product\", callback_data=\"stock_search\")\n            ],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"admin_product_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_low_stock_alerts(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show low stock alerts\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        low_stock = self.catalog_system.get_low_stock_alerts(threshold=10)\n        \n        if not low_stock:\n            text = \"\"\"\n‚úÖ **All Stock Levels Good!**\n\nNo products are running low on stock.\n\n**Current Threshold:** 10 units\n**Recommendation:** Keep monitoring daily\n\nGreat job maintaining your inventory! üëç\n            \"\"\"\n            keyboard = [[InlineKeyboardButton(\"üì¶ Manage Stock\", callback_data=\"manage_stock\")]]\n        else:\n            text = f\"\"\"\n‚ö†Ô∏è **Low Stock Alerts ({len(low_stock)} items)**\n\nThe following products need restocking:\n\n\"\"\"\n            keyboard = []\n            \n            for item in low_stock[:10]:  # Show top 10\n                stock_emoji = \"üî¥\" if item['current_stock'] <= 3 else \"üü°\"\n                text += f\"{stock_emoji} **{item['variant_name']}**\\n\"\n                text += f\"   Stock: {item['current_stock']} units\\n\"\n                text += f\"   Price: ‚Ç±{item['price']:.2f}\\n\"\n                text += f\"   Category: {item['category']}\\n\\n\"\n                \n                # Add quick restock button\n                keyboard.append([InlineKeyboardButton(\n                    f\"üì¶ Restock {item['variant_name']}\",\n                    callback_data=f\"restock_{item['variant_name'][:20]}\"\n                )])\n            \n            keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"manage_stock\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_stock_by_category(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show stock management by category\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        categories = self.catalog_system.get_categories()\n        \n        text = \"\"\"\nüè∑Ô∏è **Stock by Category**\n\nChoose a category to manage stock:\n        \"\"\"\n        \n        keyboard = []\n        for category in categories:\n            products = self.catalog_system.get_products_by_category(category['id'])\n            keyboard.append([InlineKeyboardButton(\n                f\"{category['emoji']} {category['name']} ({len(products)} products)\",\n                callback_data=f\"stock_cat_{category['id']}\"\n            )])\n        \n        keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"manage_stock\")])\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    def _create_new_product(self, product_data: dict) -> dict:\n        \"\"\"Create new product in database\"\"\"\n        try:\n            # Generate product ID\n            import uuid\n            product_id = f\"product_{uuid.uuid4().hex[:8]}\"\n            \n            # Assign variant IDs\n            for i, variant in enumerate(product_data['variants'], 1):\n                variant['id'] = i\n                variant['popular'] = False\n            \n            # Create product record\n            new_product = {\n                'id': product_id,\n                'category_id': product_data['category_id'],\n                'name': product_data['name'],\n                'description': product_data['description'],\n                'base_price': product_data['variants'][0]['price'],\n                'active': True,\n                'variants': product_data['variants'],\n                'created_at': __import__('datetime').datetime.utcnow().isoformat()\n            }\n            \n            # In real implementation, save to database\n            # self.data_manager.create_product(new_product)\n            \n            # Get category info\n            category = self.catalog_system.get_category(product_data['category_id'])\n            \n            return {\n                'success': True,\n                'product': new_product,\n                'category': category\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error creating product: {str(e)}'\n            }\n    \n    def _is_admin(self, user_id):\n        \"\"\"Check if user is admin\"\"\"\n        admin_ids = [123456789]  # Replace with actual admin IDs\n        return user_id in admin_ids\n    \n    async def cancel_product_creation(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Cancel product creation\"\"\"\n        if update.callback_query:\n            await update.callback_query.edit_message_text(\"‚ùå Product creation cancelled.\")\n        else:\n            await update.message.reply_text(\"‚ùå Product creation cancelled.\")\n        \n        context.user_data.clear()\n        return ConversationHandler.END\n\ndef get_admin_product_conversation_handler():\n    \"\"\"Get conversation handler for admin product management\"\"\"\n    admin_product = AdminProductManagement()\n    \n    return ConversationHandler(\n        entry_points=[\n            CallbackQueryHandler(admin_product.start_add_product, pattern=\"^newprod_cat_\")\n        ],\n        states={\n            ADD_PRODUCT_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_product.get_product_name)],\n            ADD_PRODUCT_DESCRIPTION: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_product.get_product_description)],\n            ADD_VARIANT_NAME: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_product.get_variant_name)],\n            ADD_VARIANT_PRICE: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_product.get_variant_price)],\n            ADD_VARIANT_STOCK: [MessageHandler(filters.TEXT & ~filters.COMMAND, admin_product.get_variant_stock)]\n        },\n        fallbacks=[\n            CallbackQueryHandler(admin_product.cancel_product_creation, pattern=\"^admin_product_menu$\"),\n            CommandHandler('cancel', admin_product.cancel_product_creation)\n        ],\n        per_message=False\n    )\n\ndef get_admin_product_handlers():\n    \"\"\"Get admin product management handlers\"\"\"\n    admin_product = AdminProductManagement()\n    \n    return [\n        CallbackQueryHandler(admin_product.admin_product_menu, pattern=\"^admin_product_menu$\"),\n        CallbackQueryHandler(admin_product.show_add_product_menu, pattern=\"^add_product$\"),\n        CallbackQueryHandler(admin_product.show_manage_stock, pattern=\"^manage_stock$\"),\n        CallbackQueryHandler(admin_product.show_low_stock_alerts, pattern=\"^low_stock_alerts$\"),\n        CallbackQueryHandler(admin_product.show_stock_by_category, pattern=\"^stock_by_category$\")\n    ]","size_bytes":20820},"balance_commands.py":{"content":"\"\"\"\nBalance System Commands for Telegram Bot\nHandles balance top-ups, deposits, and balance management\n\"\"\"\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler, MessageHandler, filters, CallbackQueryHandler, CommandHandler\nfrom telegram.constants import ParseMode\nfrom balance_system import BalanceSystem, DepositNotifications\nfrom advanced_data_manager import AdvancedDataManager\n\n# Conversation states\nCUSTOM_AMOUNT, UPLOAD_PROOF = range(2)\n\nclass BalanceCommands:\n    def __init__(self, bot_token):\n        self.bot_token = bot_token\n        self.balance_system = BalanceSystem()\n        self.data_manager = AdvancedDataManager()\n        self.notifications = DepositNotifications(bot_token)\n    \n    async def deposit_balance_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Main deposit balance command\"\"\"\n        user_telegram_id = str(update.effective_user.id)\n        user_name = update.effective_user.first_name or \"there\"\n        \n        # Get user balance info\n        balance_info = self.balance_system.get_user_balance(user_telegram_id)\n        \n        text = f\"\"\"\nüí≥ **Top Up Balance**\n\n**Current Balance:** ‚Ç±{balance_info['balance']:,.2f}\n**Total Deposited:** ‚Ç±{balance_info['total_deposited']:,.2f}\n\nüí∞ Choose a nominal below or type a custom amount.\n\n**Quick Amounts:**\n        \"\"\"\n        \n        # Create keyboard with suggested amounts\n        suggested_amounts = self.balance_system.get_suggested_amounts()\n        keyboard = []\n        \n        # Add buttons in rows of 2\n        for i in range(0, len(suggested_amounts), 2):\n            row = []\n            for j in range(2):\n                if i + j < len(suggested_amounts):\n                    amount = suggested_amounts[i + j]\n                    row.append(InlineKeyboardButton(f\"‚Ç±{amount}\", callback_data=f\"deposit_{amount}\"))\n            keyboard.append(row)\n        \n        # Add custom amount and back buttons\n        keyboard.append([InlineKeyboardButton(\"üí¨ Other Amount\", callback_data=\"custom_amount\")])\n        keyboard.append([InlineKeyboardButton(\"üîô Back\", callback_data=\"main_menu\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def check_balance_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Check balance command\"\"\"\n        user_telegram_id = str(update.effective_user.id)\n        user = self.data_manager.get_or_create_user(user_telegram_id, update.effective_user.first_name)\n        \n        # Get comprehensive balance info\n        balance_info = self.balance_system.get_user_balance(user_telegram_id)\n        deposit_history = self.balance_system.get_deposit_history(user_telegram_id, limit=5)\n        \n        # Format user info like the premium bot\n        text = f\"\"\"\nüìä **User Details:**\n‚Ä¢ ID: {user_telegram_id}\n‚Ä¢ Name: {user.get('first_name', 'Unknown')}\n‚Ä¢ Balance: ‚Ç±{balance_info['balance']:,.2f}\n‚Ä¢ Total Spent: ‚Ç±{balance_info['total_spent']:,.2f}\n\nüí∞ **Balance Summary:**\n‚Ä¢ Current Balance: ‚Ç±{balance_info['balance']:,.2f}\n‚Ä¢ Total Deposited: ‚Ç±{balance_info['total_deposited']:,.2f}\n‚Ä¢ Pending Deposits: {len(balance_info['pending_deposits'])}\n\n\"\"\"\n        \n        if deposit_history:\n            text += \"üìà **Recent Deposits:**\\n\"\n            for deposit in deposit_history[:3]:\n                status_emoji = {\n                    'completed': '‚úÖ',\n                    'pending': '‚è≥',\n                    'proof_submitted': 'üìÑ',\n                    'cancelled': '‚ùå'\n                }.get(deposit['status'], '‚ùì')\n                \n                date = deposit['created_at'][:10]  # YYYY-MM-DD\n                text += f\"‚Ä¢ {status_emoji} ‚Ç±{deposit['amount']:.2f} ({date})\\n\"\n        \n        text += \"\\nüõçÔ∏è Ready to shop with your balance!\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üí≥ Top Up\", callback_data=\"deposit_balance\"),\n                InlineKeyboardButton(\"üìú Full History\", callback_data=\"deposit_history\")\n            ],\n            [\n                InlineKeyboardButton(\"üõí Browse Products\", callback_data=\"browse_products\"),\n                InlineKeyboardButton(\"üîô Main Menu\", callback_data=\"main_menu\")\n            ]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def handle_deposit_amount(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle deposit amount selection\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        user_telegram_id = str(update.effective_user.id)\n        \n        if query.data == \"custom_amount\":\n            # Ask for custom amount\n            text = \"\"\"\nüí¨ **Enter Custom Amount**\n\nPlease enter the amount you want to deposit:\n\n**Minimum:** ‚Ç±20\n**Maximum:** ‚Ç±10,000\n\nType the amount in numbers only (e.g., 150)\n            \"\"\"\n            \n            keyboard = [[InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"deposit_balance\")]]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            return CUSTOM_AMOUNT\n        \n        elif query.data.startswith(\"deposit_\"):\n            # Handle preset amount\n            amount = float(query.data.replace(\"deposit_\", \"\"))\n            return await self.create_deposit(query, user_telegram_id, amount)\n    \n    async def handle_custom_amount(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle custom amount input\"\"\"\n        try:\n            amount = float(update.message.text.strip())\n            user_telegram_id = str(update.effective_user.id)\n            \n            # Validate amount\n            validation = self.balance_system.validate_deposit_amount(amount)\n            if not validation['valid']:\n                await update.message.reply_text(\n                    f\"‚ùå {validation['message']}\\n\\nPlease try again:\"\n                )\n                return CUSTOM_AMOUNT\n            \n            return await self.create_deposit(update, user_telegram_id, amount)\n            \n        except ValueError:\n            await update.message.reply_text(\n                \"‚ùå Please enter a valid number.\\n\\nExample: 150\"\n            )\n            return CUSTOM_AMOUNT\n    \n    async def create_deposit(self, update, user_telegram_id: str, amount: float):\n        \"\"\"Create deposit and show payment options\"\"\"\n        \n        # Create manual deposit\n        result = self.balance_system.create_manual_deposit(\n            user_telegram_id=user_telegram_id,\n            amount=amount,\n            payment_method='gcash'  # Default to GCash\n        )\n        \n        if not result['success']:\n            if hasattr(update, 'callback_query'):\n                await update.callback_query.edit_message_text(f\"‚ùå {result['message']}\")\n            else:\n                await update.message.reply_text(f\"‚ùå {result['message']}\")\n            return ConversationHandler.END\n        \n        deposit = result['deposit']\n        qr_info = result['qr_code_data']\n        \n        # Create payment display like in the premium bot\n        text = f\"\"\"\nüí≥ **Manual Deposit Created**\n\n**ID:** #{deposit['deposit_id']}\n**Method:** {deposit['payment_method'].upper()} (manual, no fee)\n**Total payment:** ‚Ç±{amount:.0f}\n\nüì± **InstaPay QR Code**\nScan the QR code above to pay\n\n{qr_info['instructions']}\n\n‚è±Ô∏è **Upload proof or press the button after payment.**\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üìÑ Upload Proof\", callback_data=f\"upload_proof_{deposit['deposit_id']}\")],\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"cancel_deposit\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"deposit_balance\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        # Send QR code simulation (in real implementation, generate actual QR)\n        qr_text = f\"\"\"\n```\n‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\n‚ñì                   ‚ñì\n‚ñì  üì± InstaPay      ‚ñì\n‚ñì                   ‚ñì\n‚ñì     ‚Ç±{amount:.2f}      ‚ñì\n‚ñì                   ‚ñì\n‚ñì  DEP{deposit['deposit_id']:>04}         ‚ñì\n‚ñì                   ‚ñì\n‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì‚ñì\n```\n\n{text}\n        \"\"\"\n        \n        if hasattr(update, 'callback_query'):\n            await update.callback_query.edit_message_text(qr_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(qr_text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        # Store deposit ID for later use\n        context.user_data['current_deposit_id'] = deposit['deposit_id']\n        \n        # Notify user about deposit creation\n        await self.notifications.notify_deposit_created(user_telegram_id, deposit)\n        \n        return ConversationHandler.END\n    \n    async def handle_upload_proof(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle proof upload button\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        deposit_id = query.data.replace(\"upload_proof_\", \"\")\n        \n        text = \"\"\"\nüìÑ **Upload Payment Proof**\n\nPlease send the payment proof as a photo.\n\n**Requirements:**\n‚Ä¢ Clear screenshot of payment confirmation\n‚Ä¢ Include transaction reference number\n‚Ä¢ Amount must match your deposit\n‚Ä¢ Upload within 30 minutes\n\nSend your screenshot now:\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"main_menu\")],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"deposit_balance\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        # Store deposit ID for proof upload\n        context.user_data['upload_deposit_id'] = deposit_id\n        return UPLOAD_PROOF\n    \n    async def handle_proof_photo(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle proof photo upload\"\"\"\n        user_telegram_id = str(update.effective_user.id)\n        deposit_id = context.user_data.get('upload_deposit_id')\n        \n        if not deposit_id:\n            await update.message.reply_text(\"‚ùå No deposit found. Please start a new deposit.\")\n            return ConversationHandler.END\n        \n        # Process proof submission\n        result = self.balance_system.submit_deposit_proof(deposit_id, user_telegram_id)\n        \n        if result['success']:\n            # NO MESSAGE TO CUSTOMER - exactly like primostorebot\n            # Just save the receipt silently, no confirmation\n            pass\n            \n        else:\n            await update.message.reply_text(f\"‚ùå {result['message']}\")\n        \n        return ConversationHandler.END\n    \n    # Removed auto-approval simulation - primostorebot requires manual approval only\n    \n    async def show_deposit_history(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show full deposit history\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        user_telegram_id = str(update.effective_user.id)\n        history = self.balance_system.get_deposit_history(user_telegram_id, limit=20)\n        \n        if not history:\n            text = \"üìú **Deposit History**\\n\\nNo deposits found. Make your first deposit to start shopping!\"\n        else:\n            text = f\"üìú **Deposit History ({len(history)} deposits)**\\n\\n\"\n            \n            for deposit in history:\n                status_emoji = {\n                    'completed': '‚úÖ',\n                    'pending': '‚è≥',\n                    'proof_submitted': 'üìÑ',\n                    'cancelled': '‚ùå'\n                }.get(deposit['status'], '‚ùì')\n                \n                status_text = {\n                    'completed': 'Approved',\n                    'pending': 'Pending Payment',\n                    'proof_submitted': 'Under Review',\n                    'cancelled': 'Cancelled'\n                }.get(deposit['status'], 'Unknown')\n                \n                date = deposit['created_at'][:16].replace('T', ' ')  # Format date\n                text += f\"**#{deposit['deposit_id']}** {status_emoji}\\n\"\n                text += f\"‚Ä¢ Amount: ‚Ç±{deposit['amount']:.2f}\\n\"\n                text += f\"‚Ä¢ Status: {status_text}\\n\"\n                text += f\"‚Ä¢ Date: {date}\\n\"\n                text += f\"‚Ä¢ Method: {deposit['payment_method'].title()}\\n\\n\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üí≥ New Deposit\", callback_data=\"deposit_balance\"),\n                InlineKeyboardButton(\"üí∞ Check Balance\", callback_data=\"check_balance\")\n            ],\n            [InlineKeyboardButton(\"üîô Back\", callback_data=\"main_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def admin_balance_management(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Admin balance management menu\"\"\"\n        user_id = update.effective_user.id\n        \n        # Check admin permissions\n        if not self._is_admin(user_id):\n            await update.message.reply_text(\"‚ùå Access denied. Admin privileges required.\")\n            return\n        \n        # Get balance analytics\n        analytics = self.balance_system.get_balance_analytics()\n        pending_deposits = self.data_manager.get_deposits_by_status('proof_submitted')\n        \n        text = f\"\"\"\nüí≥ **Balance Management**\n\n**System Overview:**\n‚Ä¢ Total Deposits: ‚Ç±{analytics['total_deposits']:,.2f}\n‚Ä¢ Pending Reviews: {analytics['pending_deposits_count']} (‚Ç±{analytics['pending_deposits_amount']:,.2f})\n‚Ä¢ Active Balances: ‚Ç±{analytics['total_user_balance']:,.2f}\n‚Ä¢ Users with Balance: {analytics['active_users_with_balance']}\n\n**Pending Actions:**\n‚Ä¢ {len(pending_deposits)} deposits need verification\n\n**Top Users by Balance:**\n\"\"\"\n        \n        for user in analytics['top_users'][:3]:\n            text += f\"‚Ä¢ {user['first_name']}: ‚Ç±{user['balance']:,.2f}\\n\"\n        \n        keyboard = [\n            [InlineKeyboardButton(f\"üìÑ Review Deposits ({len(pending_deposits)})\", callback_data=\"admin_review_deposits\")],\n            [InlineKeyboardButton(\"üìä Balance Analytics\", callback_data=\"admin_balance_analytics\")],\n            [InlineKeyboardButton(\"üë• User Balances\", callback_data=\"admin_user_balances\")],\n            [InlineKeyboardButton(\"üîô Back to Admin\", callback_data=\"admin_menu\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    def _is_admin(self, user_id):\n        \"\"\"Check if user is admin\"\"\"\n        admin_ids = [123456789]  # Replace with actual admin IDs\n        return user_id in admin_ids\n    \n    async def cancel_deposit(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Cancel deposit creation\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        await query.edit_message_text(\n            \"‚ùå **Deposit Cancelled**\\n\\nYour deposit has been cancelled. You can start a new deposit anytime.\",\n            parse_mode=ParseMode.MARKDOWN\n        )\n        \n        context.user_data.clear()\n        return ConversationHandler.END\n\ndef get_balance_conversation_handler(bot_token):\n    \"\"\"Get conversation handler for balance system\"\"\"\n    balance_commands = BalanceCommands(bot_token)\n    \n    return ConversationHandler(\n        entry_points=[\n            CallbackQueryHandler(balance_commands.handle_deposit_amount, pattern=\"^(deposit_|custom_amount)\"),\n            CallbackQueryHandler(balance_commands.handle_upload_proof, pattern=\"^upload_proof_\")\n        ],\n        states={\n            CUSTOM_AMOUNT: [MessageHandler(filters.TEXT & ~filters.COMMAND, balance_commands.handle_custom_amount)],\n            UPLOAD_PROOF: [MessageHandler(filters.PHOTO, balance_commands.handle_proof_photo)]\n        },\n        fallbacks=[\n            CallbackQueryHandler(balance_commands.cancel_deposit, pattern=\"^(cancel_deposit|main_menu)$\"),\n            CommandHandler('cancel', balance_commands.cancel_deposit)\n        ],\n        per_message=False\n    )\n\ndef get_balance_callback_handlers(bot_token):\n    \"\"\"Get balance system callback handlers\"\"\"\n    balance_commands = BalanceCommands(bot_token)\n    \n    return [\n        CallbackQueryHandler(balance_commands.deposit_balance_command, pattern=\"^deposit_balance$\"),\n        CallbackQueryHandler(balance_commands.check_balance_command, pattern=\"^check_balance$\"),\n        CallbackQueryHandler(balance_commands.show_deposit_history, pattern=\"^deposit_history$\")\n    ]","size_bytes":17311},"balance_system.py":{"content":"\"\"\"\nUser Balance and Credit System\nHandles user deposits, balance management, and spending tracking\n\"\"\"\nimport uuid\nfrom datetime import datetime, timedelta\nfrom typing import Dict, List, Optional, Tuple\nfrom simple_data_manager import SimpleDataManager\n\nclass BalanceSystem:\n    def __init__(self):\n        self.data_manager = SimpleDataManager()\n    \n    def get_user_balance(self, user_telegram_id: str) -> Dict:\n        \"\"\"Get user's current balance and spending history\"\"\"\n        user = self.data_manager.get_or_create_user(user_telegram_id)\n        \n        return {\n            'balance': user.get('balance', 0.0),\n            'total_deposited': user.get('total_deposited', 0.0),\n            'total_spent': user.get('total_spent', 0.0),\n            'pending_deposits': self._get_pending_deposits(user_telegram_id)\n        }\n    \n    def create_manual_deposit(self, \n                            user_telegram_id: str, \n                            amount: float, \n                            payment_method: str = 'gcash') -> Dict:\n        \"\"\"Create a manual deposit request\"\"\"\n        \n        if amount < 20:\n            return {\n                'success': False,\n                'message': 'Minimum deposit is ‚Ç±20'\n            }\n        \n        if amount > 10000:\n            return {\n                'success': False,\n                'message': 'Maximum deposit is ‚Ç±10,000'\n            }\n        \n        try:\n            # Generate deposit ID\n            deposit_id = len(self.data_manager.get_deposits()) + 1\n            \n            # Create deposit record\n            deposit = self.data_manager.create_deposit(\n                user_telegram_id=user_telegram_id,\n                deposit_id=str(deposit_id),\n                amount=amount,\n                payment_method=payment_method,\n                status='pending'\n            )\n            \n            if deposit:\n                return {\n                    'success': True,\n                    'deposit': deposit,\n                    'qr_code_data': self._generate_payment_qr(amount, deposit_id, payment_method),\n                    'message': f'Manual deposit #{deposit_id} created successfully'\n                }\n            else:\n                return {\n                    'success': False,\n                    'message': 'Failed to create deposit'\n                }\n                \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error creating deposit: {str(e)}'\n            }\n    \n    def _generate_payment_qr(self, amount: float, deposit_id: int, method: str) -> Dict:\n        \"\"\"Generate payment QR code data\"\"\"\n        \n        # In real implementation, integrate with actual payment providers\n        qr_data = {\n            'method': method,\n            'amount': amount,\n            'deposit_id': deposit_id,\n            'reference': f\"DEP{deposit_id:04d}\",\n            'instructions': self._get_payment_instructions(method, amount)\n        }\n        \n        return qr_data\n    \n    def _get_payment_instructions(self, method: str, amount: float) -> str:\n        \"\"\"Get payment instructions for different methods\"\"\"\n        \n        instructions = {\n            'gcash': f\"\"\"\n**GCash Payment Instructions:**\n\n1. Open your GCash app\n2. Scan the QR code above\n3. Pay exactly ‚Ç±{amount:.2f}\n4. Take a screenshot of the receipt\n5. Upload the proof using the button below\n\n**Important:**\n‚Ä¢ Pay the EXACT amount shown\n‚Ä¢ Take a clear screenshot\n‚Ä¢ Upload within 30 minutes\n\nüìû **Contact:** 09911127180 mb\nüìß **Send receipt üßæ**\n‚ö†Ô∏è **No receipt no process**\n\n**Other payment methods are available. Just ask.**\n**Join main channel here**\n            \"\"\",\n            'paymaya': f\"\"\"\n**PayMaya Payment Instructions:**\n\n1. Open your PayMaya app\n2. Scan the QR code above\n3. Pay exactly ‚Ç±{amount:.2f}\n4. Screenshot the confirmation\n5. Upload proof using the button below\n\n**Note:** Processing takes 1-5 minutes\n\nüìû **Contact:** 09911127180 mb\nüìß **Send receipt üßæ**\n‚ö†Ô∏è **No receipt no process**\n\n**Other payment methods are available. Just ask.**\n**Join main channel here**\n            \"\"\",\n            'instapay': f\"\"\"\n**InstaPay Instructions:**\n\n1. Use any InstaPay-enabled app\n2. Scan the QR code\n3. Send exactly ‚Ç±{amount:.2f}\n4. Save the transaction receipt\n5. Upload proof below\n\n**Supported Apps:**\n‚Ä¢ GCash ‚Ä¢ PayMaya ‚Ä¢ UnionBank ‚Ä¢ BPI ‚Ä¢ etc.\n\nüìû **Contact:** 09911127180 mb\nüìß **Send receipt üßæ**\n‚ö†Ô∏è **No receipt no process**\n\n**Other payment methods are available. Just ask.**\n**Join main channel here**\n            \"\"\"\n        }\n        \n        return instructions.get(method, f\"Pay exactly ‚Ç±{amount:.2f} and upload proof\")\n    \n    def submit_deposit_proof(self, deposit_id: str, user_telegram_id: str) -> Dict:\n        \"\"\"Process deposit proof submission\"\"\"\n        \n        try:\n            # Update deposit status to proof_submitted\n            result = self.data_manager.update_deposit_status(\n                deposit_id, \n                'proof_submitted',\n                f'Proof submitted by user {user_telegram_id}'\n            )\n            \n            if result:\n                # In real implementation, this would trigger admin notification\n                return {\n                    'success': True,\n                    'message': f'Proof submitted for deposit #{deposit_id}. Your deposit is being verified and will be processed within 5 minutes.',\n                    'estimated_time': '5 minutes'\n                }\n            else:\n                return {\n                    'success': False,\n                    'message': 'Failed to submit proof'\n                }\n                \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error submitting proof: {str(e)}'\n            }\n    \n    def approve_deposit(self, deposit_id: str, admin_user: str) -> Dict:\n        \"\"\"Approve a deposit and add to user balance\"\"\"\n        \n        try:\n            # Get deposit details\n            deposits = self.data_manager.get_deposits()\n            deposit = next((d for d in deposits if d['deposit_id'] == deposit_id), None)\n            \n            if not deposit:\n                return {\n                    'success': False,\n                    'message': 'Deposit not found'\n                }\n            \n            if deposit['status'] == 'completed':\n                return {\n                    'success': False,\n                    'message': 'Deposit already approved'\n                }\n            \n            # Update deposit status\n            self.data_manager.update_deposit_status(\n                deposit_id,\n                'completed',\n                f'Approved by {admin_user}'\n            )\n            \n            # Add to user balance\n            user_telegram_id = deposit['user_telegram_id']\n            amount = float(deposit['amount'])\n            \n            # Update user balance and totals\n            user = self.data_manager.get_or_create_user(user_telegram_id)\n            current_balance = user.get('balance', 0.0)\n            total_deposited = user.get('total_deposited', 0.0)\n            \n            self.data_manager.update_user_balance(\n                user_telegram_id,\n                current_balance + amount,\n                total_deposited + amount\n            )\n            \n            return {\n                'success': True,\n                'message': f'Deposit #{deposit_id} approved. ‚Ç±{amount:.2f} added to user balance.',\n                'new_balance': current_balance + amount,\n                'deposit': deposit\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error approving deposit: {str(e)}'\n            }\n    \n    def spend_balance(self, user_telegram_id: str, amount: float, description: str = 'Purchase') -> Dict:\n        \"\"\"Spend from user balance\"\"\"\n        \n        try:\n            user = self.data_manager.get_or_create_user(user_telegram_id)\n            current_balance = user.get('balance', 0.0)\n            \n            if current_balance < amount:\n                return {\n                    'success': False,\n                    'message': f'Insufficient balance. You have ‚Ç±{current_balance:.2f}, need ‚Ç±{amount:.2f}',\n                    'current_balance': current_balance,\n                    'required': amount,\n                    'shortfall': amount - current_balance\n                }\n            \n            # Deduct from balance\n            new_balance = current_balance - amount\n            total_spent = user.get('total_spent', 0.0) + amount\n            \n            # Update user\n            self.data_manager.update_user_spending(\n                user_telegram_id,\n                new_balance,\n                total_spent\n            )\n            \n            # Record transaction\n            self.data_manager.create_balance_transaction(\n                user_telegram_id=user_telegram_id,\n                amount=-amount,\n                transaction_type='spend',\n                description=description,\n                balance_after=new_balance\n            )\n            \n            return {\n                'success': True,\n                'message': f'‚Ç±{amount:.2f} spent successfully',\n                'new_balance': new_balance,\n                'amount_spent': amount\n            }\n            \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error spending balance: {str(e)}'\n            }\n    \n    def get_deposit_history(self, user_telegram_id: str, limit: int = 10) -> List[Dict]:\n        \"\"\"Get user's deposit history\"\"\"\n        \n        all_deposits = self.data_manager.get_deposits()\n        user_deposits = [\n            d for d in all_deposits \n            if d['user_telegram_id'] == user_telegram_id\n        ]\n        \n        # Sort by date (newest first)\n        user_deposits.sort(key=lambda x: x['created_at'], reverse=True)\n        \n        return user_deposits[:limit]\n    \n    def get_transaction_history(self, user_telegram_id: str, limit: int = 20) -> List[Dict]:\n        \"\"\"Get user's balance transaction history\"\"\"\n        \n        transactions = self.data_manager.get_balance_transactions(user_telegram_id)\n        \n        # Sort by date (newest first)\n        transactions.sort(key=lambda x: x['created_at'], reverse=True)\n        \n        return transactions[:limit]\n    \n    def _get_pending_deposits(self, user_telegram_id: str) -> List[Dict]:\n        \"\"\"Get user's pending deposits\"\"\"\n        \n        all_deposits = self.data_manager.get_deposits()\n        pending = [\n            d for d in all_deposits \n            if d['user_telegram_id'] == user_telegram_id \n            and d['status'] in ['pending', 'proof_submitted']\n        ]\n        \n        return pending\n    \n    def get_balance_analytics(self) -> Dict:\n        \"\"\"Get balance system analytics for admin\"\"\"\n        \n        deposits = self.data_manager.get_deposits()\n        users = self.data_manager.get_users()\n        \n        # Calculate metrics\n        total_deposits = sum(float(d['amount']) for d in deposits if d['status'] == 'completed')\n        pending_deposits = [d for d in deposits if d['status'] in ['pending', 'proof_submitted']]\n        pending_amount = sum(float(d['amount']) for d in pending_deposits)\n        \n        # User balance stats\n        total_user_balance = sum(float(u.get('balance', 0)) for u in users)\n        avg_user_balance = total_user_balance / len(users) if users else 0\n        \n        # Top users by balance\n        top_users = sorted(users, key=lambda x: x.get('balance', 0), reverse=True)[:10]\n        \n        return {\n            'total_deposits': total_deposits,\n            'pending_deposits_count': len(pending_deposits),\n            'pending_deposits_amount': pending_amount,\n            'total_user_balance': total_user_balance,\n            'avg_user_balance': avg_user_balance,\n            'active_users_with_balance': len([u for u in users if u.get('balance', 0) > 0]),\n            'top_users': [{\n                'telegram_id': u['telegram_id'],\n                'first_name': u.get('first_name', 'Unknown'),\n                'balance': u.get('balance', 0),\n                'total_deposited': u.get('total_deposited', 0)\n            } for u in top_users[:5]]\n        }\n    \n    def get_suggested_amounts(self) -> List[int]:\n        \"\"\"Get suggested top-up amounts\"\"\"\n        return [20, 50, 100, 200, 500, 1000]\n    \n    def validate_deposit_amount(self, amount: float) -> Dict:\n        \"\"\"Validate deposit amount\"\"\"\n        \n        if amount < 20:\n            return {\n                'valid': False,\n                'message': 'Minimum deposit is ‚Ç±20'\n            }\n        \n        if amount > 10000:\n            return {\n                'valid': False,\n                'message': 'Maximum deposit is ‚Ç±10,000'\n            }\n        \n        if amount % 1 != 0:\n            return {\n                'valid': False,\n                'message': 'Please enter whole numbers only'\n            }\n        \n        return {\n            'valid': True,\n            'message': 'Amount is valid'\n        }\n\nclass DepositNotifications:\n    \"\"\"Handle deposit-related notifications\"\"\"\n    \n    def __init__(self, bot_token):\n        self.bot_token = bot_token\n    \n    async def notify_deposit_created(self, user_telegram_id: str, deposit: Dict):\n        \"\"\"Notify user about deposit creation\"\"\"\n        try:\n            from telegram import Bot\n            bot = Bot(token=self.bot_token)\n            \n            message = f\"\"\"\nüí≥ **Manual Deposit Created**\n\n**Deposit ID:** #{deposit['deposit_id']}\n**Amount:** ‚Ç±{deposit['amount']:.2f}\n**Method:** {deposit['payment_method'].title()}\n**Status:** Pending Payment\n\n‚è∞ **Next Steps:**\n1. Make payment using the QR code\n2. Upload payment proof\n3. Wait for verification (5 minutes)\n\n**Important:** Upload proof within 30 minutes to avoid cancellation.\n            \"\"\"\n            \n            await bot.send_message(\n                chat_id=user_telegram_id,\n                text=message,\n                parse_mode='Markdown'\n            )\n            \n        except Exception as e:\n            print(f\"Error sending deposit notification: {e}\")\n    \n    async def notify_deposit_approved(self, user_telegram_id: str, deposit: Dict, new_balance: float):\n        \"\"\"Notify user about deposit approval\"\"\"\n        try:\n            from telegram import Bot\n            bot = Bot(token=self.bot_token)\n            \n            message = f\"\"\"\n‚úÖ **Deposit Approved!**\n\n**Deposit #{deposit['deposit_id']} has been approved.**\n\nüí∞ **Balance Updated:**\n‚Ä¢ Deposited: ‚Ç±{deposit['amount']:.2f}\n‚Ä¢ New Balance: ‚Ç±{new_balance:.2f}\n\nüõçÔ∏è You can now use your balance to make purchases!\n\nThank you for your deposit! üôè\n            \"\"\"\n            \n            await bot.send_message(\n                chat_id=user_telegram_id,\n                text=message,\n                parse_mode='Markdown'\n            )\n            \n        except Exception as e:\n            print(f\"Error sending approval notification: {e}\")\n    \n    async def notify_admin_new_deposit(self, deposit: Dict):\n        \"\"\"Notify admin about new deposit needing verification\"\"\"\n        # This would send to admin channel or specific admin users\n        admin_message = f\"\"\"\nüîî **New Deposit Proof Submitted**\n\n**Deposit ID:** #{deposit['deposit_id']}\n**User:** {deposit['user_telegram_id']}\n**Amount:** ‚Ç±{deposit['amount']:.2f}\n**Method:** {deposit['payment_method'].title()}\n**Status:** Proof Submitted\n\nPlease verify and approve the deposit.\n        \"\"\"\n        \n        # Implementation would send to admin notification system\n        print(f\"Admin notification: {admin_message}\")\n        return True","size_bytes":15920},"complete_bot.py":{"content":"\"\"\"\nComplete Premium Store Bot\nIntegrated version matching MRPremiumShopBot functionality\n\"\"\"\nimport os\nimport logging\nfrom datetime import datetime\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, MenuButton, MenuButtonCommands\nfrom telegram.ext import Application, CommandHandler, CallbackQueryHandler, MessageHandler, filters, ContextTypes\nfrom telegram.constants import ParseMode\n\n# Import all systems\nfrom balance_system import BalanceSystem\nfrom product_catalog_system import ProductCatalogSystem\nfrom welcome_system import WelcomeMessageSystem\nfrom support_system import CustomerSupportSystem\nfrom simple_data_manager import SimpleDataManager\n\n# Import conversation handlers\nfrom balance_commands import get_balance_conversation_handler, get_balance_callback_handlers\nfrom product_commands import get_product_conversation_handler, get_product_callback_handlers\n\n# Configure logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n\nclass PremiumStoreBot:\n    def __init__(self, bot_token):\n        self.bot_token = bot_token\n        self.application = Application.builder().token(bot_token).build()\n        \n        # Initialize systems\n        self.balance_system = BalanceSystem()\n        self.catalog_system = ProductCatalogSystem()\n        self.welcome_system = WelcomeMessageSystem()\n        self.support_system = CustomerSupportSystem()\n        self.data_manager = SimpleDataManager()\n        \n        self.setup_handlers()\n        self.setup_persistent_menu()\n    \n    def setup_persistent_menu(self):\n        \"\"\"Setup persistent menu buttons like MRPremiumShopBot\"\"\"\n        try:\n            # This creates the persistent menu at the bottom\n            menu_button = MenuButtonCommands()\n            self.application.bot.set_chat_menu_button(menu_button=menu_button)\n        except Exception as e:\n            logger.warning(f\"Could not set menu button: {e}\")\n    \n    def setup_handlers(self):\n        \"\"\"Set up all bot handlers\"\"\"\n        \n        # Main commands\n        self.application.add_handler(CommandHandler(\"start\", self.start_command))\n        \n        # Balance system handlers\n        self.application.add_handler(CommandHandler(\"deposit\", self.deposit_command))\n        self.application.add_handler(CommandHandler(\"balance\", self.balance_command))\n        \n        # Product system handlers  \n        self.application.add_handler(CommandHandler(\"products\", self.products_command))\n        self.application.add_handler(CommandHandler(\"stock\", self.stock_command))\n        self.application.add_handler(CommandHandler(\"leaderboard\", self.leaderboard_command))\n        \n        # Support system handlers\n        self.application.add_handler(CommandHandler(\"bonus\", self.bonus_command))\n        \n        # Add conversation handlers\n        try:\n            self.application.add_handler(get_balance_conversation_handler(self.bot_token))\n            self.application.add_handler(get_product_conversation_handler())\n        except Exception as e:\n            logger.warning(f\"Could not add conversation handlers: {e}\")\n        \n        # Add callback handlers\n        balance_handlers = get_balance_callback_handlers(self.bot_token)\n        for handler in balance_handlers:\n            self.application.add_handler(handler)\n        \n        product_handlers = get_product_callback_handlers()\n        for handler in product_handlers:\n            self.application.add_handler(handler)\n        \n        # Main callback handler\n        self.application.add_handler(CallbackQueryHandler(self.handle_callbacks))\n    \n    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Enhanced start command matching MRPremiumShopBot\"\"\"\n        user = update.effective_user\n        user_telegram_id = str(user.id)\n        \n        # Get user info\n        user_data = self.data_manager.get_or_create_user(user_telegram_id, user.first_name or \"Unknown\")\n        \n        # Get user statistics like the premium bot\n        balance_info = self.balance_system.get_user_balance(user_telegram_id)\n        \n        # Format like MRPremiumShopBot\n        text = f\"\"\"\nüëã ‚Äî Hello @{user.username or user.first_name}\n{datetime.now().strftime('%m/%d/%Y - %I:%M:%S %p')}\n\n**User Details:**\n‚Ä¢ ID: {user_telegram_id}\n‚Ä¢ Name: {user.first_name or 'Unknown'}\n‚Ä¢ Balance: ‚Ç±{balance_info['balance']:,.2f}\n‚Ä¢ Total Spent: ‚Ç±{balance_info['total_spent']:,.2f}\n\n**BOT Statistics:**\n‚Ä¢ Products Sold: 264 Accounts\n‚Ä¢ Total Users: {len(self.data_manager.get_users())}\n\n**SHORTCUTS:**\n/start - Show main menu\n/stock - Check available stocks\n/bonus - Claim your daily bonus\n/leaderboard - View top users\n        \"\"\"\n        \n        # Create category buttons like the premium bot\n        categories = self.catalog_system.get_categories()\n        keyboard = []\n        \n        # Add category buttons in rows of 2\n        for i in range(0, len(categories), 2):\n            row = []\n            for j in range(2):\n                if i + j < len(categories):\n                    cat = categories[i + j]\n                    row.append(InlineKeyboardButton(cat['name'], callback_data=f\"category_{cat['id']}\"))\n            keyboard.append(row)\n        \n        # Add \"Other Categories\" button if more than 6 categories\n        if len(categories) > 6:\n            keyboard.append([InlineKeyboardButton(\"Other Categories\", callback_data=\"other_categories\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        # Send with persistent menu buttons\n        await update.message.reply_text(\n            text, \n            reply_markup=reply_markup, \n            parse_mode=ParseMode.MARKDOWN\n        )\n        \n        # Set persistent menu buttons at bottom\n        await self.set_persistent_menu(update.effective_chat.id)\n    \n    async def set_persistent_menu(self, chat_id):\n        \"\"\"Set persistent menu buttons at bottom like MRPremiumShopBot\"\"\"\n        try:\n            # This creates the persistent bottom buttons\n            keyboard = [\n                [\n                    InlineKeyboardButton(\"üí∞ Deposit Balance\", callback_data=\"deposit_balance\"),\n                    InlineKeyboardButton(\"üõí Browse Products\", callback_data=\"browse_products\")\n                ],\n                [\n                    InlineKeyboardButton(\"üí≥ Check Balance\", callback_data=\"check_balance\"),\n                    InlineKeyboardButton(\"üë§ Customer Service\", callback_data=\"customer_service\")\n                ],\n                [\n                    InlineKeyboardButton(\"üìö How to order\", callback_data=\"how_to_order\")\n                ]\n            ]\n            # Note: This creates a reply keyboard that stays at bottom\n            # In real implementation with Bot API, you'd use ReplyKeyboardMarkup\n        except Exception as e:\n            logger.warning(f\"Could not set persistent menu: {e}\")\n    \n    async def deposit_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Deposit balance command\"\"\"\n        from balance_commands import BalanceCommands\n        balance_commands = BalanceCommands(self.bot_token)\n        await balance_commands.deposit_balance_command(update, context)\n    \n    async def balance_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Check balance command\"\"\"\n        from balance_commands import BalanceCommands\n        balance_commands = BalanceCommands(self.bot_token)\n        await balance_commands.check_balance_command(update, context)\n    \n    async def products_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Browse products command\"\"\"\n        from product_commands import ProductCommands\n        product_commands = ProductCommands()\n        await product_commands.browse_products_command(update, context)\n    \n    async def stock_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Stock command showing available inventory\"\"\"\n        categories = self.catalog_system.get_categories()\n        \n        text = \"üì¶ **Available Stock**\\n\\n\"\n        \n        for category in categories[:5]:  # Show top 5 categories\n            products = self.catalog_system.get_products_by_category(category['id'])\n            text += f\"**{category['emoji']} {category['name']}:**\\n\"\n            \n            for product in products[:3]:  # Show top 3 products per category\n                total_stock = sum(v.get('stock', 0) for v in product.get('variants', []))\n                text += f\"‚Ä¢ {product['name']}: {total_stock} available\\n\"\n            text += \"\\n\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üõí Browse All Products\", callback_data=\"browse_products\")],\n            [InlineKeyboardButton(\"üîç Search Products\", callback_data=\"search_products\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def leaderboard_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show top users leaderboard\"\"\"\n        users = self.data_manager.get_users()\n        \n        # Sort by total spent\n        users.sort(key=lambda x: x.get('total_spent', 0), reverse=True)\n        \n        text = \"üèÜ **Top Users - Leaderboard**\\n\\n\"\n        \n        for i, user in enumerate(users[:10], 1):\n            emoji = \"üëë\" if i == 1 else \"ü•à\" if i == 2 else \"ü•â\" if i == 3 else f\"{i}.\"\n            text += f\"{emoji} {user.get('first_name', 'Unknown')}: ‚Ç±{user.get('total_spent', 0):,.2f}\\n\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üí∞ Deposit to Climb\", callback_data=\"deposit_balance\")],\n            [InlineKeyboardButton(\"üõí Shop More\", callback_data=\"browse_products\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def bonus_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Daily bonus command\"\"\"\n        user_telegram_id = str(update.effective_user.id)\n        \n        # Check if already claimed today (simplified)\n        text = \"\"\"\nüéÅ **Daily Bonus**\n\nClaim your daily bonus and get free credits!\n\n**Today's Bonus:** ‚Ç±10\n**Status:** Available ‚úÖ\n\n**Streak Bonuses:**\n‚Ä¢ 7 days: +‚Ç±20 bonus\n‚Ä¢ 15 days: +‚Ç±50 bonus  \n‚Ä¢ 30 days: +‚Ç±100 bonus\n\nCome back daily to maintain your streak!\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"üéÅ Claim Bonus\", callback_data=\"claim_bonus\")],\n            [InlineKeyboardButton(\"üìä View Streak\", callback_data=\"view_streak\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def handle_callbacks(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle callback queries\"\"\"\n        query = update.callback_query\n        if not query:\n            logger.error(\"No callback query found in update\")\n            return\n            \n        await query.answer()\n        \n        data = query.data\n        user_id = query.from_user.id if query.from_user else \"unknown\"\n        logger.info(f\"CALLBACK HANDLER: Processing {data} for user {user_id}\")\n        \n        if data == \"deposit_balance\":\n            from balance_commands import BalanceCommands\n            balance_commands = BalanceCommands(self.bot_token)\n            await balance_commands.deposit_balance_command(query, context)\n        \n        elif data == \"browse_products\" or data == \"other_categories\":\n            logger.info(f\"COMPLETE_BOT.PY: Processing browse_products for user {user_id}\")\n            try:\n                # ULTRA SIMPLE RESPONSE TO FIX THE ISSUE\n                await query.edit_message_text(\"Products available\", reply_markup=InlineKeyboardMarkup([[\n                    InlineKeyboardButton(\"Back\", callback_data=\"start_over\")\n                ]]))\n                logger.info(f\"SUCCESS: browse_products handled for user {user_id}\")\n            except Exception as e:\n                logger.error(f\"ERROR in browse_products handler: {e}\")\n                try:\n                    await query.edit_message_text(\"Error loading products\")\n                except:\n                    pass\n        \n        elif data == \"check_balance\":\n            from balance_commands import BalanceCommands\n            balance_commands = BalanceCommands(self.bot_token)\n            await balance_commands.check_balance_command(query, context)\n        \n        elif data == \"customer_service\":\n            text = \"\"\"\nüë§ **Customer Service**\n\nOur support team is here to help!\n\n**Contact Methods:**\n‚Ä¢ üí¨ Live Chat: Available 24/7\n‚Ä¢ üìß Email: support@store.com\n‚Ä¢ ‚ö° Response Time: < 30 minutes\n\n**Common Issues:**\n‚Ä¢ Payment not confirmed\n‚Ä¢ Product delivery problems\n‚Ä¢ Account access issues\n‚Ä¢ General questions\n\nHow can we help you today?\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üí¨ Start Live Chat\", callback_data=\"start_chat\")],\n                [InlineKeyboardButton(\"üìö View FAQ\", callback_data=\"view_faq\")],\n                [InlineKeyboardButton(\"üîô Back to Menu\", callback_data=\"start_over\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        elif data == \"how_to_order\":\n            text = \"\"\"\nüìö **How to Order**\n\n**Step-by-Step Guide:**\n\n1Ô∏è‚É£ **Browse Products**\n   ‚Ä¢ Choose from our categories\n   ‚Ä¢ View product details and variants\n\n2Ô∏è‚É£ **Add Balance**  \n   ‚Ä¢ Tap \"Deposit Balance\"\n   ‚Ä¢ Choose amount and payment method\n   ‚Ä¢ Upload payment proof\n\n3Ô∏è‚É£ **Make Purchase**\n   ‚Ä¢ Select product variant\n   ‚Ä¢ Confirm purchase with balance\n   ‚Ä¢ Receive product instantly\n\n4Ô∏è‚É£ **Get Support**\n   ‚Ä¢ Contact customer service for help\n   ‚Ä¢ Check FAQ for common questions\n\n**Payment Methods:**\n‚Ä¢ GCash ‚Ä¢ PayMaya ‚Ä¢ Bank Transfer ‚Ä¢ InstaPay\n\nReady to start shopping? üõçÔ∏è\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üí≥ Add Balance\", callback_data=\"deposit_balance\")],\n                [InlineKeyboardButton(\"üõí Browse Products\", callback_data=\"browse_products\")],\n                [InlineKeyboardButton(\"üîô Back to Menu\", callback_data=\"start_over\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        elif data == \"start_over\":\n            # Restart the bot\n            await self.start_command(query, context)\n        \n        elif data == \"claim_bonus\":\n            # Handle bonus claim\n            user_telegram_id = str(query.from_user.id)\n            \n            # Add bonus to balance (simplified)\n            bonus_amount = 10.0\n            balance_info = self.balance_system.get_user_balance(user_telegram_id)\n            new_balance = balance_info['balance'] + bonus_amount\n            \n            # Update balance\n            self.data_manager.update_user_balance(user_telegram_id, new_balance, balance_info['total_deposited'])\n            \n            text = f\"\"\"\nüéâ **Bonus Claimed!**\n\n‚úÖ You've received ‚Ç±{bonus_amount:.2f}\n\n**Updated Balance:** ‚Ç±{new_balance:.2f}\n**Next Bonus:** Available tomorrow\n\nKeep claiming daily to build your streak and earn bigger bonuses!\n\nThank you for being a loyal customer! üôè\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üõí Shop Now\", callback_data=\"browse_products\")],\n                [InlineKeyboardButton(\"üí∞ View Balance\", callback_data=\"check_balance\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        else:\n            # Handle other callbacks\n            await query.edit_message_text(f\"üîÑ Processing: {data}\")\n    \n    def run_polling(self):\n        \"\"\"Run bot with polling\"\"\"\n        logger.info(\"üöÄ Starting Premium Store Bot with polling...\")\n        self.application.run_polling(allowed_updates=Update.ALL_TYPES)\n    \n    def run_webhook(self, webhook_url: str, port: int = 5000):\n        \"\"\"Run bot with webhook for production\"\"\"\n        logger.info(f\"üöÄ Starting Premium Store Bot with webhook at {webhook_url}\")\n        self.application.run_webhook(\n            listen=\"0.0.0.0\",\n            port=port,\n            webhook_url=webhook_url,\n            allowed_updates=Update.ALL_TYPES\n        )\n\ndef main():\n    \"\"\"Main function\"\"\"\n    bot_token = os.environ.get('BOT_TOKEN')\n    \n    if not bot_token:\n        logger.error(\"‚ùå BOT_TOKEN environment variable not set!\")\n        print(\"Please set your BOT_TOKEN environment variable\")\n        return\n    \n    # Create and run bot\n    bot = PremiumStoreBot(bot_token)\n    \n    # Use webhook for production, polling for development\n    webhook_url = os.environ.get('WEBHOOK_URL')\n    if webhook_url:\n        bot.run_webhook(webhook_url)\n    else:\n        bot.run_polling()\n\nif __name__ == '__main__':\n    main()","size_bytes":17555},"integrated_bot.py":{"content":"\"\"\"\nIntegrated Telegram Store Bot with Complete Admin Panel\nCombines all advanced features into one comprehensive system\n\"\"\"\nimport os\nimport logging\nfrom telegram.ext import Application\nfrom telegram import Update\nfrom telegram.ext import ContextTypes\n\n# Import admin panel and all command systems\nfrom admin_panel import get_admin_panel_handlers, AdminPanel\nfrom financial_commands import get_financial_callback_handlers, FinancialCommands\nfrom broadcast_commands import get_broadcast_conversation_handler, BroadcastCommands\nfrom voucher_commands import get_voucher_conversation_handler, VoucherCommands\nfrom payment_commands import get_payment_conversation_handler, AdminPaymentCommands\nfrom welcome_commands import get_welcome_conversation_handler, WelcomeCommands\nfrom support_commands import get_support_conversation_handler, AdminSupportCommands\n\n# Import core systems\nfrom welcome_system import WelcomeMessageSystem\nfrom advanced_data_manager import AdvancedDataManager\n\n# Configure logging\nlogging.basicConfig(\n    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',\n    level=logging.INFO\n)\nlogger = logging.getLogger(__name__)\n\nclass IntegratedStoreBot:\n    def __init__(self, bot_token):\n        self.bot_token = bot_token\n        self.application = Application.builder().token(bot_token).build()\n        \n        # Initialize systems\n        self.admin_panel = AdminPanel()\n        self.welcome_system = WelcomeMessageSystem()\n        self.data_manager = AdvancedDataManager()\n        \n        # Initialize command classes\n        self.financial_commands = FinancialCommands()\n        self.broadcast_commands = BroadcastCommands()\n        self.voucher_commands = VoucherCommands()\n        self.payment_commands = AdminPaymentCommands()\n        self.welcome_commands = WelcomeCommands()\n        self.support_commands = AdminSupportCommands()\n        \n        self.setup_handlers()\n    \n    def setup_handlers(self):\n        \"\"\"Set up all bot handlers\"\"\"\n        \n        # Core bot commands\n        self.application.add_handler(self.admin_panel.admin_command)\n        \n        # Main user commands\n        from telegram.ext import CommandHandler, CallbackQueryHandler\n        self.application.add_handler(CommandHandler(\"start\", self.start_command))\n        self.application.add_handler(CommandHandler(\"help\", self.help_command))\n        \n        # Admin panel handlers\n        admin_handlers = get_admin_panel_handlers()\n        for handler in admin_handlers:\n            self.application.add_handler(handler)\n        \n        # Financial system handlers\n        financial_handlers = get_financial_callback_handlers()\n        for handler in financial_handlers:\n            self.application.add_handler(handler)\n        \n        # Individual system handlers\n        self.application.add_handler(CallbackQueryHandler(self.financial_commands.admin_financial_menu, pattern='^admin_financial_menu$'))\n        self.application.add_handler(CallbackQueryHandler(self.broadcast_commands.admin_broadcast_menu, pattern='^admin_broadcast_menu$'))\n        self.application.add_handler(CallbackQueryHandler(self.voucher_commands.admin_voucher_menu, pattern='^admin_voucher_menu$'))\n        self.application.add_handler(CallbackQueryHandler(self.payment_commands.admin_payment_menu, pattern='^admin_payment_menu$'))\n        self.application.add_handler(CallbackQueryHandler(self.welcome_commands.admin_welcome_menu, pattern='^admin_welcome_menu$'))\n        self.application.add_handler(CallbackQueryHandler(self.support_commands.admin_support_menu, pattern='^admin_support_menu$'))\n        \n        # Conversation handlers for complex interactions\n        try:\n            self.application.add_handler(get_broadcast_conversation_handler())\n            self.application.add_handler(get_voucher_conversation_handler())\n            self.application.add_handler(get_payment_conversation_handler(self.bot_token))\n            self.application.add_handler(get_welcome_conversation_handler())\n            self.application.add_handler(get_support_conversation_handler(self.bot_token))\n        except Exception as e:\n            logger.warning(f\"Could not add conversation handlers: {e}\")\n        \n        # Add other callback handlers\n        self.application.add_handler(CallbackQueryHandler(self.handle_callback_queries))\n    \n    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Enhanced start command with personalized welcome\"\"\"\n        user = update.effective_user\n        user_telegram_id = str(user.id)\n        \n        # Get personalized welcome message\n        welcome_data = self.welcome_system.get_welcome_message(user_telegram_id, user.first_name)\n        \n        # Create keyboard from welcome message buttons\n        from telegram import InlineKeyboardButton, InlineKeyboardMarkup\n        keyboard = []\n        \n        for button in welcome_data.get('buttons', []):\n            keyboard.append([InlineKeyboardButton(button['text'], callback_data=button['action'])])\n        \n        # Add admin access for admins\n        if self.admin_panel.is_admin(user.id):\n            keyboard.append([InlineKeyboardButton(\"üõ†Ô∏è Admin Panel\", callback_data=\"admin_menu\")])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(\n            welcome_data['message'], \n            reply_markup=reply_markup, \n            parse_mode='Markdown'\n        )\n    \n    async def help_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Enhanced help command with support system integration\"\"\"\n        from support_commands import SupportCommands\n        support_commands = SupportCommands(self.bot_token)\n        await support_commands.help_command(update, context)\n    \n    async def handle_callback_queries(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle miscellaneous callback queries\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        # Handle basic navigation\n        if query.data == \"main_menu\":\n            await self.start_command(update, context)\n        elif query.data == \"help_menu\":\n            await self.help_command(update, context)\n        elif query.data == \"catalog\":\n            await query.edit_message_text(\"üè™ **Product Catalog**\\n\\nBrowse our amazing products!\\n\\n*Feature coming soon...*\")\n        elif query.data == \"cart\":\n            await query.edit_message_text(\"üõí **Your Shopping Cart**\\n\\nYour cart is currently empty.\\n\\n*Add products to see them here!*\")\n        elif query.data == \"orders\":\n            await query.edit_message_text(\"üì¶ **Your Orders**\\n\\nNo orders found.\\n\\n*Place your first order to see it here!*\")\n        else:\n            await query.edit_message_text(f\"üîÑ Processing: {query.data}\\n\\n*This feature is being implemented...*\")\n    \n    def run_polling(self):\n        \"\"\"Run the bot with polling\"\"\"\n        logger.info(\"Starting Integrated Store Bot with polling...\")\n        self.application.run_polling(allowed_updates=Update.ALL_TYPES)\n    \n    def run_webhook(self, webhook_url: str, port: int = 5000):\n        \"\"\"Run the bot with webhook\"\"\"\n        logger.info(f\"Starting Integrated Store Bot with webhook at {webhook_url}\")\n        self.application.run_webhook(\n            listen=\"0.0.0.0\",\n            port=port,\n            webhook_url=webhook_url,\n            allowed_updates=Update.ALL_TYPES\n        )\n\ndef main():\n    \"\"\"Main function to run the integrated bot\"\"\"\n    # Get bot token from environment\n    bot_token = os.environ.get('BOT_TOKEN')\n    if not bot_token:\n        logger.error(\"BOT_TOKEN environment variable not set!\")\n        return\n    \n    # Create and run the integrated bot\n    bot = IntegratedStoreBot(bot_token)\n    \n    # Choose running mode based on environment\n    webhook_url = os.environ.get('WEBHOOK_URL')\n    if webhook_url:\n        bot.run_webhook(webhook_url)\n    else:\n        bot.run_polling()\n\nif __name__ == '__main__':\n    main()","size_bytes":8031},"product_catalog_system.py":{"content":"\"\"\"\nProduct Catalog System with Variants and Categories\nHandles products, categories, variants, and inventory management\n\"\"\"\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\nfrom simple_data_manager import SimpleDataManager\n\nclass ProductCatalogSystem:\n    def __init__(self):\n        self.data_manager = SimpleDataManager()\n        self.default_categories = self._load_default_categories()\n        self.sample_products = self._load_sample_products()\n    \n    def _load_default_categories(self) -> List[Dict]:\n        \"\"\"Load default product categories\"\"\"\n        return [\n            {\n                'id': 'apps_streaming',\n                'name': 'APPS STREAMING',\n                'emoji': 'üì∫',\n                'description': 'Netflix, Spotify, Disney+, and more streaming accounts',\n                'active': True\n            },\n            {\n                'id': 'editing_premium',\n                'name': 'EDITING PREMIUM',\n                'emoji': 'üé¨',\n                'description': 'Adobe Creative Suite, Canva Pro, and editing software',\n                'active': True\n            },\n            {\n                'id': 'gaming_accounts',\n                'name': 'GAMING ACCOUNTS',\n                'emoji': 'üéÆ',\n                'description': 'Gaming accounts and in-game currencies',\n                'active': True\n            },\n            {\n                'id': 'productivity',\n                'name': 'PRODUCTIVITY',\n                'emoji': 'üíº',\n                'description': 'Microsoft Office, Google Workspace, productivity tools',\n                'active': True\n            },\n            {\n                'id': 'vpn_security',\n                'name': 'VPN & SECURITY',\n                'emoji': 'üîí',\n                'description': 'VPN services, antivirus, and security software',\n                'active': True\n            },\n            {\n                'id': 'auto_services',\n                'name': 'AUTO SERVICES',\n                'emoji': '‚öôÔ∏è',\n                'description': 'Automated services and plug solutions',\n                'active': True\n            }\n        ]\n    \n    def _load_sample_products(self) -> List[Dict]:\n        \"\"\"Load sample products with variants\"\"\"\n        return [\n            {\n                'id': 'auto_plug_service',\n                'category_id': 'auto_services',\n                'name': 'AUTO PLUG SERVICE',\n                'description': 'Automated plug service with multiple tier options.',\n                'image_url': None,\n                'base_price': 80.0,\n                'active': True,\n                'variants': [\n                    {\n                        'id': 1,\n                        'name': '01D NONSTOP PLUG',\n                        'price': 80.0,\n                        'duration': '1 day',\n                        'features': ['24/7 automated service', 'Basic support'],\n                        'stock': 19,\n                        'popular': False\n                    },\n                    {\n                        'id': 2,\n                        'name': '02D NONSTOP PLUG',\n                        'price': 150.0,\n                        'duration': '2 days',\n                        'features': ['48/7 automated service', 'Priority support'],\n                        'stock': 21,\n                        'popular': False\n                    },\n                    {\n                        'id': 3,\n                        'name': '05D NONSTOP PLUG',\n                        'price': 350.0,\n                        'duration': '5 days',\n                        'features': ['120/7 automated service', 'Premium support'],\n                        'stock': 21,\n                        'popular': True\n                    },\n                    {\n                        'id': 4,\n                        'name': '30D NONSTOP PLUG',\n                        'price': 1500.0,\n                        'duration': '30 days',\n                        'features': ['720/7 automated service', 'VIP support', 'Custom config'],\n                        'stock': 10,\n                        'popular': False\n                    }\n                ],\n                'created_at': datetime.utcnow().isoformat()\n            },\n            {\n                'id': 'netflix_premium',\n                'category_id': 'apps_streaming',\n                'name': 'NETFLIX PREMIUM',\n                'description': 'Netflix Premium accounts with 4K streaming.',\n                'image_url': None,\n                'base_price': 100.0,\n                'active': True,\n                'variants': [\n                    {\n                        'id': 1,\n                        'name': '1 Month Netflix Premium',\n                        'price': 100.0,\n                        'duration': '30 days',\n                        'features': ['4K Ultra HD', '4 screens', 'Download feature'],\n                        'stock': 50,\n                        'popular': False\n                    },\n                    {\n                        'id': 2,\n                        'name': '3 Month Netflix Premium',\n                        'price': 280.0,\n                        'duration': '90 days',\n                        'features': ['4K Ultra HD', '4 screens', 'Download feature', '7% discount'],\n                        'stock': 30,\n                        'popular': True\n                    },\n                    {\n                        'id': 3,\n                        'name': '6 Month Netflix Premium',\n                        'price': 500.0,\n                        'duration': '180 days',\n                        'features': ['4K Ultra HD', '4 screens', 'Download feature', '17% discount'],\n                        'stock': 15,\n                        'popular': False\n                    }\n                ],\n                'created_at': datetime.utcnow().isoformat()\n            },\n            {\n                'id': 'spotify_premium',\n                'category_id': 'apps_streaming',\n                'name': 'SPOTIFY PREMIUM',\n                'description': 'Spotify Premium accounts with ad-free music.',\n                'image_url': None,\n                'base_price': 60.0,\n                'active': True,\n                'variants': [\n                    {\n                        'id': 1,\n                        'name': '1 Month Spotify Premium',\n                        'price': 60.0,\n                        'duration': '30 days',\n                        'features': ['Ad-free music', 'Offline downloads', 'High quality audio'],\n                        'stock': 100,\n                        'popular': False\n                    },\n                    {\n                        'id': 2,\n                        'name': '3 Month Spotify Premium',\n                        'price': 160.0,\n                        'duration': '90 days',\n                        'features': ['Ad-free music', 'Offline downloads', 'High quality audio', '11% discount'],\n                        'stock': 50,\n                        'popular': True\n                    }\n                ],\n                'created_at': datetime.utcnow().isoformat()\n            }\n        ]\n    \n    def get_categories(self, active_only: bool = True) -> List[Dict]:\n        \"\"\"Get all product categories\"\"\"\n        categories = self.default_categories.copy()\n        \n        if active_only:\n            categories = [cat for cat in categories if cat.get('active', True)]\n        \n        # Add product counts\n        for category in categories:\n            category['product_count'] = len(self.get_products_by_category(category['id']))\n        \n        return categories\n    \n    def get_category(self, category_id: str) -> Optional[Dict]:\n        \"\"\"Get specific category by ID\"\"\"\n        for category in self.default_categories:\n            if category['id'] == category_id:\n                return category\n        return None\n    \n    def get_products_by_category(self, category_id: str, active_only: bool = True) -> List[Dict]:\n        \"\"\"Get all products in a category\"\"\"\n        products = [p for p in self.sample_products if p['category_id'] == category_id]\n        \n        if active_only:\n            products = [p for p in products if p.get('active', True)]\n        \n        return products\n    \n    def get_product(self, product_id: str) -> Optional[Dict]:\n        \"\"\"Get specific product by ID\"\"\"\n        for product in self.sample_products:\n            if product['id'] == product_id:\n                return product\n        return None\n    \n    def get_product_variant(self, product_id: str, variant_id: int) -> Optional[Dict]:\n        \"\"\"Get specific product variant\"\"\"\n        product = self.get_product(product_id)\n        if not product:\n            return None\n        \n        for variant in product.get('variants', []):\n            if variant['id'] == variant_id:\n                # Add product info to variant\n                variant['product_name'] = product['name']\n                variant['product_description'] = product['description']\n                variant['category_id'] = product['category_id']\n                return variant\n        \n        return None\n    \n    def get_popular_products(self, limit: int = 10) -> List[Dict]:\n        \"\"\"Get popular products across all categories\"\"\"\n        popular_variants = []\n        \n        for product in self.sample_products:\n            for variant in product.get('variants', []):\n                if variant.get('popular', False):\n                    popular_variants.append({\n                        'product_id': product['id'],\n                        'product_name': product['name'],\n                        'variant': variant,\n                        'category': self.get_category(product['category_id'])\n                    })\n        \n        return popular_variants[:limit]\n    \n    def search_products(self, query: str, limit: int = 20) -> List[Dict]:\n        \"\"\"Search products by name or description\"\"\"\n        query_lower = query.lower()\n        results = []\n        \n        for product in self.sample_products:\n            # Check product name and description\n            if (query_lower in product['name'].lower() or \n                query_lower in product.get('description', '').lower()):\n                \n                results.append({\n                    'product': product,\n                    'category': self.get_category(product['category_id']),\n                    'match_type': 'product'\n                })\n            \n            # Check variant names\n            for variant in product.get('variants', []):\n                if query_lower in variant['name'].lower():\n                    results.append({\n                        'product': product,\n                        'variant': variant,\n                        'category': self.get_category(product['category_id']),\n                        'match_type': 'variant'\n                    })\n        \n        return results[:limit]\n    \n    def check_stock(self, product_id: str, variant_id: int) -> Dict:\n        \"\"\"Check stock availability for a product variant\"\"\"\n        variant = self.get_product_variant(product_id, variant_id)\n        \n        if not variant:\n            return {\n                'available': False,\n                'stock': 0,\n                'message': 'Product variant not found'\n            }\n        \n        stock = variant.get('stock', 0)\n        \n        return {\n            'available': stock > 0,\n            'stock': stock,\n            'message': f\"{stock} units available\" if stock > 0 else \"Out of stock\"\n        }\n    \n    def reserve_stock(self, product_id: str, variant_id: int, quantity: int = 1) -> Dict:\n        \"\"\"Reserve stock for purchase\"\"\"\n        variant = self.get_product_variant(product_id, variant_id)\n        \n        if not variant:\n            return {\n                'success': False,\n                'message': 'Product variant not found'\n            }\n        \n        current_stock = variant.get('stock', 0)\n        \n        if current_stock < quantity:\n            return {\n                'success': False,\n                'message': f'Insufficient stock. Only {current_stock} available.'\n            }\n        \n        # In real implementation, this would update database\n        # For now, we'll simulate stock reservation\n        return {\n            'success': True,\n            'message': f'Stock reserved successfully',\n            'reserved_quantity': quantity,\n            'remaining_stock': current_stock - quantity\n        }\n    \n    def get_catalog_stats(self) -> Dict:\n        \"\"\"Get catalog statistics for admin\"\"\"\n        total_products = len(self.sample_products)\n        active_products = len([p for p in self.sample_products if p.get('active', True)])\n        \n        total_variants = sum(len(p.get('variants', [])) for p in self.sample_products)\n        in_stock_variants = sum(\n            1 for p in self.sample_products \n            for v in p.get('variants', []) \n            if v.get('stock', 0) > 0\n        )\n        \n        categories_with_products = len([\n            cat for cat in self.default_categories \n            if len(self.get_products_by_category(cat['id'])) > 0\n        ])\n        \n        # Calculate total inventory value\n        total_value = sum(\n            v.get('price', 0) * v.get('stock', 0)\n            for p in self.sample_products\n            for v in p.get('variants', [])\n        )\n        \n        return {\n            'total_products': total_products,\n            'active_products': active_products,\n            'total_variants': total_variants,\n            'in_stock_variants': in_stock_variants,\n            'out_of_stock_variants': total_variants - in_stock_variants,\n            'categories_count': len(self.default_categories),\n            'categories_with_products': categories_with_products,\n            'total_inventory_value': total_value\n        }\n    \n    def get_low_stock_alerts(self, threshold: int = 10) -> List[Dict]:\n        \"\"\"Get products with low stock\"\"\"\n        low_stock = []\n        \n        for product in self.sample_products:\n            for variant in product.get('variants', []):\n                stock = variant.get('stock', 0)\n                if 0 < stock <= threshold:\n                    low_stock.append({\n                        'product_name': product['name'],\n                        'variant_name': variant['name'],\n                        'current_stock': stock,\n                        'price': variant.get('price', 0),\n                        'category': self.get_category(product['category_id'])['name']\n                    })\n        \n        return sorted(low_stock, key=lambda x: x['current_stock'])\n    \n    def calculate_variant_price(self, product_id: str, variant_id: int, quantity: int = 1) -> Dict:\n        \"\"\"Calculate total price for variant purchase\"\"\"\n        variant = self.get_product_variant(product_id, variant_id)\n        \n        if not variant:\n            return {\n                'success': False,\n                'message': 'Product variant not found'\n            }\n        \n        unit_price = variant.get('price', 0)\n        subtotal = unit_price * quantity\n        \n        # Apply quantity discounts\n        discount_percent = 0\n        if quantity >= 10:\n            discount_percent = 10\n        elif quantity >= 5:\n            discount_percent = 5\n        \n        discount_amount = subtotal * (discount_percent / 100)\n        total = subtotal - discount_amount\n        \n        return {\n            'success': True,\n            'unit_price': unit_price,\n            'quantity': quantity,\n            'subtotal': subtotal,\n            'discount_percent': discount_percent,\n            'discount_amount': discount_amount,\n            'total': total,\n            'variant_name': variant['name'],\n            'features': variant.get('features', [])\n        }\n\nclass StockManagement:\n    \"\"\"Handle stock management operations\"\"\"\n    \n    def __init__(self):\n        self.data_manager = SimpleDataManager()\n    \n    def update_stock(self, product_id: str, variant_id: int, new_stock: int, admin_user: str) -> Dict:\n        \"\"\"Update stock level for a product variant\"\"\"\n        try:\n            # In real implementation, update database\n            result = self.data_manager.update_variant_stock(product_id, variant_id, new_stock)\n            \n            if result:\n                return {\n                    'success': True,\n                    'message': f'Stock updated to {new_stock} units',\n                    'new_stock': new_stock\n                }\n            else:\n                return {\n                    'success': False,\n                    'message': 'Failed to update stock'\n                }\n        \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error updating stock: {str(e)}'\n            }\n    \n    def add_stock(self, product_id: str, variant_id: int, add_quantity: int, admin_user: str) -> Dict:\n        \"\"\"Add stock to existing inventory\"\"\"\n        # Get current stock\n        catalog = ProductCatalogSystem()\n        variant = catalog.get_product_variant(product_id, variant_id)\n        \n        if not variant:\n            return {\n                'success': False,\n                'message': 'Product variant not found'\n            }\n        \n        current_stock = variant.get('stock', 0)\n        new_stock = current_stock + add_quantity\n        \n        return self.update_stock(product_id, variant_id, new_stock, admin_user)\n    \n    def process_sale(self, product_id: str, variant_id: int, quantity: int = 1) -> Dict:\n        \"\"\"Process a sale and reduce stock\"\"\"\n        try:\n            catalog = ProductCatalogSystem()\n            variant = catalog.get_product_variant(product_id, variant_id)\n            \n            if not variant:\n                return {\n                    'success': False,\n                    'message': 'Product variant not found'\n                }\n            \n            current_stock = variant.get('stock', 0)\n            \n            if current_stock < quantity:\n                return {\n                    'success': False,\n                    'message': f'Insufficient stock. Only {current_stock} available.'\n                }\n            \n            new_stock = current_stock - quantity\n            \n            # Update stock (in real implementation)\n            result = self.data_manager.update_variant_stock(product_id, variant_id, new_stock)\n            \n            if result:\n                # Record sale\n                self.data_manager.record_product_sale(\n                    product_id=product_id,\n                    variant_id=variant_id,\n                    quantity=quantity,\n                    price=variant.get('price', 0)\n                )\n                \n                return {\n                    'success': True,\n                    'message': f'Sale processed. Stock reduced by {quantity}',\n                    'new_stock': new_stock,\n                    'sold_quantity': quantity\n                }\n            else:\n                return {\n                    'success': False,\n                    'message': 'Failed to update stock'\n                }\n        \n        except Exception as e:\n            return {\n                'success': False,\n                'message': f'Error processing sale: {str(e)}'\n            }","size_bytes":19412},"product_commands.py":{"content":"\"\"\"\nProduct Catalog Commands for Telegram Bot\nHandles product browsing, variants, and purchasing\n\"\"\"\nfrom telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup\nfrom telegram.ext import ContextTypes, ConversationHandler, MessageHandler, filters, CallbackQueryHandler, CommandHandler\nfrom telegram.constants import ParseMode\nfrom product_catalog_system import ProductCatalogSystem, StockManagement\nfrom balance_system import BalanceSystem\nfrom advanced_data_manager import AdvancedDataManager\n\n# Conversation states\nPRODUCT_SEARCH = range(1)\n\nclass ProductCommands:\n    def __init__(self):\n        self.catalog_system = ProductCatalogSystem()\n        self.balance_system = BalanceSystem()\n        self.stock_management = StockManagement()\n        self.data_manager = AdvancedDataManager()\n    \n    async def browse_products_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Browse products by category\"\"\"\n        categories = self.catalog_system.get_categories()\n        \n        text = \"\"\"\nüõí **Browse Products**\n\nChoose a category to explore our products:\n\n**Available Categories:**\n\"\"\"\n        \n        keyboard = []\n        for category in categories:\n            text += f\"‚Ä¢ {category['emoji']} {category['name']} ({category['product_count']} products)\\n\"\n            keyboard.append([InlineKeyboardButton(\n                f\"{category['emoji']} {category['name']} ({category['product_count']})\",\n                callback_data=f\"category_{category['id']}\"\n            )])\n        \n        text += \"\\nüîç You can also search for specific products.\"\n        \n        keyboard.extend([\n            [InlineKeyboardButton(\"üîç Search Products\", callback_data=\"search_products\")],\n            [InlineKeyboardButton(\"‚≠ê Popular Products\", callback_data=\"popular_products\")],\n            [InlineKeyboardButton(\"üîô Main Menu\", callback_data=\"main_menu\")]\n        ])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        if update.callback_query:\n            await update.callback_query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        else:\n            await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_category_products(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show products in a specific category\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        category_id = query.data.replace(\"category_\", \"\")\n        category = self.catalog_system.get_category(category_id)\n        products = self.catalog_system.get_products_by_category(category_id)\n        \n        if not category:\n            await query.edit_message_text(\"‚ùå Category not found.\")\n            return\n        \n        text = f\"\"\"\n{category['emoji']} **{category['name']}**\n\n{category['description']}\n\n**Available Products ({len(products)}):**\n\"\"\"\n        \n        keyboard = []\n        \n        for product in products:\n            # Get cheapest variant price\n            min_price = min(v['price'] for v in product.get('variants', []))\n            max_price = max(v['price'] for v in product.get('variants', []))\n            \n            if min_price == max_price:\n                price_text = f\"‚Ç±{min_price:.0f}\"\n            else:\n                price_text = f\"‚Ç±{min_price:.0f}-‚Ç±{max_price:.0f}\"\n            \n            # Count available variants\n            available_variants = len([v for v in product.get('variants', []) if v.get('stock', 0) > 0])\n            \n            text += f\"‚Ä¢ **{product['name']}** - {price_text} ({available_variants} variants)\\n\"\n            \n            keyboard.append([InlineKeyboardButton(\n                f\"üì¶ {product['name']} - {price_text}\",\n                callback_data=f\"product_{product['id']}\"\n            )])\n        \n        keyboard.extend([\n            [InlineKeyboardButton(\"üîç Search in Category\", callback_data=f\"search_category_{category_id}\")],\n            [InlineKeyboardButton(\"üîô Back to Categories\", callback_data=\"browse_products\")]\n        ])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_product_details(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show detailed product information with variants\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        product_id = query.data.replace(\"product_\", \"\")\n        product = self.catalog_system.get_product(product_id)\n        \n        if not product:\n            await query.edit_message_text(\"‚ùå Product not found.\")\n            return\n        \n        category = self.catalog_system.get_category(product['category_id'])\n        \n        # Format like the premium bot's product display\n        text = f\"\"\"\n{category['emoji']} **{product['name']}**\n\n{product['description']}\n\n**Variants:**\n\"\"\"\n        \n        keyboard = []\n        \n        for i, variant in enumerate(product.get('variants', []), 1):\n            stock_text = f\"‚Ç±{variant['price']:.0f} | {variant['stock']}X\" if variant.get('stock', 0) > 0 else \"OUT OF STOCK\"\n            \n            text += f\"[{i}] {variant['name']} ‚Äî {stock_text}\\n\"\n            \n            if variant.get('stock', 0) > 0:\n                # Create button for available variants\n                keyboard.append([InlineKeyboardButton(\n                    f\"[{i}]\",\n                    callback_data=f\"variant_{product_id}_{variant['id']}\"\n                )])\n        \n        # Add variant selection buttons in rows\n        if len(keyboard) > 0:\n            text += \"\\n**Select a variant to purchase:**\"\n            \n            # Group buttons in rows of 4\n            button_rows = []\n            for i in range(0, len(keyboard), 4):\n                row = [btn[0] for btn in keyboard[i:i+4]]\n                button_rows.append(row)\n            \n            button_rows.append([InlineKeyboardButton(\"üîô Back\", callback_data=f\"category_{product['category_id']}\")])\n        else:\n            text += \"\\n‚ùå **All variants are currently out of stock.**\"\n            button_rows = [[InlineKeyboardButton(\"üîô Back\", callback_data=f\"category_{product['category_id']}\")]]\n        \n        reply_markup = InlineKeyboardMarkup(button_rows)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def show_variant_details(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show variant details and purchase options\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        # Parse callback data: variant_productid_variantid\n        parts = query.data.split('_')\n        product_id = parts[1]\n        variant_id = int(parts[2])\n        \n        user_telegram_id = str(update.effective_user.id)\n        \n        variant = self.catalog_system.get_product_variant(product_id, variant_id)\n        if not variant:\n            await query.edit_message_text(\"‚ùå Variant not found.\")\n            return\n        \n        # Get user balance\n        balance_info = self.balance_system.get_user_balance(user_telegram_id)\n        user_balance = balance_info['balance']\n        \n        # Check stock\n        stock_info = self.catalog_system.check_stock(product_id, variant_id)\n        \n        text = f\"\"\"\nüì¶ **{variant['product_name']}**\nüéØ **{variant['name']}**\n\nüí∞ **Price:** ‚Ç±{variant['price']:.2f}\n‚è±Ô∏è **Duration:** {variant.get('duration', 'Lifetime')}\nüì¶ **Stock:** {stock_info['stock']} available\n\n**Features:**\n\"\"\"\n        \n        for feature in variant.get('features', []):\n            text += f\"‚Ä¢ {feature}\\n\"\n        \n        text += f\"\\nüí≥ **Your Balance:** ‚Ç±{user_balance:.2f}\"\n        \n        # Check if user can afford\n        can_afford = user_balance >= variant['price']\n        \n        keyboard = []\n        \n        if stock_info['available'] and can_afford:\n            text += \"\\n‚úÖ **Ready to purchase!**\"\n            keyboard.append([InlineKeyboardButton(\"üí∞ Buy Now\", callback_data=f\"buy_{product_id}_{variant_id}\")])\n        elif not stock_info['available']:\n            text += \"\\n‚ùå **Out of stock**\"\n        elif not can_afford:\n            needed = variant['price'] - user_balance\n            text += f\"\\n‚ö†Ô∏è **Insufficient balance**\\nYou need ‚Ç±{needed:.2f} more to purchase this item.\"\n            keyboard.append([InlineKeyboardButton(\"üí≥ Top Up Balance\", callback_data=\"deposit_balance\")])\n        \n        keyboard.extend([\n            [InlineKeyboardButton(\"üîô Back to Product\", callback_data=f\"product_{product_id}\")],\n            [InlineKeyboardButton(\"üè† Main Menu\", callback_data=\"main_menu\")]\n        ])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def process_purchase(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Process variant purchase using balance\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        # Parse callback data: buy_productid_variantid\n        parts = query.data.split('_')\n        product_id = parts[1]\n        variant_id = int(parts[2])\n        \n        user_telegram_id = str(update.effective_user.id)\n        \n        variant = self.catalog_system.get_product_variant(product_id, variant_id)\n        if not variant:\n            await query.edit_message_text(\"‚ùå Product variant not found.\")\n            return\n        \n        # Check stock availability\n        stock_info = self.catalog_system.check_stock(product_id, variant_id)\n        if not stock_info['available']:\n            await query.edit_message_text(\"‚ùå Sorry, this item is now out of stock.\")\n            return\n        \n        # Process payment from balance\n        spend_result = self.balance_system.spend_balance(\n            user_telegram_id,\n            variant['price'],\n            f\"Purchase: {variant['name']}\"\n        )\n        \n        if not spend_result['success']:\n            text = f\"\"\"\n‚ùå **Purchase Failed**\n\n{spend_result['message']}\n\nüí≥ Current Balance: ‚Ç±{spend_result.get('current_balance', 0):.2f}\nüí∞ Required: ‚Ç±{spend_result.get('required', variant['price']):.2f}\nüìâ Shortfall: ‚Ç±{spend_result.get('shortfall', 0):.2f}\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üí≥ Top Up Balance\", callback_data=\"deposit_balance\")],\n                [InlineKeyboardButton(\"üîô Back\", callback_data=f\"variant_{product_id}_{variant_id}\")]\n            ]\n            reply_markup = InlineKeyboardMarkup(keyboard)\n            \n            await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n            return\n        \n        # Process stock reduction\n        stock_result = self.stock_management.process_sale(product_id, variant_id, 1)\n        \n        if not stock_result['success']:\n            # Refund the balance since stock update failed\n            await query.edit_message_text(f\"‚ùå Purchase failed: {stock_result['message']}\")\n            return\n        \n        # Create order record\n        from datetime import datetime\n        order = {\n            'id': len(self.data_manager.get_orders()) + 1,\n            'user_telegram_id': user_telegram_id,\n            'product_name': variant['name'],\n            'total': variant['price'],\n            'status': 'completed',\n            'created_at': datetime.utcnow().isoformat()\n        }\n        \n        # Success message\n        text = f\"\"\"\nüéâ **Purchase Successful!**\n\n‚úÖ **Product:** {variant['name']}\nüí∞ **Paid:** ‚Ç±{variant['price']:.2f}\nüí≥ **New Balance:** ‚Ç±{spend_result['new_balance']:.2f}\nüì¶ **Order ID:** #{order.get('id', 'N/A')}\n\n**Product Details:**\nüì¶ Your {variant['name']} is now active!\n‚è±Ô∏è Duration: {variant.get('duration', 'Lifetime')}\n\n**Next Steps:**\n‚Ä¢ Check your orders for details\n‚Ä¢ Contact support if you need help\n‚Ä¢ Leave feedback about your purchase\n\nThank you for your purchase! üôè\n        \"\"\"\n        \n        keyboard = [\n            [\n                InlineKeyboardButton(\"üì¶ My Orders\", callback_data=\"my_orders\"),\n                InlineKeyboardButton(\"üí¨ Customer Service\", callback_data=\"customer_service\")\n            ],\n            [\n                InlineKeyboardButton(\"üõí Buy More\", callback_data=\"browse_products\"),\n                InlineKeyboardButton(\"üè† Main Menu\", callback_data=\"main_menu\")\n            ]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        \n        # Update user statistics\n        await self._update_user_stats(user_telegram_id, variant['price'])\n    \n    async def _update_user_stats(self, user_telegram_id: str, amount: float):\n        \"\"\"Update user statistics after purchase\"\"\"\n        user = self.data_manager.get_or_create_user(user_telegram_id)\n        \n        current_spent = user.get('total_spent', 0)\n        order_count = user.get('order_count', 0)\n        \n        self.data_manager.update_user_spending(\n            user_telegram_id,\n            user.get('balance', 0),  # Balance already updated by balance system\n            current_spent + amount,\n            order_count + 1\n        )\n    \n    async def search_products(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Start product search\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        text = \"\"\"\nüîç **Search Products**\n\nType the name of the product you're looking for:\n\n**Search Tips:**\n‚Ä¢ Enter product names (e.g., \"Netflix\", \"Spotify\")\n‚Ä¢ Use keywords (e.g., \"streaming\", \"premium\")\n‚Ä¢ Search by category (e.g., \"editing\", \"gaming\")\n\nWhat are you looking for?\n        \"\"\"\n        \n        keyboard = [\n            [InlineKeyboardButton(\"‚ùå Cancel\", callback_data=\"browse_products\")]\n        ]\n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return PRODUCT_SEARCH\n    \n    async def handle_product_search(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Handle product search query\"\"\"\n        search_query = update.message.text.strip()\n        \n        if len(search_query) < 2:\n            await update.message.reply_text(\n                \"‚ùå Please enter at least 2 characters to search.\"\n            )\n            return PRODUCT_SEARCH\n        \n        # Search products\n        results = self.catalog_system.search_products(search_query, limit=10)\n        \n        if not results:\n            text = f\"\"\"\nüîç **Search Results for \"{search_query}\"**\n\n‚ùå No products found matching your search.\n\n**Suggestions:**\n‚Ä¢ Try different keywords\n‚Ä¢ Check spelling\n‚Ä¢ Browse categories instead\n            \"\"\"\n            \n            keyboard = [\n                [InlineKeyboardButton(\"üõí Browse Categories\", callback_data=\"browse_products\")],\n                [InlineKeyboardButton(\"üîç Search Again\", callback_data=\"search_products\")]\n            ]\n        else:\n            text = f\"\"\"\nüîç **Search Results for \"{search_query}\"**\n\nFound {len(results)} result(s):\n\"\"\"\n            \n            keyboard = []\n            \n            for result in results:\n                product = result['product']\n                \n                if result['match_type'] == 'variant':\n                    # Specific variant match\n                    variant = result['variant']\n                    text += f\"‚Ä¢ **{variant['name']}** - ‚Ç±{variant['price']:.0f}\\n\"\n                    keyboard.append([InlineKeyboardButton(\n                        f\"üì¶ {variant['name']} - ‚Ç±{variant['price']:.0f}\",\n                        callback_data=f\"variant_{product['id']}_{variant['id']}\"\n                    )])\n                else:\n                    # Product match\n                    min_price = min(v['price'] for v in product.get('variants', []))\n                    text += f\"‚Ä¢ **{product['name']}** - from ‚Ç±{min_price:.0f}\\n\"\n                    keyboard.append([InlineKeyboardButton(\n                        f\"üì¶ {product['name']} - from ‚Ç±{min_price:.0f}\",\n                        callback_data=f\"product_{product['id']}\"\n                    )])\n            \n            keyboard.extend([\n                [InlineKeyboardButton(\"üîç New Search\", callback_data=\"search_products\")],\n                [InlineKeyboardButton(\"üõí Browse Categories\", callback_data=\"browse_products\")]\n            ])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await update.message.reply_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n        return ConversationHandler.END\n    \n    async def show_popular_products(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Show popular products\"\"\"\n        query = update.callback_query\n        await query.answer()\n        \n        popular = self.catalog_system.get_popular_products()\n        \n        text = \"\"\"\n‚≠ê **Popular Products**\n\nOur most popular items:\n\"\"\"\n        \n        keyboard = []\n        \n        for item in popular:\n            variant = item['variant']\n            text += f\"‚Ä¢ **{variant['name']}** - ‚Ç±{variant['price']:.0f} ‚≠ê\\n\"\n            \n            keyboard.append([InlineKeyboardButton(\n                f\"‚≠ê {variant['name']} - ‚Ç±{variant['price']:.0f}\",\n                callback_data=f\"variant_{item['product_id']}_{variant['id']}\"\n            )])\n        \n        keyboard.extend([\n            [InlineKeyboardButton(\"üõí Browse All\", callback_data=\"browse_products\")],\n            [InlineKeyboardButton(\"üîç Search\", callback_data=\"search_products\")],\n            [InlineKeyboardButton(\"üîô Main Menu\", callback_data=\"main_menu\")]\n        ])\n        \n        reply_markup = InlineKeyboardMarkup(keyboard)\n        \n        await query.edit_message_text(text, reply_markup=reply_markup, parse_mode=ParseMode.MARKDOWN)\n    \n    async def cancel_search(self, update: Update, context: ContextTypes.DEFAULT_TYPE):\n        \"\"\"Cancel product search\"\"\"\n        if update.callback_query:\n            await update.callback_query.edit_message_text(\"‚ùå Search cancelled.\")\n        else:\n            await update.message.reply_text(\"‚ùå Search cancelled.\")\n        \n        return ConversationHandler.END\n\ndef get_product_conversation_handler():\n    \"\"\"Get conversation handler for product system\"\"\"\n    product_commands = ProductCommands()\n    \n    return ConversationHandler(\n        entry_points=[\n            CallbackQueryHandler(product_commands.search_products, pattern=\"^search_products$\")\n        ],\n        states={\n            PRODUCT_SEARCH: [MessageHandler(filters.TEXT & ~filters.COMMAND, product_commands.handle_product_search)]\n        },\n        fallbacks=[\n            CallbackQueryHandler(product_commands.cancel_search, pattern=\"^browse_products$\"),\n            CommandHandler('cancel', product_commands.cancel_search)\n        ],\n        per_message=False\n    )\n\ndef get_product_callback_handlers():\n    \"\"\"Get product system callback handlers\"\"\"\n    product_commands = ProductCommands()\n    \n    return [\n        CallbackQueryHandler(product_commands.browse_products_command, pattern=\"^browse_products$\"),\n        CallbackQueryHandler(product_commands.show_category_products, pattern=\"^category_\"),\n        CallbackQueryHandler(product_commands.show_product_details, pattern=\"^product_\"),\n        CallbackQueryHandler(product_commands.show_variant_details, pattern=\"^variant_\"),\n        CallbackQueryHandler(product_commands.process_purchase, pattern=\"^buy_\"),\n        CallbackQueryHandler(product_commands.show_popular_products, pattern=\"^popular_products$\")\n    ]","size_bytes":20046},"simple_data_manager.py":{"content":"\"\"\"\nSimple Data Manager - JSON-based storage for immediate functionality\n\"\"\"\nimport json\nimport os\nfrom datetime import datetime\nfrom typing import Dict, List, Optional\n\nclass SimpleDataManager:\n    def __init__(self):\n        self.data_dir = \"data\"\n        self.ensure_data_dir()\n        self.ensure_data_files()\n        self._add_balance_methods()\n    \n    def ensure_data_dir(self):\n        \"\"\"Create data directory if it doesn't exist\"\"\"\n        if not os.path.exists(self.data_dir):\n            os.makedirs(self.data_dir)\n    \n    def ensure_data_files(self):\n        \"\"\"Create data files with default data if they don't exist\"\"\"\n        files = {\n            'users.json': {},\n            'products.json': self.get_default_products(),\n            'orders.json': {},\n            'deposits.json': {},\n            'settings.json': {\n                'welcome_message': 'Welcome to Premium Store!',\n                'support_message': 'Contact support for help.'\n            }\n        }\n        \n        for filename, default_data in files.items():\n            filepath = os.path.join(self.data_dir, filename)\n            if not os.path.exists(filepath):\n                with open(filepath, 'w') as f:\n                    json.dump(default_data, f, indent=2)\n    \n    def get_default_products(self):\n        \"\"\"Get default product catalog\"\"\"\n        return {\n            \"1\": {\n                \"id\": \"1\",\n                \"name\": \"Netflix Premium\",\n                \"description\": \"1 Month Netflix Premium Account\",\n                \"category_id\": \"streaming\",\n                \"price\": 150.0,\n                \"variants\": [\n                    {\"id\": 1, \"name\": \"1 Month\", \"price\": 150.0, \"stock\": 25},\n                    {\"id\": 2, \"name\": \"3 Months\", \"price\": 400.0, \"stock\": 15}\n                ],\n                \"emoji\": \"üì∫\"\n            },\n            \"2\": {\n                \"id\": \"2\", \n                \"name\": \"Spotify Premium\",\n                \"description\": \"1 Month Spotify Premium\",\n                \"category_id\": \"music\",\n                \"price\": 120.0,\n                \"variants\": [\n                    {\"id\": 1, \"name\": \"Individual\", \"price\": 120.0, \"stock\": 30},\n                    {\"id\": 2, \"name\": \"Family\", \"price\": 180.0, \"stock\": 10}\n                ],\n                \"emoji\": \"üéµ\"\n            }\n        }\n    \n    def load_data(self, filename: str) -> Dict:\n        \"\"\"Load data from JSON file\"\"\"\n        filepath = os.path.join(self.data_dir, filename)\n        try:\n            with open(filepath, 'r') as f:\n                data = json.load(f)\n                # Ensure we return a dict, not a list\n                if isinstance(data, dict):\n                    return data\n                else:\n                    return {}\n        except (FileNotFoundError, json.JSONDecodeError):\n            return {}\n    \n    def save_data(self, filename: str, data: Dict):\n        \"\"\"Save data to JSON file\"\"\"\n        filepath = os.path.join(self.data_dir, filename)\n        with open(filepath, 'w') as f:\n            json.dump(data, f, indent=2)\n    \n    def get_or_create_user(self, telegram_id: str, first_name: str = \"Unknown\") -> Dict:\n        \"\"\"Get or create user\"\"\"\n        users = self.load_data('users.json')\n        \n        if telegram_id not in users:\n            users[telegram_id] = {\n                'telegram_id': telegram_id,\n                'first_name': first_name,\n                'balance': 0.0,\n                'total_deposited': 0.0,\n                'total_spent': 0.0,\n                'order_count': 0,\n                'created_at': datetime.utcnow().isoformat(),\n                'last_activity': datetime.utcnow().isoformat()\n            }\n            self.save_data('users.json', users)\n        \n        return users[telegram_id]\n    \n    def get_users(self) -> List[Dict]:\n        \"\"\"Get all users\"\"\"\n        users = self.load_data('users.json')\n        return list(users.values())\n    \n    def get_products(self) -> Dict:\n        \"\"\"Get all products\"\"\"\n        return self.load_data('products.json')\n    \n    def get_orders(self) -> Dict:\n        \"\"\"Get all orders\"\"\"\n        return self.load_data('orders.json')\n    \n    def get_categories(self) -> List[Dict]:\n        \"\"\"Get product categories\"\"\"\n        return [\n            {'id': 'streaming', 'name': 'üì∫ Streaming', 'emoji': 'üì∫'},\n            {'id': 'music', 'name': 'üéµ Music', 'emoji': 'üéµ'},\n            {'id': 'gaming', 'name': 'üéÆ Gaming', 'emoji': 'üéÆ'},\n            {'id': 'vpn', 'name': 'üîí VPN', 'emoji': 'üîí'}\n        ]\n    \n    def get_products_by_category(self, category_id: str) -> List[Dict]:\n        \"\"\"Get products by category\"\"\"\n        products = self.get_products()\n        return [p for p in products.values() if p.get('category_id') == category_id]\n    \n    def _add_balance_methods(self):\n        \"\"\"Add balance system methods\"\"\"\n        \n        def get_deposits(user_telegram_id: str = None, status: str = None):\n            \"\"\"Get deposits with optional filters\"\"\"\n            deposits = self.load_data('deposits.json')\n            result = list(deposits.values())\n            \n            if user_telegram_id:\n                result = [d for d in result if d.get('user_telegram_id') == user_telegram_id]\n            if status:\n                result = [d for d in result if d.get('status') == status]\n            \n            return result\n        \n        def create_deposit(user_telegram_id: str, deposit_id: str, amount: float, \n                          payment_method: str, status: str = 'pending'):\n            \"\"\"Create new deposit record\"\"\"\n            deposits = self.load_data('deposits.json')\n            \n            deposit = {\n                'id': len(deposits) + 1,\n                'deposit_id': deposit_id,\n                'user_telegram_id': user_telegram_id,\n                'amount': amount,\n                'payment_method': payment_method,\n                'status': status,\n                'created_at': datetime.utcnow().isoformat(),\n                'updated_at': datetime.utcnow().isoformat()\n            }\n            \n            deposits[str(deposit['id'])] = deposit\n            self.save_data('deposits.json', deposits)\n            return deposit\n        \n        def update_deposit_status(deposit_id: str, status: str, notes: str = ''):\n            \"\"\"Update deposit status\"\"\"\n            deposits = self.load_data('deposits.json')\n            \n            for dep in deposits.values():\n                if dep.get('deposit_id') == deposit_id:\n                    dep['status'] = status\n                    dep['updated_at'] = datetime.utcnow().isoformat()\n                    if notes:\n                        dep['notes'] = notes\n                    break\n            \n            self.save_data('deposits.json', deposits)\n            return True\n        \n        def get_deposits_by_status(status: str):\n            \"\"\"Get deposits by status\"\"\"\n            return get_deposits(status=status)\n        \n        def update_user_balance(user_telegram_id: str, new_balance: float, total_deposited: float):\n            \"\"\"Update user balance\"\"\"\n            users = self.load_data('users.json')\n            \n            if user_telegram_id in users:\n                users[user_telegram_id]['balance'] = new_balance\n                users[user_telegram_id]['total_deposited'] = total_deposited\n                users[user_telegram_id]['last_activity'] = datetime.utcnow().isoformat()\n                self.save_data('users.json', users)\n            \n            return True\n        \n        def update_user_spending(user_telegram_id: str, balance: float, total_spent: float, order_count: int = None):\n            \"\"\"Update user spending\"\"\"\n            users = self.load_data('users.json')\n            \n            if user_telegram_id in users:\n                users[user_telegram_id]['balance'] = balance\n                users[user_telegram_id]['total_spent'] = total_spent\n                if order_count is not None:\n                    users[user_telegram_id]['order_count'] = order_count\n                users[user_telegram_id]['last_activity'] = datetime.utcnow().isoformat()\n                self.save_data('users.json', users)\n            \n            return True\n        \n        def create_balance_transaction(user_telegram_id: str, amount: float, \n                                     transaction_type: str, description: str, balance_after: float):\n            \"\"\"Create balance transaction\"\"\"\n            return {\n                'id': 1,\n                'user_telegram_id': user_telegram_id,\n                'amount': amount,\n                'transaction_type': transaction_type,\n                'description': description,\n                'balance_after': balance_after,\n                'created_at': datetime.utcnow().isoformat()\n            }\n        \n        def get_balance_transactions(user_telegram_id: str):\n            \"\"\"Get balance transactions\"\"\"\n            return [{\n                'id': 1,\n                'user_telegram_id': user_telegram_id,\n                'amount': 0.0,\n                'transaction_type': 'deposit',\n                'description': 'Initial balance',\n                'balance_after': 0.0,\n                'created_at': datetime.utcnow().isoformat()\n            }]\n        \n        def update_variant_stock(product_id: str, variant_id: int, new_stock: int):\n            \"\"\"Update variant stock\"\"\"\n            products = self.get_products()\n            \n            if product_id in products:\n                for variant in products[product_id].get('variants', []):\n                    if variant['id'] == variant_id:\n                        variant['stock'] = new_stock\n                        break\n                self.save_data('products.json', products)\n            \n            return True\n        \n        def record_product_sale(product_id: str, variant_id: int, quantity: int, price: float):\n            \"\"\"Record product sale\"\"\"\n            return True\n        \n        # Assign methods to self\n        self.get_deposits = get_deposits\n        self.create_deposit = create_deposit\n        self.update_deposit_status = update_deposit_status\n        self.get_deposits_by_status = get_deposits_by_status\n        self.update_user_balance = update_user_balance\n        self.update_user_spending = update_user_spending\n        self.create_balance_transaction = create_balance_transaction\n        self.get_balance_transactions = get_balance_transactions\n        self.update_variant_stock = update_variant_stock\n        self.record_product_sale = record_product_sale","size_bytes":10576},"attached_assets/content-1757397650890.md":{"content":"[Download](https://telegram.org/dl?tme=842248175833dd4742_5414393342116189793)\n\n[![](https://cdn5.telesco.pe/file/HMeCZF_x3Skd7HPSHnBXhHRNKZ_LxRqR83XQW5s0sy1Yfid-okHadYUKcC7_9gcYBzGN_p_3lwZHCxWIlTr5XjHYvdh8sofoOc4Db_qVaEQoy9IWPxFZLFhMhMZE7T5K-1r8fiyPCl4-63SflbFWaMf9H0SOwAdPwz4JkXL1ySat4IaTBV5ZrkVJRY1naxT_RElk1hj0BCuJYi-tikDKWKgFQTj7xrON4Lbo20CN1VYjibKqEir1PRa8LjzQdgKSfAZqvlPJGI3pIZSsLDbA5MTVEYAdM2np1Qw2sza9-onWknADiZf5c-s3InhcoVMd5xmRTptd3BDSk5Ux0Ua2Gg.jpg)](tg://resolve?domain=MRPremiumShopBot)\n\nMR Premium Shop\n\n@MRPremiumShopBot\n\n[Start Bot](tg://resolve?domain=MRPremiumShopBot)\n\nIf you have **Telegram**, you can launch\n\n**MR Premium Shop** right away.","size_bytes":662},"attached_assets/content-1757397851548.md":{"content":"[Download](https://telegram.org/dl?tme=5fd2d0ffc42ec5f5cb_14829601859824500456)\n\n[![](https://cdn5.telesco.pe/file/vogGkuoghgXs0Vm6yRAWDFNnYejxK9v5iNK__JfrOgYt1WWPdiFy0P0Noh6IOryNgNgFS6yDQ3PQIjn97oJ1NnAtu0zpYtRmRhnms_u-Sh_w8-TXco48efEqMoeZTP0LNhL9SekBmdWoBGwsmY0ervj8FIJGLGPZFuoJH9GTrVTus9UbueTKRTxsEObdYywKOZjRd_ZHRFRCiRlpkI9b93ExkXbjWp_7-xRAIWC78ZNDXvrdHEYtVL-lUGjXw-q2HC4WeHzs2_P6MXQktOwhRXSRwTAKMRVpCVPPUUwyBq8FaGqpiukWIaATXKjLomQl2Jc_-p8NGt-Uhj_DSIZouQ.jpg)](tg://resolve?domain=primostorebot)\n\nPRIMO STORE\n\n@primostorebot\n\nBUYING = YOU ACCEPT OUR RULES\n\n[Start Bot](tg://resolve?domain=primostorebot)\n\nIf you have **Telegram**, you can launch\n\n**PRIMO STORE** right away.","size_bytes":677}},"version":1}